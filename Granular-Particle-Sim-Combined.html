<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Life Simulator - GPU Optimized</title>
    <style>
        /* Tab Interface Styles */
        .tab-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #111;
            border-bottom: 2px solid #333;
            z-index: 1000;
            display: flex;
            justify-content: center;
            padding: 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .tab-button {
            background: #222;
            color: #ccc;
            border: none;
            padding: 15px 30px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            min-width: 200px;
        }

        .tab-button:hover {
            background: #333;
            color: #fff;
        }

        .tab-button.active {
            background: #444;
            color: #4CAF50;
            border-bottom-color: #4CAF50;
        }

        .tab-content {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 10;
            pointer-events: none;
        }

        .tab-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 400px;
            height: 100%;
            background: #111;
            border-right: 2px solid #333;
            transform: translateX(-100%);
            transition: transform 0.4s ease;
            pointer-events: auto;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            z-index: 1;
        }

        .tab-panel.active {
            transform: translateX(0);
            z-index: 2;
        }

        .tab-panel .control-panel {
            width: 100%;
            height: 100%;
            padding: 20px;
            overflow-y: auto;
            max-height: none;
            position: static;
            border: none;
            border-radius: 0;
            background: #111;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow-x: hidden;
        }
        
        .main-content {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 5;
            /* Ensure canvas stays in front of scrollbars and properly centered */
            overflow: hidden;
            background: #000;
        }
        canvas {
            border: 1px solid #333;
            display: block;
        }
        #canvas {
            position: relative;
            z-index: 2;
            background: #000;
        }
        .control-panel {
            width: 100%;
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 0;
            height: 100%;
            position: static;
            overflow-y: auto;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group h3 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 6px;
        }
        .slider-row {
            margin-bottom: 10px;
        }
        .slider-row label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #ccc;
        }
        .checkbox-label {
            display: flex !important;
            align-items: center;
        }
        .slider-row label input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
        }
        .value-display {
            min-width: 50px;
            text-align: right;
            font-size: 12px;
            color: #888;
            font-family: monospace;
        }
        .species-a { color: #ff4444; }
        .species-b { color: #4444ff; }
        
        /* Particle Settings Styles */
        .particle-settings {
            margin-bottom: 15px;
        }
        .species-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
            font-size: 14px;
        }
        .species-label {
            min-width: 70px;
            font-weight: bold;
        }
        .param-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .param-label {
            color: #ccc;
            font-size: 12px;
        }
        .draggable-number {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: ns-resize;
            user-select: none;
            min-width: 40px;
            text-align: center;
            font-family: monospace;
            font-size: 12px;
        }
        .draggable-number:hover {
            background: #444;
            border-color: #666;
        }
        .draggable-number.dragging {
            background: #555;
            border-color: #888;
        }
        
        /* Force Matrix Styles */
        .matrix-container {
            margin-top: 15px;
        }
        .matrix-grid {
            display: grid;
            gap: 0px;
            background: #555;
            border: 2px solid #666;
            border-radius: 4px;
            overflow: hidden;
        }
        .matrix-header {
            background: #222;
            padding: 6px;
            text-align: center;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            border: 2px solid #444;
        }
        .species-color-picker {
            width: 20px;
            height: 20px;
            border: 1px solid #666;
            border-radius: 3px;
            cursor: pointer;
            padding: 0;
        }
        .matrix-cell {
            background: #444;
            padding: 0;
            text-align: center;
            font-size: 10px;
            font-weight: bold;
            cursor: ns-resize;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: background-color 0.1s ease;
            border: 2px solid #333;
        }
        .matrix-cell:hover {
            border: 2px solid #888;
        }
        .matrix-cell.dragging {
            border: 2px solid #fff;
        }
        .force-legend {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 10px;
            color: #888;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        .controls {
            text-align: center;
            margin: 20px;
        }
        button {
            background: #333;
            color: #fff;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            border-radius: 5px;
        }
        button:hover {
            background: #555;
        }
        
        /* Responsive design for tabbed interface */
        @media (max-width: 1024px) {
            .tab-panel {
                width: 320px;
            }
            .tab-button {
                min-width: 180px;
                padding: 12px 20px;
                font-size: 13px;
            }
        }
        
        @media (max-width: 768px) {
            .tab-header {
                flex-direction: column;
                height: auto;
                position: relative;
            }
            
            .tab-button {
                min-width: auto;
                width: 100%;
                padding: 15px;
                border-bottom: 1px solid #333;
                border-right: none;
            }
            
            .tab-button.active {
                border-bottom-color: #4CAF50;
                border-right-color: transparent;
            }
            
            .tab-content {
                position: relative;
                top: 0;
                height: 40vh;
            }
            
            .tab-panel {
                width: 100%;
                left: 0;
                transform: translateY(-100%);
                border-right: none;
                border-bottom: 2px solid #333;
            }
            
            .tab-panel.active {
                transform: translateY(0);
            }
            
            .main-content {
                position: relative;
                top: 0;
                height: 60vh;
                min-height: 60vh;
            }
        }
        
        @media (max-width: 480px) {
            .tab-content {
                height: 45vh;
            }
            
            .main-content {
                height: 55vh;
                min-height: 55vh;
            }
            
            .tab-button {
                font-size: 12px;
                padding: 12px;
            }
        }
        
        /* Audio Control Styles */
        .audio-master-controls {
            margin-bottom: 15px;
            padding: 10px;
            background: #0a0a0a;
            border: 1px solid #444;
            border-radius: 6px;
        }
        
        /* Species Tab System */
        .species-tab-container {
            margin-bottom: 15px;
        }
        
        /* Audio Mode Tab System */
        .audio-mode-tabs {
            display: flex;
            margin-bottom: 15px;
            background: #1a1a1a;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #333;
        }
        
        .audio-mode-tab {
            flex: 1;
            padding: 12px 16px;
            background: #222;
            color: #ccc;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .audio-mode-tab:hover {
            background: #333;
            color: #fff;
        }
        
        .audio-mode-tab.active {
            background: #4CAF50;
            color: #000;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .audio-mode-tab:first-child {
            border-right: 1px solid #333;
        }
        
        .audio-mode-content {
            min-height: 200px;
        }
        
        .audio-mode-panel {
            display: none;
        }
        
        .audio-mode-panel.active {
            display: block;
        }
        
        /* Threshold with visualization */
        .threshold-container {
            position: relative;
            margin-bottom: 12px;
        }
        
        .threshold-visualization {
            position: absolute;
            top: 0;
            left: 0;
            right: 50px; /* Space for value display */
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            z-index: 1;
        }
        
        .velocity-level-bar {
            height: 100%;
            background: linear-gradient(to right, #4CAF50 0%, #FFC107 50%, #FF5722 100%);
            width: 0%;
            transition: width 0.1s ease;
        }
        
        .threshold-slider {
            position: relative;
            z-index: 2;
            background: transparent !important;
        }
        
        .threshold-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #4CAF50;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .species-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 15px;
            padding: 10px;
            background: #0a0a0a;
            border: 1px solid #444;
            border-radius: 6px;
        }
        
        .species-tab {
            flex: 1;
            min-width: 80px;
            padding: 8px 12px;
            background: #222;
            border: 2px solid #444;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }
        
        .species-tab:hover {
            background: #333;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .species-tab.active {
            background: #444;
            border-color: currentColor;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            transform: translateY(-2px);
        }
        
        .species-tab-label {
            display: block;
            margin-bottom: 2px;
        }
        
        .species-tab-info {
            font-size: 10px;
            opacity: 0.8;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .species-audio-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
            transition: background-color 0.2s ease;
        }
        
        .species-audio-status.active {
            background: #4CAF50;
            box-shadow: 0 0 4px #4CAF50;
        }
        
        /* Collapsible Sections */
        .collapsible-section {
            margin-bottom: 15px;
        }
        
        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }
        
        .collapsible-header:hover {
            background: #252525;
        }
        
        .collapsible-header h3 {
            margin: 0;
            font-size: 15px;
        }
        
        .collapsible-toggle {
            font-size: 14px;
            transition: transform 0.2s ease;
        }
        
        .collapsible-content {
            border: 1px solid #444;
            border-top: none;
            border-radius: 0 0 6px 6px;
            background: #111;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .collapsible-content.collapsed {
            max-height: 0;
            border: none;
        }
        
        .collapsible-content:not(.collapsed) {
            max-height: 1000px;
        }
        
        .collapsible-section.collapsed .collapsible-toggle {
            transform: rotate(180deg);
        }
        
        .collapsible-inner {
            padding: 15px;
        }
        
        .audio-button {
            background: #444;
            color: #fff;
            border: none;
            padding: 4px 8px;
            margin-left: 8px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
            min-width: 35px;
        }
        
        .audio-button:hover {
            background: #666;
        }
        
        .audio-button.active {
            background: #4CAF50;
        }
        
        .loop-controls {
            display: flex;
            gap: 4px;
            flex: 1;
        }
        
        .loop-button {
            min-width: 32px;
            height: 24px;
            padding: 2px 6px;
            font-size: 12px;
            background: #444;
            color: #fff;
            border: 1px solid #666;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .loop-button:hover {
            background: #555;
            border-color: #777;
        }
        
        .loop-button.active {
            background: #4CAF50;
            color: #000;
            border-color: #4CAF50;
        }
        
        .freq-range-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .freq-range {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .freq-label {
            min-width: 35px;
            font-size: 12px;
            color: #ccc;
        }
        
        .freq-slider {
            flex: 1;
        }
        
        .audio-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 12px;
        }
        
        .species-audio-container {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .species-audio-panel {
            margin-bottom: 15px;
            padding: 12px;
            background: #0f0f0f;
            border: 1px solid #333;
            border-radius: 6px;
        }
        
        .species-audio-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .species-audio-title {
            font-weight: bold;
            font-size: 14px;
        }
        
        .audio-file-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .file-input-label {
            background: #333;
            color: #fff;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            border: 1px solid #555;
        }
        
        .file-input-label:hover {
            background: #444;
        }
        
        .file-name {
            flex: 1;
            font-size: 11px;
            color: #888;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .waveform-container {
            width: 100%;
            height: 40px;
            background: #222;
            border: 1px solid #444;
            border-radius: 3px;
            margin-bottom: 8px;
            position: relative;
            overflow: hidden;
        }
        
        .waveform-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .audio-controls-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .audio-controls-group {
            background: #0f0f0f;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }
        
        .audio-controls-group h4 {
            margin: 0 0 10px 0;
            color: #ccc;
            font-size: 13px;
            border-bottom: 1px solid #333;
            padding-bottom: 6px;
        }
        
        .grain-activity {
            display: flex;
            gap: 2px;
            flex-wrap: wrap;
        }
        
        .grain-indicator {
            width: 8px;
            height: 8px;
            background: #333;
            border-radius: 50%;
            transition: background-color 0.1s ease;
        }
        
        .grain-indicator.active {
            background: #4CAF50;
        }
        
        .audio-meter {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
        }
        
        .meter-bar {
            width: 50px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .meter-fill {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #FFC107, #FF5722);
            width: 0%;
            transition: width 0.1s ease;
        }
        
        /* Rotary Dial for Ratio Control */
        .ratio-dial-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 12px;
        }
        
        .ratio-dial {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #333;
            border: 3px solid #555;
            position: relative;
            cursor: pointer;
            transition: border-color 0.2s ease;
        }
        
        .ratio-dial:hover {
            border-color: #4CAF50;
        }
        
        .ratio-dial-indicator {
            position: absolute;
            top: 3px;
            left: 50%;
            width: 3px;
            height: 20px;
            background: #4CAF50;
            transform-origin: center bottom;
            transform: translateX(-50%) rotate(0deg);
            border-radius: 2px;
            transition: transform 0.1s ease;
        }
        
        .ratio-dial-label {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 4px;
        }
        
        .ratio-dial-value {
            font-size: 14px;
            font-weight: bold;
            color: #4CAF50;
            text-align: center;
        }
        
    </style>
</head>
<body>
    <!-- Tab Navigation Header -->
    <div class="tab-header">
        <button class="tab-button active" data-tab="physics">
            ⚛️ Physics & Simulation
        </button>
        <button class="tab-button" data-tab="audio">
            🎵 Audio Engine
        </button>
    </div>

    <!-- Tabbed Control Panels -->
    <div class="tab-content">
        <!-- Physics & Simulation Panel -->
        <div class="tab-panel active" id="physics-panel">
            <div class="control-panel physics-panel">
        <div class="collapsible-section" id="presetSection">
            <div class="collapsible-header" onclick="toggleCollapsible('presetSection')">
                <h3>Presets & Control</h3>
                <span class="collapsible-toggle">▼</span>
            </div>
            <div class="collapsible-content" id="presetContent">
                <div class="collapsible-inner">
                    <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                        <button onclick="savePreset()" style="flex: 1; background: #2a5f2a; font-size: 12px; padding: 8px;">💾 Save</button>
                        <button onclick="loadPreset()" style="flex: 1; background: #2a2a5f; font-size: 12px; padding: 8px;">📁 Load</button>
                        <button onclick="exportPreset()" style="flex: 1; background: #5f2a5f; font-size: 12px; padding: 8px;">📤 Export</button>
                    </div>
                    <div style="display: flex; gap: 8px; margin-bottom: 15px;">
                        <select id="presetSelect" style="flex: 1; background: #333; color: #fff; border: 1px solid #555; padding: 5px; border-radius: 3px; font-size: 12px;">
                            <option value="">Select Preset...</option>
                        </select>
                        <button onclick="deletePreset()" style="background: #5f2a2a; font-size: 12px; padding: 5px 10px;">🗑️</button>
                    </div>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button onclick="resetSimulation()" style="flex: 1; font-size: 12px; padding: 8px;">🔄 Reset</button>
                        <button onclick="togglePause()" style="flex: 1; font-size: 12px; padding: 8px;">⏯️ Pause</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <div class="slider-row">
                <label>Canvas Width</label>
                <div class="slider-container">
                    <span class="draggable-number" id="canvas-width">1200</span>
                    <span style="color: #888; font-size: 12px;">px</span>
                </div>
            </div>
            <div class="slider-row">
                <label>Canvas Height</label>
                <div class="slider-container">
                    <span class="draggable-number" id="canvas-height">800</span>
                    <span style="color: #888; font-size: 12px;">px</span>
                </div>
            </div>
        </div>

        <div class="control-group">
            <h3>Species Configuration</h3>
            <div class="slider-row">
                <label>Species Count</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="speciesCount" min="2" max="8" step="1" value="2">
                    <span class="value-display" id="speciesCount-value">2</span>
                </div>
            </div>
        </div>

        <div class="collapsible-section" id="forceMatrixSection">
            <div class="collapsible-header" onclick="toggleCollapsible('forceMatrixSection')">
                <h3>Force Relationships</h3>
                <span class="collapsible-toggle">▼</span>
            </div>
            <div class="collapsible-content" id="forceMatrixContent">
                <div class="collapsible-inner">
                    <div class="matrix-container">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin: 0 0 10px 0;">
                            <h4 style="margin: 0; color: #ccc; font-size: 14px;">Force Relationship Matrix</h4>
                            <button id="randomizeMatrix" class="audio-button" style="font-size: 12px; padding: 4px 8px;">🎲 Randomize</button>
                        </div>
                        <div class="matrix-grid" id="forceMatrix">
                            <!-- Matrix will be generated dynamically -->
                        </div>
                        <div class="force-legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #ff4444;"></div>
                                <span>Repulsion (-1.0)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #666;"></div>
                                <span>Neutral (0.0)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #44ff44;"></div>
                                <span>Attraction (+1.0)</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="collapsible-section" id="performanceSection">
            <div class="collapsible-header" onclick="toggleCollapsible('performanceSection')">
                <h3>Performance Metrics</h3>
                <span class="collapsible-toggle">▼</span>
            </div>
            <div class="collapsible-content" id="performanceContent">
                <div class="collapsible-inner">
                    <div style="font-size: 12px; color: #888; line-height: 1.6;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span>FPS:</span>
                            <span id="fps-display" style="color: #4CAF50; font-family: monospace;">60</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span>Frame Time:</span>
                            <span id="frame-time" style="color: #4CAF50; font-family: monospace;">16.7ms</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span>Canvas:</span>
                            <span id="canvas-size" style="color: #4CAF50; font-family: monospace;">1200×800</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span>Particles:</span>
                            <span id="total-particles" style="color: #4CAF50; font-family: monospace;">400</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span>Trail Particles:</span>
                            <span id="trail-particles" style="color: #4CAF50; font-family: monospace;">0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span>Spatial Grid:</span>
                            <span id="grid-info" style="color: #4CAF50; font-family: monospace;">Active</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span>Audio Grains:</span>
                            <span id="total-grains" style="color: #4CAF50; font-family: monospace;">0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span>Audio Latency:</span>
                            <span id="audio-latency" style="color: #4CAF50; font-family: monospace;">N/A</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>


        <div class="control-group">
            <h3>Physics Settings</h3>
            <div class="slider-row">
                <label class="checkbox-label">
                    <input type="checkbox" id="toroidalSpace" checked style="margin-right: 8px;">
                    Toroidal Space (Edge Wrapping)
                </label>
            </div>
            <div class="slider-row">
                <label>Friction</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="friction" min="0.85" max="1.0" step="0.01" value="0.95">
                    <span class="value-display" id="friction-value">0.95</span>
                </div>
            </div>
            <div class="slider-row">
                <label>Force Radius</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="forceRadius" min="20" max="200" step="10" value="60">
                    <span class="value-display" id="forceRadius-value">60</span>
                </div>
            </div>
            <div class="slider-row">
                <label>Simulation Speed</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="simSpeed" min="0.1" max="2.0" step="0.1" value="1.0">
                    <span class="value-display" id="simSpeed-value">1.0</span>
                </div>
            </div>
            <div class="slider-row">
                <label>Gravity Strength</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="gravityStrength" min="0.0" max="10.0" step="0.05" value="0.0">
                    <span class="value-display" id="gravityStrength-value">0.0</span>
                </div>
            </div>
            <div class="slider-row">
                <label>Wall Bounce Damping</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="bounceDamping" min="0.5" max="1.5" step="0.1" value="0.8">
                    <span class="value-display" id="bounceDamping-value">0.8</span>
                </div>
            </div>
            <div style="font-size: 12px; color: #888; margin-top: 8px;">
                Click and hold on simulation to create gravity pull
            </div>
        </div>

            </div>
        </div>

        <!-- Audio Engine Panel -->
        <div class="tab-panel" id="audio-panel">
            <div class="control-panel audio-panel">
                
                <div class="control-group">
                    <h3>Master Audio Controls</h3>
                    <div class="audio-master-controls">
                        <div class="slider-row">
                            <label>Master Volume</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="masterVolume" min="0" max="1.0" step="0.05" value="0.3">
                                <span class="value-display" id="masterVolume-value">0.30</span>
                                <button id="masterMute" class="audio-button">🔇</button>
                            </div>
                        </div>
                        <div class="slider-row">
                            <label>Frequency Range</label>
                            <div class="freq-range-container">
                                <div class="freq-range">
                                    <span class="freq-label">Low:</span>
                                    <input type="range" class="slider freq-slider" id="freqLow" min="20" max="500" step="10" value="80">
                                    <span class="value-display" id="freqLow-value">80Hz</span>
                                </div>
                                <div class="freq-range">
                                    <span class="freq-label">High:</span>
                                    <input type="range" class="slider freq-slider" id="freqHigh" min="1000" max="20000" step="100" value="8000">
                                    <span class="value-display" id="freqHigh-value">8000Hz</span>
                                </div>
                            </div>
                        </div>
                        <div class="slider-row">
                            <label>Velocity x Gain Curve</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="velocityGainCurve" min="0.1" max="3.0" step="0.1" value="1.0">
                                <span class="value-display" id="velocityGainCurve-value">1.0</span>
                            </div>
                        </div>
                        <div class="slider-row">
                            <label>Velocity Threshold</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="velocityThreshold" min="0.0" max="1.0" step="0.01" value="0.0">
                                <span class="value-display" id="velocityThreshold-value">0.00</span>
                            </div>
                        </div>
                        <div class="audio-status">
                            <span>Audio: </span><span id="audioStatus" style="color: #888;">Initializing...</span>
                            <button id="audioInit" class="audio-button">🎵 Start Audio</button>
                        </div>
                    </div>
                </div>
                
                <div class="collapsible-section" id="speciesAudioSection">
                    <div class="collapsible-header" onclick="toggleCollapsible('speciesAudioSection')">
                        <h3>Individual Species Audio</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content" id="speciesAudioContent">
                        <div class="collapsible-inner">
                            <div class="species-tab-container">
                                <div class="species-tabs" id="speciesTabs">
                                    <!-- Species tabs will be generated dynamically -->
                                </div>
                            </div>
                            <div class="species-audio-container" id="speciesAudioControls">
                                <!-- Species audio controls will be generated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
    </div>

    <!-- Centered Canvas -->
    <div class="main-content">
        <canvas id="canvas"></canvas>
    </div>

    <!-- ===== JAVASCRIPT MODULES ===== -->
    
    
    <!-- ===== MAIN APPLICATION ===== -->
    <script>
        // ===== AUDIO SYSTEM =====
        // Granular synthesis engine for particle-driven audio

// Audio System Variables
let audioContext = null;
let masterGainNode = null;
let compressorNode = null;
let isAudioEnabled = false;
let isMasterMuted = false;
let masterVolume = 0.3;
let frequencyRange = { low: 80, high: 8000 };

// Global velocity controls
let globalVelocityGainCurve = 1.0; // Exponential curve for velocity->gain (0.1-3.0)
let globalVelocityThreshold = 0.0; // Minimum velocity to trigger audio (0.0-1.0)
let globalVelocityThresholdSquared = 0.0; // Cached squared threshold for performance
let audioFadeDuration = 0.05; // Fade duration in seconds for threshold transitions (50ms)

// Species audio synthesizers
let speciesAudioSynths = [];

// Audio triggering modes
const TRIGGER_MODES = {
    COLLISION: 'collision',
    LOOPING: 'looping'
};

// Base Grain Engine class
class GrainEngine {
    constructor(speciesIndex, audioContext, masterGain, mode) {
        this.speciesIndex = speciesIndex;
        this.audioContext = audioContext;
        this.masterGain = masterGain;
        this.mode = mode;
        
        // Audio buffer
        this.audioBuffer = null;
        
        // Grain pool for performance
        this.grains = [];
        this.maxGrains = 50;
        
        // Audio processing parameters
        this.threshold = 0.1; // Trigger threshold (0-1)
        this.ratio = 2.0; // Compression ratio (1-10) - deprecated, replaced by smoothing
        this.smoothing = 0.0; // Smoothing factor (0-1) - creates soft threshold boundary
        this.attack = 0.01; // Attack time in seconds
        this.release = 0.1; // Release time in seconds
        this.makeupGain = 1.0; // Post-compression gain boost
        
        // State tracking
        this.activeGrains = 0;
        this.gainReduction = 0; // For visual feedback
        this.lastUpdate = 0;
    }
    
    // Abstract methods to be implemented by subclasses
    shouldTrigger(particle) {
        throw new Error('shouldTrigger must be implemented by subclass');
    }
    
    calculateGain(particle, inputLevel) {
        // Smoothed threshold calculation
        if (this.smoothing === 0.0) {
            // Hard threshold - traditional on/off behavior
            if (inputLevel <= this.threshold) {
                this.gainReduction = 0;
                return 0; // No audio below threshold
            }
            return inputLevel * this.makeupGain;
        } else {
            // Soft threshold with smoothing
            const smoothRange = this.smoothing * 0.5; // Smoothing extends 50% of smoothing value on each side
            const lowerBound = Math.max(0, this.threshold - smoothRange);
            const upperBound = Math.min(1, this.threshold + smoothRange);
            
            if (inputLevel <= lowerBound) {
                // Below smooth range - no audio
                this.gainReduction = 1.0;
                return 0;
            } else if (inputLevel >= upperBound) {
                // Above smooth range - full audio
                this.gainReduction = 0;
                return inputLevel * this.makeupGain;
            } else {
                // Within smooth range - fade in/out
                const fadePosition = (inputLevel - lowerBound) / (upperBound - lowerBound);
                const smoothedGain = this.smoothCurve(fadePosition);
                this.gainReduction = 1.0 - smoothedGain;
                return inputLevel * smoothedGain * this.makeupGain;
            }
        }
    }
    
    // Smooth curve function for threshold fading
    smoothCurve(t) {
        // Smooth step function for natural-sounding fade
        return t * t * (3 - 2 * t);
    }
    
    createGrain(particle, gainLevel) {
        if (!this.audioBuffer || this.grains.length >= this.maxGrains) return null;
        
        // Create audio nodes
        const source = this.audioContext.createBufferSource();
        const gainNode = this.audioContext.createGain();
        const filterNode = this.audioContext.createBiquadFilter();
        const pannerNode = this.audioContext.createStereoPanner();
        
        // Setup audio graph
        source.buffer = this.audioBuffer;
        source.connect(filterNode);
        filterNode.connect(gainNode);
        gainNode.connect(pannerNode);
        pannerNode.connect(this.masterGain);
        
        // Configure filter
        filterNode.type = 'bandpass';
        filterNode.Q.value = 2;
        
        const grain = {
            source,
            gainNode,
            filterNode,
            pannerNode,
            particle,
            startTime: this.audioContext.currentTime,
            isPlaying: true,
            targetGain: gainLevel
        };
        
        // Configure initial parameters
        this.updateGrainParameters(grain, particle);
        
        this.grains.push(grain);
        return grain;
    }
    
    updateGrainParameters(grain, particle) {
        // Update audio parameters based on particle state
        const now = this.audioContext.currentTime;
        
        // Calculate frequency and bandwidth from Y position and size
        const invY = 1 - (particle.y / (typeof canvasHeight !== 'undefined' ? canvasHeight : 800));
        const logLow = Math.log(frequencyRange.low);
        const logHigh = Math.log(frequencyRange.high);
        const frequency = Math.exp(logLow + (invY * (logHigh - logLow)));
        
        // Map particle size to filter bandwidth
        const minSize = 2, maxSize = 10;
        const normalizedSize = Math.max(0, Math.min(1, (particle.size - minSize) / (maxSize - minSize)));
        const bandwidth = 12.0 - (normalizedSize * 11.0); // Smaller particles = narrower bands
        
        // Set filter parameters
        grain.filterNode.frequency.setTargetAtTime(frequency, now, 0.01);
        grain.filterNode.Q.setTargetAtTime(bandwidth, now, 0.01);
        
        // Set panning based on X position
        const pan = (particle.x / (typeof canvasWidth !== 'undefined' ? canvasWidth : 1200)) * 2 - 1;
        grain.pannerNode.pan.setTargetAtTime(pan, now, 0.01);
        
        // Apply gain with attack/release
        grain.gainNode.gain.setTargetAtTime(grain.targetGain, now, 
            grain.targetGain > grain.gainNode.gain.value ? this.attack : this.release);
    }
    
    removeGrain(grain) {
        const index = this.grains.indexOf(grain);
        if (index !== -1) {
            grain.isPlaying = false;
            this.grains.splice(index, 1);
        }
    }
    
    update(particles) {
        this.activeGrains = this.grains.length;
        
        // Update existing grains
        for (let i = this.grains.length - 1; i >= 0; i--) {
            const grain = this.grains[i];
            if (grain.particle && grain.isPlaying) {
                this.updateGrainParameters(grain, grain.particle);
            }
        }
    }
}

// Collision-based grain engine
class CollisionGrainEngine extends GrainEngine {
    constructor(speciesIndex, audioContext, masterGain) {
        super(speciesIndex, audioContext, masterGain, TRIGGER_MODES.COLLISION);
        
        // Collision-specific parameters
        this.collisionSpeciesMatrix = new Array(8).fill(true); // Which species trigger audio
        this.collisionSensitivity = 1.0; // Multiplier for collision force
        this.minimumCollisionForce = 0.05; // Minimum force to trigger
    }
    
    shouldTrigger(particle) {
        if (!particle.collisionEvents || particle.collisionEvents.length === 0) {
            return false;
        }
        
        // Check recent collisions with enabled species
        const recentCollisions = particle.collisionEvents.filter(event => 
            this.collisionSpeciesMatrix[event.otherSpecies] && 
            event.force >= this.minimumCollisionForce
        );
        
        // Debug logging for collision threshold
        if (particle.collisionEvents.length > 0 && Math.random() < 0.05) { // 5% chance for debug
            const maxForce = Math.max(...particle.collisionEvents.map(e => e.force));
            console.log(`🔍 Collision check - Species ${this.speciesIndex}, MaxForce: ${maxForce.toFixed(3)}, Threshold: ${this.minimumCollisionForce.toFixed(3)}, Triggered: ${recentCollisions.length > 0}`);
        }
        
        return recentCollisions.length > 0;
    }
    
    update(particles) {
        super.update(particles);
        
        // Find particles of this species
        const speciesParticles = particles.filter(p => p.species === this.speciesIndex);
        
        for (const particle of speciesParticles) {
            if (this.shouldTrigger(particle)) {
                // Calculate gain based on collision force
                const maxForce = Math.max(...particle.collisionEvents.map(e => e.force));
                const inputLevel = Math.min(1.0, maxForce * this.collisionSensitivity);
                const gainLevel = this.calculateGain(particle, inputLevel);
                
                // Debug logging
                if (Math.random() < 0.01) { // Log 1% of collision events to avoid spam
                    console.log(`✨ Collision grain - Species ${this.speciesIndex}, Force: ${maxForce.toFixed(3)}, Gain: ${gainLevel.toFixed(3)}`);
                }
                
                // Show collision pulse visualization
                if (typeof showCollisionPulse === 'function') {
                    const triggerSpecies = particle.collisionEvents.find(e => 
                        this.collisionSpeciesMatrix[e.otherSpecies] && 
                        e.force * this.collisionSensitivity >= this.minimumCollisionForce
                    )?.otherSpecies;
                    showCollisionPulse(this.speciesIndex, maxForce, triggerSpecies);
                }
                
                // Create grain if we don't already have one for this particle
                const existingGrain = this.grains.find(g => g.particle === particle);
                if (!existingGrain && gainLevel > 0.01) {
                    const grain = this.createGrain(particle, gainLevel);
                    if (grain) {
                        // Start playback
                        grain.source.start(this.audioContext.currentTime);
                        grain.source.stop(this.audioContext.currentTime + 0.2); // 200ms grain
                        
                        // Cleanup when finished
                        grain.source.onended = () => this.removeGrain(grain);
                    }
                }
            }
        }
    }
}

// Looping grain engine with crossfading
class LoopingGrainEngine extends GrainEngine {
    constructor(speciesIndex, audioContext, masterGain) {
        super(speciesIndex, audioContext, masterGain, TRIGGER_MODES.LOOPING);
        
        // Looping-specific parameters
        this.loopDirection = 'forward'; // 'forward', 'reverse', 'alternate'
        this.crossfadeAmount = 0.5; // 0-1, amount of crossfade between grains
        this.grainDuration = 0.1; // Base grain duration
        this.grainSpacing = 0.05; // Time between grain starts
        this.alternateState = 1; // For alternating direction
        this.velocityThreshold = 0.05; // Configurable velocity threshold
        
        // Per-particle grain scheduling
        this.particleGrains = new Map(); // particle -> grain info
    }
    
    shouldTrigger(particle) {
        // Trigger in looping mode if particle velocity is above threshold
        const velocity = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        const normalizedVelocity = Math.min(1.0, velocity / 3.0); // Normalize to 0-1 range based on max velocity
        
        // Intuitive logic: lower threshold = more sound (trigger at lower velocities)
        // If threshold is 0.1, trigger when normalized velocity > 0.1
        return normalizedVelocity > this.velocityThreshold;
    }
    
    update(particles) {
        super.update(particles);
        
        const currentTime = this.audioContext.currentTime;
        const speciesParticles = particles.filter(p => p.species === this.speciesIndex);
        
        for (const particle of speciesParticles) {
            if (this.shouldTrigger(particle)) {
                const velocity = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                const inputLevel = Math.min(1.0, velocity / 3.0); // Normalize to max velocity
                const gainLevel = this.calculateGain(particle, inputLevel);
                
                if (gainLevel > 0.01) {
                    // Check if we need to schedule a new grain for this particle
                    const grainInfo = this.particleGrains.get(particle);
                    const shouldScheduleNew = !grainInfo || 
                        (currentTime - grainInfo.lastGrainTime) >= this.grainSpacing;
                    
                    if (shouldScheduleNew) {
                        const grain = this.createLoopingGrain(particle, gainLevel);
                        if (grain) {
                            this.particleGrains.set(particle, {
                                lastGrainTime: currentTime,
                                currentGrain: grain
                            });
                        }
                    }
                }
            } else {
                // Remove particle from tracking if no longer active
                this.particleGrains.delete(particle);
            }
        }
    }
    
    createLoopingGrain(particle, gainLevel) {
        if (!this.audioBuffer || this.grains.length >= this.maxGrains) return null;
        
        const grain = this.createGrain(particle, gainLevel);
        if (!grain) return null;
        
        // Calculate sample position based on particle X
        const samplePosition = particle.x / (typeof canvasWidth !== 'undefined' ? canvasWidth : 1200);
        const startTime = samplePosition * this.audioBuffer.duration;
        
        // Determine playback direction and rate
        let playbackRate = 1.0;
        let actualStartTime = startTime;
        
        if (this.loopDirection === 'reverse') {
            playbackRate = -1.0;
        } else if (this.loopDirection === 'alternate') {
            playbackRate = this.alternateState;
            this.alternateState *= -1; // Toggle for next grain
        }
        
        // Apply crossfading envelope
        const fadeTime = this.grainDuration * this.crossfadeAmount * 0.5;
        const now = this.audioContext.currentTime;
        
        grain.gainNode.gain.setValueAtTime(0, now);
        grain.gainNode.gain.linearRampToValueAtTime(gainLevel, now + fadeTime);
        grain.gainNode.gain.setValueAtTime(gainLevel, now + this.grainDuration - fadeTime);
        grain.gainNode.gain.linearRampToValueAtTime(0, now + this.grainDuration);
        
        // Start playback
        grain.source.playbackRate.value = Math.abs(playbackRate);
        grain.source.start(now, actualStartTime, this.grainDuration);
        grain.source.stop(now + this.grainDuration);
        
        // Cleanup when finished
        grain.source.onended = () => this.removeGrain(grain);
        
        return grain;
    }
}

// Enhanced Granular Synthesizer Class with dual engine support
class GranularSynth {
    constructor(speciesIndex, audioContext, masterGain) {
        this.speciesIndex = speciesIndex;
        this.audioContext = audioContext;
        this.masterGain = masterGain;
        
        // Audio graph (only create if audioContext exists)
        if (audioContext && masterGain) {
            this.gainNode = audioContext.createGain();
            this.gainNode.connect(masterGain);
            this.gainNode.gain.value = 0.7;
        } else {
            this.gainNode = null;
        }
        
        // Sample buffer and selection
        this.audioBuffer = null;
        this.fileName = '';
        this.sampleStart = 0.0; // Start position in sample (0-1)
        this.sampleEnd = 1.0;   // End position in sample (0-1)
        
        // Trigger mode and engines
        this.triggerMode = TRIGGER_MODES.LOOPING; // Default to looping mode
        this.collisionEngine = null;
        this.loopingEngine = null;
        this.currentEngine = null;
        
        // Legacy parameters (maintained for compatibility)
        this.loopMode = 'forward';
        this.pitch = 0; // Semitones (0-24)
        this.detune = 0; // Cents (0-50, randomized per grain)
        this.fadeLength = 0.002; // Crossfade length (1ms-20ms)
        
        // State
        this.isMuted = false;
        this.volume = 0.7;
        this.activeGrains = 0;
        
        // Initialize engines
        this.initializeEngines();
        
        console.log(`🎵 Enhanced granular synth created for Species ${String.fromCharCode(65 + speciesIndex)}`);
    }
    
    initializeEngines() {
        if (!this.audioContext || !this.gainNode) return;
        
        this.collisionEngine = new CollisionGrainEngine(this.speciesIndex, this.audioContext, this.gainNode);
        this.loopingEngine = new LoopingGrainEngine(this.speciesIndex, this.audioContext, this.gainNode);
        
        // Set current engine based on mode
        this.currentEngine = this.triggerMode === TRIGGER_MODES.COLLISION ? 
            this.collisionEngine : this.loopingEngine;
    }
    
    // Connect audio graph when context becomes available
    connectAudioGraph(audioContext, masterGain) {
        this.audioContext = audioContext;
        this.masterGain = masterGain;
        
        if (!this.gainNode && audioContext && masterGain) {
            this.gainNode = audioContext.createGain();
            this.gainNode.connect(masterGain);
            this.gainNode.gain.value = this.volume || 0.7;
        }
        
        // Initialize engines with new context
        this.initializeEngines();
    }
    
    // Load audio sample
    async loadSample(arrayBuffer) {
        try {
            // If no audio context yet, create a temporary one for display purposes
            if (!this.audioContext || this.audioContext.state === 'closed') {
                this.rawAudioData = arrayBuffer;
                this.fileName = 'Sample loaded (awaiting audio start)';
                
                // Create temporary audioContext just for decoding and display
                try {
                    const tempContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.audioBuffer = await tempContext.decodeAudioData(arrayBuffer.slice(0)); // Use copy of buffer
                    await tempContext.close(); // Clean up temporary context
                    console.log(`🎵 Sample decoded for display for Species ${String.fromCharCode(65 + this.speciesIndex)}: ${this.audioBuffer.duration.toFixed(2)}s`);
                } catch (tempError) {
                    console.warn('Could not decode for display:', tempError);
                }
                
                return true;
            }
            
            // Make sure audioContext is in good state before decoding
            if (this.audioContext.state === 'suspended') {
                console.warn('AudioContext suspended, storing sample for later decode');
                this.rawAudioData = arrayBuffer;
                this.fileName = 'Sample loaded (awaiting audio start)';
                return true;
            }
            
            // Decode immediately if audio context exists and is running
            this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            
            // Share audio buffer with engines
            if (this.collisionEngine) this.collisionEngine.audioBuffer = this.audioBuffer;
            if (this.loopingEngine) this.loopingEngine.audioBuffer = this.audioBuffer;
            
            console.log(`🎵 Sample loaded for Species ${String.fromCharCode(65 + this.speciesIndex)}: ${this.audioBuffer.duration.toFixed(2)}s`);
            return true;
        } catch (error) {
            console.error('Audio decode error:', error);
            return false;
        }
    }
    
    // Decode stored audio data when audio context becomes available
    async decodeStoredAudio() {
        if (this.rawAudioData && this.audioContext) {
            try {
                // If we already have an audioBuffer from temp decode, re-decode with proper audioContext
                // This ensures the audioBuffer is compatible with the main audio system
                this.audioBuffer = await this.audioContext.decodeAudioData(this.rawAudioData);
                this.rawAudioData = null; // Clear raw data after decoding
                
                // Share audio buffer with engines
                if (this.collisionEngine) this.collisionEngine.audioBuffer = this.audioBuffer;
                if (this.loopingEngine) this.loopingEngine.audioBuffer = this.audioBuffer;
                
                console.log(`🎵 Re-decoded sample for audio system for Species ${String.fromCharCode(65 + this.speciesIndex)}: ${this.audioBuffer.duration.toFixed(2)}s`);
                return true;
            } catch (error) {
                console.error('Stored audio decode error:', error);
                return false;
            }
        }
        return false;
    }
    
    // Set trigger mode (collision or looping)
    setTriggerMode(mode) {
        this.triggerMode = mode;
        
        // Ensure engines exist
        if (!this.collisionEngine || !this.loopingEngine) {
            this.initializeEngines();
        }
        
        this.currentEngine = mode === TRIGGER_MODES.COLLISION ? 
            this.collisionEngine : this.loopingEngine;
        
        // Share audio buffer and settings with new engine
        if (this.currentEngine && this.audioBuffer) {
            this.currentEngine.audioBuffer = this.audioBuffer;
        }
        
        console.log(`🎵 Species ${String.fromCharCode(65 + this.speciesIndex)} trigger mode: ${mode}`);
    }
    
    // Get current engine settings for UI
    getEngineSettings() {
        if (!this.currentEngine) return {};
        
        return {
            threshold: this.currentEngine.threshold,
            ratio: this.currentEngine.ratio,
            attack: this.currentEngine.attack,
            release: this.currentEngine.release,
            makeupGain: this.currentEngine.makeupGain,
            gainReduction: this.currentEngine.gainReduction,
            // Mode-specific settings
            ...(this.triggerMode === TRIGGER_MODES.COLLISION ? {
                collisionSpeciesMatrix: this.collisionEngine.collisionSpeciesMatrix,
                collisionSensitivity: this.collisionEngine.collisionSensitivity,
                minimumCollisionForce: this.collisionEngine.minimumCollisionForce
            } : {
                loopDirection: this.loopingEngine.loopDirection,
                crossfadeAmount: this.loopingEngine.crossfadeAmount,
                grainDuration: this.loopingEngine.grainDuration,
                grainSpacing: this.loopingEngine.grainSpacing
            })
        };
    }
    
    // Update engine settings from UI
    updateEngineSettings(settings) {
        if (!this.currentEngine) return;
        
        // Update common settings
        if (settings.threshold !== undefined) this.currentEngine.threshold = settings.threshold;
        if (settings.ratio !== undefined) this.currentEngine.ratio = settings.ratio; // Keep for backwards compatibility
        if (settings.smoothing !== undefined) this.currentEngine.smoothing = settings.smoothing;
        if (settings.attack !== undefined) this.currentEngine.attack = settings.attack;
        if (settings.release !== undefined) this.currentEngine.release = settings.release;
        if (settings.makeupGain !== undefined) this.currentEngine.makeupGain = settings.makeupGain;
        
        // Update mode-specific settings
        if (this.triggerMode === TRIGGER_MODES.COLLISION && this.collisionEngine) {
            // Map threshold to collision-specific parameters
            if (settings.threshold !== undefined) {
                this.collisionEngine.minimumCollisionForce = settings.threshold;
                console.log(`🎯 Collision threshold updated to: ${settings.threshold}`);
            }
            if (settings.collisionSpeciesMatrix) this.collisionEngine.collisionSpeciesMatrix = settings.collisionSpeciesMatrix;
            if (settings.collisionSensitivity !== undefined) this.collisionEngine.collisionSensitivity = settings.collisionSensitivity;
            if (settings.minimumCollisionForce !== undefined) this.collisionEngine.minimumCollisionForce = settings.minimumCollisionForce;
        } else if (this.triggerMode === TRIGGER_MODES.LOOPING && this.loopingEngine) {
            // Map threshold to looping-specific parameters  
            if (settings.threshold !== undefined) {
                this.loopingEngine.velocityThreshold = settings.threshold;
                console.log(`🎯 Looping velocity threshold updated to: ${settings.threshold}`);
            }
            if (settings.loopDirection) this.loopingEngine.loopDirection = settings.loopDirection;
            if (settings.crossfadeAmount !== undefined) this.loopingEngine.crossfadeAmount = settings.crossfadeAmount;
            if (settings.grainDuration !== undefined) this.loopingEngine.grainDuration = settings.grainDuration;
            if (settings.grainSpacing !== undefined) this.loopingEngine.grainSpacing = settings.grainSpacing;
        }
    }
    
    // Create and manage audio grain with crossfading (legacy method - now uses engines)
    createGrain(particle) {
        // Delegate to current engine
        return this.currentEngine ? this.currentEngine.createGrain(particle, 0.5) : null;
    }
    
    // Legacy create grain method (for backwards compatibility)
    createGrainLegacy(particle) {
        if (!this.audioBuffer || this.isMuted || !isAudioEnabled) return null;
        if (this.grains.length >= this.maxGrains) return null;
        
        // FAST velocity threshold check and fade state update
        const velocitySquared = particle.vx * particle.vx + particle.vy * particle.vy;
        const isAboveThreshold = velocitySquared >= globalVelocityThresholdSquared;
        
        // Update fade state efficiently (60fps = ~16.67ms per frame)
        const fadeStep = (1.0 / 60.0) / audioFadeDuration; // Fade step per frame at 60fps
        
        if (isAboveThreshold && !particle.wasAboveThreshold) {
            // Started crossing threshold - begin fade in
            particle.wasAboveThreshold = true;
        } else if (!isAboveThreshold && particle.wasAboveThreshold) {
            // Started crossing threshold - begin fade out  
            particle.wasAboveThreshold = false;
        }
        
        // Update fade state smoothly
        if (particle.wasAboveThreshold) {
            particle.audioFadeState = Math.min(1.0, particle.audioFadeState + fadeStep);
        } else {
            particle.audioFadeState = Math.max(0.0, particle.audioFadeState - fadeStep);
        }
        
        // Exit early if no volume (avoids creating audio nodes for silent particles)
        if (particle.audioFadeState <= 0.001) {
            return null;
        }
        
        // Only now create audio nodes (expensive operations) for audible particles
        const source = this.audioContext.createBufferSource();
        const gainNode = this.audioContext.createGain();
        const filterNode = this.audioContext.createBiquadFilter();
        const pannerNode = this.audioContext.createStereoPanner();
        
        // Setup audio graph: source -> filter -> gain -> panner -> species gain
        source.buffer = this.audioBuffer;
        source.connect(filterNode);
        filterNode.connect(gainNode);
        gainNode.connect(pannerNode);
        pannerNode.connect(this.gainNode);
        
        // Configure filter for Y-axis frequency control
        filterNode.type = 'bandpass';
        filterNode.Q.value = 2;
        
        // Calculate parameters from particle (expensive operations only for audible particles)
        const sampleRange = this.sampleEnd - this.sampleStart;
        const samplePosition = this.sampleStart + (Math.max(0, Math.min(1, particle.x / canvasWidth)) * sampleRange);
        const { frequency, bandwidth } = this.calculateFrequencyAndBandwidth(particle.y / canvasHeight, particle.size);
        
        // Calculate velocity and apply gain curve + fade
        const velocity = Math.sqrt(velocitySquared);
        const MAX_SPEED = 3;
        const normalizedVelocity = Math.min(1, velocity / MAX_SPEED);
        const curvedVelocity = Math.pow(normalizedVelocity, globalVelocityGainCurve);
        const volume = curvedVelocity * this.volume * particle.audioFadeState; // Apply fade multiplier
        
        const grainDuration = this.mapTrailLengthToGrainDuration(particle);
        const pan = (particle.x / canvasWidth) * 2 - 1; // -1 (left) to +1 (right)
        
        // Calculate pitch adjustment (semitones + random detune)
        const semitoneRatio = Math.pow(2, this.pitch / 12); // Convert semitones to frequency ratio
        const randomDetuneCents = (Math.random() - 0.5) * 2 * this.detune; // Random detune in cents
        const detuneRatio = Math.pow(2, randomDetuneCents / 1200); // Convert cents to frequency ratio
        const totalPitchRatio = semitoneRatio * detuneRatio;
        
        // Enhanced crossfading parameters using fadeLength setting
        const crossfadeTime = this.fadeLength; // Use species-specific fade length
        const fadeInTime = Math.min(crossfadeTime, grainDuration * 0.1); // Max 10% of grain duration
        const fadeOutTime = Math.min(crossfadeTime, grainDuration * 0.1);
        
        // Calculate sample start/end positions based on loop mode with crossfading
        let startTime, endTime, playbackRate = 1;
        
        if (this.loopMode === 'forward') {
            startTime = samplePosition * this.audioBuffer.duration;
            endTime = Math.min(startTime + grainDuration, this.audioBuffer.duration);
        } else if (this.loopMode === 'reverse') {
            // Play backwards by setting negative playback rate
            startTime = samplePosition * this.audioBuffer.duration;
            endTime = Math.max(startTime - grainDuration, 0);
            playbackRate = -1;
            // For reverse playback, we need to start from the end position
            const temp = startTime;
            startTime = endTime;
            endTime = temp;
        } else if (this.loopMode === 'alternate') {
            // Alternate between forward and reverse for each grain with crossfade
            if (this.alternateDirection === 1) {
                // Forward
                startTime = samplePosition * this.audioBuffer.duration;
                endTime = Math.min(startTime + grainDuration, this.audioBuffer.duration);
                playbackRate = 1;
            } else {
                // Reverse
                startTime = samplePosition * this.audioBuffer.duration;
                endTime = Math.max(startTime - grainDuration, 0);
                playbackRate = -1;
                const temp = startTime;
                startTime = endTime;
                endTime = temp;
            }
            // Toggle direction for next grain
            this.alternateDirection *= -1;
        }
        
        // Set playback rate for direction and pitch
        source.playbackRate.value = Math.abs(playbackRate) * totalPitchRatio;
        
        // Enhanced gain envelope with smooth crossfading
        const now = this.audioContext.currentTime;
        const sustainTime = grainDuration - fadeInTime - fadeOutTime;
        
        // Start with zero gain
        gainNode.gain.setValueAtTime(0, now);
        
        // Fade in (prevents clicks)
        gainNode.gain.linearRampToValueAtTime(volume, now + fadeInTime);
        
        // Sustain level
        if (sustainTime > 0) {
            gainNode.gain.setValueAtTime(volume, now + fadeInTime + sustainTime);
        }
        
        // Fade out (prevents clicks)
        gainNode.gain.linearRampToValueAtTime(0, now + grainDuration);
        
        // Set frequency and bandwidth (Y-axis mapping + particle size)
        filterNode.frequency.setValueAtTime(frequency, now);
        filterNode.Q.setValueAtTime(bandwidth, now);
        
        // Set panning (X-axis mapping)
        pannerNode.pan.setValueAtTime(pan, now);
        
        // Create grain object
        const grain = {
            source,
            gainNode,
            filterNode,
            pannerNode,
            startTime: now,
            duration: grainDuration,
            particle: particle,
            isPlaying: true,
            playbackRate: playbackRate,
            fadeInTime: fadeInTime,
            fadeOutTime: fadeOutTime
        };
        
        // Start playback with proper timing
        const actualDuration = Math.abs(endTime - startTime);
        if (actualDuration > 0) {
            source.start(now, startTime, actualDuration);
            source.stop(now + grainDuration);
        } else {
            // Handle edge case where duration is zero
            return null;
        }
        
        // Cleanup when finished
        source.onended = () => {
            this.removeGrain(grain);
        };
        
        this.grains.push(grain);
        return grain;
    }
    
    // Remove grain from pool
    removeGrain(grain) {
        const index = this.grains.indexOf(grain);
        if (index !== -1) {
            this.grains.splice(index, 1);
            grain.isPlaying = false;
        }
    }
    
    // Update grain parameters based on particle movement
    updateGrain(grain, particle) {
        if (!grain.isPlaying) return;
        
        const now = this.audioContext.currentTime;
        const { frequency, bandwidth } = this.calculateFrequencyAndBandwidth(particle.y / canvas.height, particle.size);
        const velocity = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        const volume = Math.min(1, velocity / MAX_SPEED) * this.volume;
        const pan = (particle.x / canvas.width) * 2 - 1; // -1 (left) to +1 (right)
        
        // Update frequency and bandwidth smoothly
        grain.filterNode.frequency.setTargetAtTime(frequency, now, 0.01);
        grain.filterNode.Q.setTargetAtTime(bandwidth, now, 0.01);
        
        // Update volume based on velocity
        grain.gainNode.gain.setTargetAtTime(volume, now, 0.01);
        
        // Update panning based on X position
        grain.pannerNode.pan.setTargetAtTime(pan, now, 0.01);
    }
    
    // Calculate frequency and bandwidth from Y position and particle size (narrower bands for smaller particles)
    calculateFrequencyAndBandwidth(normalizedY, particleSize) {
        // Invert Y (top = high frequency, bottom = low frequency)
        const invY = 1 - normalizedY;
        
        // Logarithmic scaling for musical frequency perception
        const logLow = Math.log(frequencyRange.low);
        const logHigh = Math.log(frequencyRange.high);
        const logFreq = logLow + (invY * (logHigh - logLow));
        const frequency = Math.exp(logFreq);
        
        // Map particle size to filter bandwidth - REVERSED: smaller particles = narrower bands
        const minSize = 2; // Minimum particle size
        const maxSize = 10; // Maximum particle size
        const normalizedSize = Math.max(0, Math.min(1, (particleSize - minSize) / (maxSize - minSize)));
        
        // Smaller particles = higher Q (narrower band), larger particles = lower Q (wider band)
        // Adjusted for narrower base frequency at size 2.0
        const minQ = 1.0; // Wide bandwidth for large particles
        const maxQ = 12.0; // Very narrow bandwidth for small particles (size 2.0)
        const bandwidth = maxQ - (normalizedSize * (maxQ - minQ));
        
        return { frequency, bandwidth };
    }
    
    // Map trail length to grain duration - direct mapping to 2ms-200ms range
    mapTrailLengthToGrainDuration(particle) {
        const speciesTrailLength = (typeof speciesTrailLengths !== 'undefined' ? speciesTrailLengths[particle.species] : null) || 0.5;
        
        const minDuration = 0.002; // 2ms
        const maxDuration = 0.2;   // 200ms
        
        // Direct linear mapping of species trail length (0-1) to grain duration (2ms-200ms)
        return minDuration + (speciesTrailLength * (maxDuration - minDuration));
    }
    
    // Update all grains for this species (now uses engine system)
    update(particles) {
        if (!this.currentEngine || this.isMuted || !isAudioEnabled) {
            this.activeGrains = 0;
            return;
        }
        
        // Update current engine
        this.currentEngine.update(particles);
        this.activeGrains = this.currentEngine.activeGrains;
    }
    
    // Set volume
    setVolume(volume) {
        this.volume = Math.max(0, Math.min(1, volume));
        this.gainNode.gain.setTargetAtTime(this.isMuted ? 0 : this.volume, this.audioContext.currentTime, 0.01);
    }
    
    // Mute/unmute
    setMute(muted) {
        this.isMuted = muted;
        this.gainNode.gain.setTargetAtTime(muted ? 0 : this.volume, this.audioContext.currentTime, 0.01);
    }
    
    // Set loop mode
    setLoopMode(mode) {
        this.loopMode = mode;
        this.alternateDirection = 1; // Reset alternate direction
        console.log(`🎵 Species ${String.fromCharCode(65 + this.speciesIndex)} loop mode: ${mode}`);
    }
    
    // Stop all grains
    stopAll() {
        if (this.collisionEngine) {
            for (let grain of this.collisionEngine.grains) {
                if (grain.source && grain.isPlaying) {
                    grain.source.stop();
                }
            }
            this.collisionEngine.grains = [];
        }
        
        if (this.loopingEngine) {
            for (let grain of this.loopingEngine.grains) {
                if (grain.source && grain.isPlaying) {
                    grain.source.stop();
                }
            }
            this.loopingEngine.grains = [];
            this.loopingEngine.particleGrains.clear();
        }
    }
    
    // Legacy compatibility - expose grains property
    get grains() {
        return this.currentEngine ? this.currentEngine.grains : [];
    }
    
    // Legacy compatibility - expose maxGrains property
    get maxGrains() {
        return this.currentEngine ? this.currentEngine.maxGrains : 50;
    }
}

// Initialize Audio System
async function initAudioSystem() {
    // Prevent multiple initializations
    if (isAudioEnabled && audioContext && audioContext.state === 'running') {
        console.log('🎵 Audio system already initialized');
        return true;
    }
    
    try {
        // Only create new context if one doesn't exist or is closed
        if (!audioContext || audioContext.state === 'closed') {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } else if (audioContext.state === 'suspended') {
            await audioContext.resume();
        }
        
        // Create master audio graph only if needed
        if (!masterGainNode || !compressorNode) {
            masterGainNode = audioContext.createGain();
            compressorNode = audioContext.createDynamicsCompressor();
            
            // Setup audio chain: species synths -> master gain -> compressor -> destination
            masterGainNode.connect(compressorNode);
            compressorNode.connect(audioContext.destination);
        }
        
        // Configure compressor for safety
        compressorNode.threshold.value = -20;
        compressorNode.knee.value = 10;
        compressorNode.ratio.value = 8;
        compressorNode.attack.value = 0.001;
        compressorNode.release.value = 0.1;
        
        // Set master volume
        masterGainNode.gain.value = masterVolume;
        
        // Connect existing synths to audio context and decode any stored audio
        for (let i = 0; i < speciesAudioSynths.length; i++) {
            if (speciesAudioSynths[i]) {
                speciesAudioSynths[i].connectAudioGraph(audioContext, masterGainNode);
                // Decode any stored audio data
                await speciesAudioSynths[i].decodeStoredAudio();
            }
        }
        
        // Update waveforms for any newly decoded audio
        for (let i = 0; i < speciesAudioSynths.length; i++) {
            const synth = speciesAudioSynths[i];
            if (synth && synth.audioBuffer) {
                const waveformCanvas = document.getElementById(`waveform${i}`);
                if (waveformCanvas) {
                    const currentSpeciesColors = (typeof speciesColors !== 'undefined') ? speciesColors : [[1,0,0],[0,0,1]];
                    drawWaveform(synth.audioBuffer, waveformCanvas, currentSpeciesColors[i] || [1,1,1], i);
                }
                
                // Update file name
                const fileNameElement = document.getElementById(`fileName${i}`);
                if (fileNameElement && synth.fileName) {
                    fileNameElement.textContent = synth.fileName;
                }
            }
        }
        
        isAudioEnabled = true;
        updateAudioStatus('Ready');
        
        console.log('🎵 Audio system initialized successfully');
        return true;
        
    } catch (error) {
        console.error('Audio initialization failed:', error);
        updateAudioStatus('Failed');
        return false;
    }
}

// Initialize audio UI only (no audio context required)
function initAudioUI() {
    speciesAudioSynths = [];
    
    // Create UI-only synths (no audioContext)
    for (let i = 0; i < maxSpecies; i++) {
        const synth = new GranularSynth(i, null, null);
        speciesAudioSynths.push(synth);
    }
    
    // Generate species audio UI
    createSpeciesAudioControls();
    
    // Setup draggable numbers for species parameters
    if (typeof setupDraggableNumbers === 'function') {
        setTimeout(() => setupDraggableNumbers(), 0);
    }
    
    console.log('🎵 Audio UI initialized (controls ready, audio awaiting start)');
}

// Initialize species synthesizers (preserves existing audio buffers)
function initSpeciesSynths() {
    const existingData = [];
    
    // Preserve existing audio data
    for (let i = 0; i < speciesAudioSynths.length; i++) {
        if (speciesAudioSynths[i]) {
            existingData[i] = {
                audioBuffer: speciesAudioSynths[i].audioBuffer,
                fileName: speciesAudioSynths[i].fileName,
                volume: speciesAudioSynths[i].volume,
                isMuted: speciesAudioSynths[i].isMuted,
                loopMode: speciesAudioSynths[i].loopMode,
                sampleStart: speciesAudioSynths[i].sampleStart || 0.0,
                sampleEnd: speciesAudioSynths[i].sampleEnd || 1.0,
                pitch: speciesAudioSynths[i].pitch || 0,
                detune: speciesAudioSynths[i].detune || 0,
                fadeLength: speciesAudioSynths[i].fadeLength || 0.002
            };
        }
    }
    
    speciesAudioSynths = [];
    
    for (let i = 0; i < maxSpecies; i++) {
        const synth = new GranularSynth(i, audioContext, masterGainNode);
        
        // Restore existing data if available
        if (existingData[i]) {
            synth.audioBuffer = existingData[i].audioBuffer;
            synth.fileName = existingData[i].fileName || 'No Sample';
            synth.volume = existingData[i].volume;
            synth.isMuted = existingData[i].isMuted;
            synth.loopMode = existingData[i].loopMode;
            synth.sampleStart = existingData[i].sampleStart || 0.0;
            synth.sampleEnd = existingData[i].sampleEnd || 1.0;
            synth.pitch = existingData[i].pitch || 0;
            synth.detune = existingData[i].detune || 0;
            synth.fadeLength = existingData[i].fadeLength || 0.002;
            synth.alternateDirection = 1; // Reset alternate direction
        }
        
        speciesAudioSynths.push(synth);
    }
    
    // Generate species audio UI
    createSpeciesAudioControls();
    
    // Setup draggable numbers for species parameters (call from main script)
    if (typeof setupDraggableNumbers === 'function') {
        setTimeout(() => setupDraggableNumbers(), 0);
    }
}

// Update audio system with particle data
function updateAudioSystem() {
    if (!isAudioEnabled || !audioContext || audioContext.state !== 'running') return;
    
    // Update each species synth with its particles
    for (let i = 0; i < speciesCount; i++) {
        if (speciesAudioSynths[i]) {
            speciesAudioSynths[i].update(particles);
        }
    }
    
    // Update UI indicators
    updateAudioUI();
}

// Update audio status display
function updateAudioStatus(status) {
    const statusElement = document.getElementById('audioStatus');
    if (statusElement) {
        statusElement.textContent = status;
        statusElement.style.color = status === 'Ready' ? '#4CAF50' : 
                                  status === 'Failed' ? '#ff4444' : '#888';
    }
}

// Audio control functions - defined globally for event handlers
function toggleSpeciesMute(speciesIndex) {
    if (!speciesAudioSynths[speciesIndex]) return;
    
    const synth = speciesAudioSynths[speciesIndex];
    synth.setMute(!synth.isMuted);
    
    const button = document.getElementById(`speciesMute${speciesIndex}`);
    if (button) {
        button.textContent = synth.isMuted ? '🔇' : '🔊';
        button.classList.toggle('active', !synth.isMuted);
    }
}

function setSpeciesVolume(speciesIndex, volume) {
    if (!speciesAudioSynths[speciesIndex]) return;
    
    speciesAudioSynths[speciesIndex].setVolume(volume);
    
    const valueDisplay = document.getElementById(`speciesVolume${speciesIndex}-value`);
    if (valueDisplay) {
        valueDisplay.textContent = volume.toFixed(2);
    }
}

function setMasterVolume(volume) {
    masterVolume = volume;
    if (masterGainNode) {
        masterGainNode.gain.setTargetAtTime(isMasterMuted ? 0 : volume, audioContext.currentTime, 0.01);
    }
    
    const valueDisplay = document.getElementById('masterVolume-value');
    if (valueDisplay) {
        valueDisplay.textContent = volume.toFixed(2);
    }
}

function toggleMasterMute() {
    isMasterMuted = !isMasterMuted;
    if (masterGainNode) {
        masterGainNode.gain.setTargetAtTime(isMasterMuted ? 0 : masterVolume, audioContext.currentTime, 0.01);
    }
    
    const button = document.getElementById('masterMute');
    if (button) {
        button.textContent = isMasterMuted ? '🔇' : '🔊';
        button.classList.toggle('active', !isMasterMuted);
    }
}

function setFrequencyRange(low, high) {
    frequencyRange.low = low;
    frequencyRange.high = high;
    
    const lowDisplay = document.getElementById('freqLow-value');
    const highDisplay = document.getElementById('freqHigh-value');
    if (lowDisplay) lowDisplay.textContent = `${low}Hz`;
    if (highDisplay) highDisplay.textContent = `${high}Hz`;
}

function setGlobalVelocityGainCurve(curve) {
    globalVelocityGainCurve = curve;
    
    const valueDisplay = document.getElementById('velocityGainCurve-value');
    if (valueDisplay) {
        valueDisplay.textContent = curve.toFixed(1);
    }
}

function setGlobalVelocityThreshold(threshold) {
    globalVelocityThreshold = threshold;
    
    // Pre-calculate squared threshold for performance (MAX_SPEED = 3)
    const MAX_SPEED = 3;
    globalVelocityThresholdSquared = (threshold * MAX_SPEED) * (threshold * MAX_SPEED);
    
    const valueDisplay = document.getElementById('velocityThreshold-value');
    if (valueDisplay) {
        valueDisplay.textContent = threshold.toFixed(2);
    }
}

// New audio control functions
function setSpeciesPitch(speciesIndex, pitch) {
    if (!speciesAudioSynths[speciesIndex]) return;
    
    speciesAudioSynths[speciesIndex].pitch = pitch;
    
    const valueDisplay = document.getElementById(`speciesPitch${speciesIndex}-value`);
    if (valueDisplay) {
        valueDisplay.textContent = pitch >= 0 ? `+${pitch}st` : `${pitch}st`;
    }
}

function setSpeciesDetune(speciesIndex, detune) {
    if (!speciesAudioSynths[speciesIndex]) return;
    
    speciesAudioSynths[speciesIndex].detune = detune;
    
    const valueDisplay = document.getElementById(`speciesDetune${speciesIndex}-value`);
    if (valueDisplay) {
        valueDisplay.textContent = `${detune}¢`;
    }
}


function setSpeciesFadeLength(speciesIndex, fadeLength) {
    if (!speciesAudioSynths[speciesIndex]) return;
    
    speciesAudioSynths[speciesIndex].fadeLength = fadeLength;
    
    const valueDisplay = document.getElementById(`speciesFade${speciesIndex}-value`);
    if (valueDisplay) {
        valueDisplay.textContent = `${Math.round(fadeLength * 1000)}ms`;
    }
}

// Set species loop mode - defined globally for loop button handlers
function setSpeciesLoopMode(speciesIndex, mode) {
    if (!speciesAudioSynths[speciesIndex]) return;
    
    // Update the synth's loop mode
    speciesAudioSynths[speciesIndex].setLoopMode(mode);
    
    // Update UI to show selected mode
    const buttons = document.querySelectorAll(`[data-species="${speciesIndex}"][data-loop-mode]`);
    buttons.forEach(button => {
        button.classList.remove('active');
        if (button.dataset.loopMode === mode) {
            button.classList.add('active');
        }
    });
    
    console.log(`🎵 Species ${String.fromCharCode(65 + speciesIndex)} loop mode set to: ${mode}`);
}

// Load audio file for species - defined globally for file input handlers
async function loadAudioFile(event, speciesIndex) {
    const file = event.target.files[0];
    if (!file || !speciesAudioSynths[speciesIndex]) return;
    
    try {
        const arrayBuffer = await file.arrayBuffer();
        const success = await speciesAudioSynths[speciesIndex].loadSample(arrayBuffer);
        
        if (success) {
            // Update UI with actual file name
            const fileNameElement = document.getElementById(`fileName${speciesIndex}`);
            if (fileNameElement) {
                fileNameElement.textContent = file.name;
            }
            
            // Store the actual file name in the synth for proper display
            speciesAudioSynths[speciesIndex].fileName = file.name;
            
            // Update waveform if audioBuffer is available (should be available now even before Start Audio)
            const waveformCanvas = document.getElementById(`waveform${speciesIndex}`);
            if (waveformCanvas && speciesAudioSynths[speciesIndex].audioBuffer) {
                const currentSpeciesColors = (typeof speciesColors !== 'undefined') ? speciesColors : [[1,0,0],[0,0,1]];
                drawWaveform(speciesAudioSynths[speciesIndex].audioBuffer, waveformCanvas, currentSpeciesColors[speciesIndex] || [1,1,1], speciesIndex);
            }
            
            console.log(`🎵 Loaded audio file for Species ${String.fromCharCode(65 + speciesIndex)}: ${file.name}`);
        } else {
            alert('Failed to load audio file. Please try a different file.');
        }
    } catch (error) {
        console.error('File loading error:', error);
        alert('Error loading audio file.');
    }
}

// Waveform selection state
let waveformSelection = {
    isSelecting: false,
    speciesIndex: -1,
    startX: 0,
    currentX: 0,
    canvas: null
};

// Draw waveform visualization with selection overlay
function drawWaveform(audioBuffer, canvas, color, speciesIndex) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    ctx.clearRect(0, 0, width, height);
    
    if (!audioBuffer) return;
    
    const data = audioBuffer.getChannelData(0);
    const step = Math.ceil(data.length / width);
    const amp = height / 2;
    
    // Draw waveform
    ctx.strokeStyle = `rgb(${Math.round(color[0] * 255)}, ${Math.round(color[1] * 255)}, ${Math.round(color[2] * 255)})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    for (let i = 0; i < width; i++) {
        let min = 1.0;
        let max = -1.0;
        
        for (let j = 0; j < step; j++) {
            const datum = data[(i * step) + j];
            if (datum < min) min = datum;
            if (datum > max) max = datum;
        }
        
        ctx.moveTo(i, (1 + min) * amp);
        ctx.lineTo(i, (1 + max) * amp);
    }
    
    ctx.stroke();
    
    // Draw center line
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, amp);
    ctx.lineTo(width, amp);
    ctx.stroke();
    
    // Draw selection overlay if this species has selection data
    if (speciesAudioSynths[speciesIndex] && typeof speciesIndex !== 'undefined') {
        const synth = speciesAudioSynths[speciesIndex];
        if (synth.sampleStart !== 0 || synth.sampleEnd !== 1) {
            const startX = synth.sampleStart * width;
            const endX = synth.sampleEnd * width;
            const selectionWidth = endX - startX;
            
            // Draw selection rectangle
            ctx.fillStyle = `rgba(${Math.round(color[0] * 255)}, ${Math.round(color[1] * 255)}, ${Math.round(color[2] * 255)}, 0.3)`;
            ctx.fillRect(startX, 0, selectionWidth, height);
            
            // Draw selection borders
            ctx.strokeStyle = `rgb(${Math.round(color[0] * 255)}, ${Math.round(color[1] * 255)}, ${Math.round(color[2] * 255)})`;
            ctx.lineWidth = 2;
            ctx.strokeRect(startX, 0, selectionWidth, height);
        }
    }
    
    // Draw current selection if actively selecting on this canvas
    if (waveformSelection.isSelecting && waveformSelection.canvas === canvas) {
        const startX = Math.min(waveformSelection.startX, waveformSelection.currentX);
        const endX = Math.max(waveformSelection.startX, waveformSelection.currentX);
        const selectionWidth = endX - startX;
        
        // Draw active selection
        ctx.fillStyle = `rgba(${Math.round(color[0] * 255)}, ${Math.round(color[1] * 255)}, ${Math.round(color[2] * 255)}, 0.4)`;
        ctx.fillRect(startX, 0, selectionWidth, height);
        
        ctx.strokeStyle = `rgb(${Math.round(color[0] * 255)}, ${Math.round(color[1] * 255)}, ${Math.round(color[2] * 255)})`;
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(startX, 0, selectionWidth, height);
        ctx.setLineDash([]); // Reset line dash
    }
}

// Setup waveform selection handlers
function setupWaveformSelection(canvas, speciesIndex) {
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        
        waveformSelection.isSelecting = true;
        waveformSelection.speciesIndex = speciesIndex;
        waveformSelection.startX = x;
        waveformSelection.currentX = x;
        waveformSelection.canvas = canvas;
        
        e.preventDefault();
    });
    
    canvas.addEventListener('mousemove', (e) => {
        if (!waveformSelection.isSelecting || waveformSelection.canvas !== canvas) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        waveformSelection.currentX = Math.max(0, Math.min(canvas.width, x));
        
        // Redraw waveform with current selection
        if (speciesAudioSynths[speciesIndex] && speciesAudioSynths[speciesIndex].audioBuffer) {
            drawWaveform(speciesAudioSynths[speciesIndex].audioBuffer, canvas, (typeof speciesColors !== 'undefined' ? speciesColors[speciesIndex] : [1,1,1]), speciesIndex);
        }
        
        e.preventDefault();
    });
    
    canvas.addEventListener('mouseup', (e) => {
        if (!waveformSelection.isSelecting || waveformSelection.canvas !== canvas) return;
        
        const startX = Math.min(waveformSelection.startX, waveformSelection.currentX);
        const endX = Math.max(waveformSelection.startX, waveformSelection.currentX);
        const width = canvas.width;
        
        // Convert pixels to normalized positions (0-1)
        const startPos = Math.max(0, Math.min(1, startX / width));
        const endPos = Math.max(0, Math.min(1, endX / width));
        
        // Only update if there's a meaningful selection (at least 2% of the waveform)
        if (Math.abs(endPos - startPos) > 0.02) {
            const synth = speciesAudioSynths[speciesIndex];
            if (synth) {
                synth.sampleStart = startPos;
                synth.sampleEnd = endPos;
                console.log(`🎵 Species ${String.fromCharCode(65 + speciesIndex)} sample selection: ${(startPos * 100).toFixed(1)}% - ${(endPos * 100).toFixed(1)}%`);
            }
        }
        
        // Reset selection state
        waveformSelection.isSelecting = false;
        waveformSelection.speciesIndex = -1;
        waveformSelection.canvas = null;
        
        // Final redraw
        if (speciesAudioSynths[speciesIndex] && speciesAudioSynths[speciesIndex].audioBuffer) {
            drawWaveform(speciesAudioSynths[speciesIndex].audioBuffer, canvas, (typeof speciesColors !== 'undefined' ? speciesColors[speciesIndex] : [1,1,1]), speciesIndex);
        }
        
        e.preventDefault();
    });
    
    // Handle mouse leaving the canvas
    canvas.addEventListener('mouseleave', (e) => {
        if (waveformSelection.isSelecting && waveformSelection.canvas === canvas) {
            // Cancel selection
            waveformSelection.isSelecting = false;
            waveformSelection.speciesIndex = -1;
            waveformSelection.canvas = null;
            
            // Redraw without selection
            if (speciesAudioSynths[speciesIndex] && speciesAudioSynths[speciesIndex].audioBuffer) {
                drawWaveform(speciesAudioSynths[speciesIndex].audioBuffer, canvas, (typeof speciesColors !== 'undefined' ? speciesColors[speciesIndex] : [1,1,1]), speciesIndex);
            }
        }
    });
    
    // Double-click to reset selection to full waveform
    canvas.addEventListener('dblclick', (e) => {
        const synth = speciesAudioSynths[speciesIndex];
        if (synth) {
            synth.sampleStart = 0.0;
            synth.sampleEnd = 1.0;
            console.log(`🎵 Species ${String.fromCharCode(65 + speciesIndex)} sample selection reset to full waveform`);
            
            // Redraw waveform
            if (synth.audioBuffer) {
                drawWaveform(synth.audioBuffer, canvas, (typeof speciesColors !== 'undefined' ? speciesColors[speciesIndex] : [1,1,1]), speciesIndex);
            }
        }
        e.preventDefault();
    });
    
    // Make canvas cursor indicate it's selectable
    canvas.style.cursor = 'crosshair';
}

// RGB to Hex conversion function - ensure it's defined before createSpeciesAudioControls
function rgbToHex(rgbArray) {
    const r = Math.round(rgbArray[0] * 255);
    const g = Math.round(rgbArray[1] * 255);
    const b = Math.round(rgbArray[2] * 255);
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

// ===== UI GENERATION (Audio UI only) =====
// Global variable to track currently selected species for audio controls
let selectedSpeciesForAudio = 0;

// Species selector is now handled by the species tab system in main HTML

// Create species audio controls UI - defined globally (now shows single species)
function createSpeciesAudioControls() {
    const container = document.getElementById('speciesAudioControls');
    if (!container) return;
    
    container.innerHTML = '';
    
    // Use window variables if available, fallback to defaults
    const currentSpeciesCount = (typeof speciesCount !== 'undefined') ? speciesCount : 2;
    const currentSpeciesColors = (typeof speciesColors !== 'undefined') ? speciesColors : [[1,0,0],[0,0,1]];
    const currentParticleCounts = (typeof particleCounts !== 'undefined') ? particleCounts : [200, 200];
    const currentParticleSizes = (typeof particleSizes !== 'undefined') ? particleSizes : [4, 4];
    const currentSpeciesTrailLengths = (typeof speciesTrailLengths !== 'undefined') ? speciesTrailLengths : [0.75, 0.65];
    
    // Only create panel for selected species
    const i = selectedSpeciesForAudio;
    if (i >= currentSpeciesCount) {
        selectedSpeciesForAudio = 0;
        return;
    }
    
    const synth = speciesAudioSynths[i];
    const panel = document.createElement('div');
    panel.className = 'species-audio-panel';
    
    // Add count/size/trail controls at top of panel
    const speciesParamsHeader = document.createElement('div');
    speciesParamsHeader.innerHTML = '<h4 style="margin: 0 0 10px 0; color: #ccc; font-size: 14px; border-bottom: 1px solid #333; padding-bottom: 5px;">Species Parameters</h4>';
    
    const speciesParamsRow = document.createElement('div');
    speciesParamsRow.className = 'species-row';
    speciesParamsRow.style.marginBottom = '15px';

    const speciesLabel = document.createElement('div');
    speciesLabel.className = 'species-label';
    speciesLabel.style.color = rgbToHex(currentSpeciesColors[i] || [1,1,1]);
    speciesLabel.textContent = `Species ${String.fromCharCode(65 + i)}`;

    // Count parameter
    const countGroup = document.createElement('div');
    countGroup.className = 'param-group';
    
    const countLabel = document.createElement('span');
    countLabel.className = 'param-label';
    countLabel.textContent = 'Count:';
    
    const countValue = document.createElement('div');
    countValue.className = 'draggable-number';
    countValue.textContent = currentParticleCounts[i] || 200;
    countValue.id = `count-${i}`;
    
    countGroup.appendChild(countLabel);
    countGroup.appendChild(countValue);

    // Size parameter
    const sizeGroup = document.createElement('div');
    sizeGroup.className = 'param-group';
    
    const sizeLabel = document.createElement('span');
    sizeLabel.className = 'param-label';
    sizeLabel.textContent = 'Size:';
    
    const sizeValue = document.createElement('div');
    sizeValue.className = 'draggable-number';
    sizeValue.textContent = currentParticleSizes[i] || 4;
    sizeValue.id = `size-${i}`;
    
    sizeGroup.appendChild(sizeLabel);
    sizeGroup.appendChild(sizeValue);

    // Trail parameter
    const trailGroup = document.createElement('div');
    trailGroup.className = 'param-group';
    
    const trailLabel = document.createElement('span');
    trailLabel.className = 'param-label';
    trailLabel.textContent = 'Trail:';
    
    const trailValue = document.createElement('div');
    trailValue.className = 'draggable-number';
    trailValue.textContent = (currentSpeciesTrailLengths[i] || 0.75).toFixed(2);
    trailValue.id = `trail-${i}`;
    
    trailGroup.appendChild(trailLabel);
    trailGroup.appendChild(trailValue);

    speciesParamsRow.appendChild(speciesLabel);
    speciesParamsRow.appendChild(countGroup);
    speciesParamsRow.appendChild(sizeGroup);
    speciesParamsRow.appendChild(trailGroup);
    
    const header = document.createElement('div');
    header.className = 'species-audio-header';
    header.innerHTML = '<h4 style="margin: 0 0 10px 0; color: #ccc; font-size: 14px; border-bottom: 1px solid #333; padding-bottom: 5px;">Audio Controls</h4>';
    
    const title = document.createElement('div');
    title.className = 'species-audio-title';
    title.style.color = rgbToHex(currentSpeciesColors[i] || [1,1,1]);
    title.textContent = `Species ${String.fromCharCode(65 + i)}`;
    
    const muteButton = document.createElement('button');
    muteButton.className = 'audio-button';
    muteButton.id = `speciesMute${i}`;
    muteButton.textContent = (synth && synth.isMuted) ? '🔇' : '🔊';
    if (synth && !synth.isMuted) muteButton.classList.add('active');
    muteButton.addEventListener('click', () => toggleSpeciesMute(i));
    
    header.appendChild(title);
    header.appendChild(muteButton);
    
    // File controls
    const fileControls = document.createElement('div');
    fileControls.className = 'audio-file-controls';
    
    const fileWrapper = document.createElement('div');
    fileWrapper.className = 'file-input-wrapper';
    
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.id = `audioFile${i}`;
    fileInput.accept = '.wav,.mp3,.m4a,.ogg';
    fileInput.addEventListener('change', (e) => loadAudioFile(e, i));
    
    const fileLabel = document.createElement('label');
    fileLabel.className = 'file-input-label';
    fileLabel.htmlFor = `audioFile${i}`;
    fileLabel.textContent = '📁 Load Sample';
    
    const fileName = document.createElement('div');
    fileName.className = 'file-name';
    fileName.id = `fileName${i}`;
    fileName.textContent = (synth && synth.fileName) || 'No Sample';
    
    fileWrapper.appendChild(fileInput);
    fileWrapper.appendChild(fileLabel);
    fileControls.appendChild(fileWrapper);
    fileControls.appendChild(fileName);
    
    // Waveform display
    const waveformContainer = document.createElement('div');
    waveformContainer.className = 'waveform-container';
    
    const waveformCanvas = document.createElement('canvas');
    waveformCanvas.className = 'waveform-canvas';
    waveformCanvas.id = `waveform${i}`;
    waveformCanvas.width = 280;
    waveformCanvas.height = 40;
    
    waveformContainer.appendChild(waveformCanvas);
    
    // Setup waveform selection handlers
    setupWaveformSelection(waveformCanvas, i);
    
    // Audio Mode Tab System
    const audioModeTabsContainer = document.createElement('div');
    audioModeTabsContainer.className = 'audio-mode-tabs';
    
    const currentTriggerMode = (synth && synth.triggerMode) || TRIGGER_MODES.LOOPING;
    
    // Collision mode tab
    const collisionTab = document.createElement('button');
    collisionTab.className = 'audio-mode-tab';
    if (currentTriggerMode === TRIGGER_MODES.COLLISION) collisionTab.classList.add('active');
    collisionTab.innerHTML = '<span>✨</span><span>Collision</span>';
    collisionTab.addEventListener('click', () => {
        setSpeciesTriggerMode(i, TRIGGER_MODES.COLLISION);
        updateAudioModeUI(i);
    });
    
    // Looping mode tab
    const loopingTab = document.createElement('button');
    loopingTab.className = 'audio-mode-tab';
    if (currentTriggerMode === TRIGGER_MODES.LOOPING) loopingTab.classList.add('active');
    loopingTab.innerHTML = '<span>🔁</span><span>Looping</span>';
    loopingTab.addEventListener('click', () => {
        setSpeciesTriggerMode(i, TRIGGER_MODES.LOOPING);
        updateAudioModeUI(i);
    });
    
    audioModeTabsContainer.appendChild(collisionTab);
    audioModeTabsContainer.appendChild(loopingTab);
    
    // Volume control
    const volumeRow = document.createElement('div');
    volumeRow.className = 'audio-controls-row';
    
    const volumeLabel = document.createElement('span');
    volumeLabel.textContent = 'Volume:';
    volumeLabel.style.minWidth = '50px';
    volumeLabel.style.fontSize = '12px';
    
    const volumeSlider = document.createElement('input');
    volumeSlider.type = 'range';
    volumeSlider.className = 'slider';
    volumeSlider.id = `speciesVolume${i}`;
    volumeSlider.min = '0';
    volumeSlider.max = '1';
    volumeSlider.step = '0.05';
    const currentVolume = (synth && typeof synth.volume !== 'undefined') ? synth.volume : 0.7;
    volumeSlider.value = currentVolume.toString();
    volumeSlider.style.flex = '1';
    volumeSlider.addEventListener('input', (e) => setSpeciesVolume(i, parseFloat(e.target.value)));
    
    const volumeValue = document.createElement('span');
    volumeValue.className = 'value-display';
    volumeValue.id = `speciesVolume${i}-value`;
    volumeValue.textContent = currentVolume.toFixed(2);
    
    volumeRow.appendChild(volumeLabel);
    volumeRow.appendChild(volumeSlider);
    volumeRow.appendChild(volumeValue);
    
    // Audio mode content container
    const audioModeContent = document.createElement('div');
    audioModeContent.className = 'audio-mode-content';
    audioModeContent.id = `audioModeContent${i}`;
    
    // Create both mode panels
    createAudioModePanels(audioModeContent, i, currentTriggerMode, synth);
    
    // This is now handled in createAudioModePanels
    
    // Legacy loop controls moved to mode-specific section
    
    // Pitch control
    const pitchRow = document.createElement('div');
    pitchRow.className = 'audio-controls-row';
    
    const pitchLabel = document.createElement('span');
    pitchLabel.textContent = 'Pitch:';
    pitchLabel.style.minWidth = '50px';
    pitchLabel.style.fontSize = '12px';
    
    const pitchSlider = document.createElement('input');
    pitchSlider.type = 'range';
    pitchSlider.className = 'slider';
    pitchSlider.id = `speciesPitch${i}`;
    pitchSlider.min = '-12';
    pitchSlider.max = '12';
    pitchSlider.step = '1';
    const currentPitch = (synth && typeof synth.pitch !== 'undefined') ? synth.pitch : 0;
    pitchSlider.value = currentPitch.toString();
    pitchSlider.style.flex = '1';
    pitchSlider.addEventListener('input', (e) => setSpeciesPitch(i, parseInt(e.target.value)));
    
    const pitchValue = document.createElement('span');
    pitchValue.className = 'value-display';
    pitchValue.id = `speciesPitch${i}-value`;
    pitchValue.textContent = currentPitch >= 0 ? `+${currentPitch}st` : `${currentPitch}st`;
    
    pitchRow.appendChild(pitchLabel);
    pitchRow.appendChild(pitchSlider);
    pitchRow.appendChild(pitchValue);
    
    // Detune control
    const detuneRow = document.createElement('div');
    detuneRow.className = 'audio-controls-row';
    
    const detuneLabel = document.createElement('span');
    detuneLabel.textContent = 'Detune:';
    detuneLabel.style.minWidth = '50px';
    detuneLabel.style.fontSize = '12px';
    
    const detuneSlider = document.createElement('input');
    detuneSlider.type = 'range';
    detuneSlider.className = 'slider';
    detuneSlider.id = `speciesDetune${i}`;
    detuneSlider.min = '0';
    detuneSlider.max = '50';
    detuneSlider.step = '1';
    const currentDetune = (synth && typeof synth.detune !== 'undefined') ? synth.detune : 0;
    detuneSlider.value = currentDetune.toString();
    detuneSlider.style.flex = '1';
    detuneSlider.addEventListener('input', (e) => setSpeciesDetune(i, parseInt(e.target.value)));
    
    const detuneValue = document.createElement('span');
    detuneValue.className = 'value-display';
    detuneValue.id = `speciesDetune${i}-value`;
    detuneValue.textContent = `${currentDetune}¢`;
    
    detuneRow.appendChild(detuneLabel);
    detuneRow.appendChild(detuneSlider);
    detuneRow.appendChild(detuneValue);
    
    // Fade Length control
    const fadeRow = document.createElement('div');
    fadeRow.className = 'audio-controls-row';
    
    const fadeLabel = document.createElement('span');
    fadeLabel.textContent = 'Fade:';
    fadeLabel.style.minWidth = '50px';
    fadeLabel.style.fontSize = '12px';
    
    const fadeSlider = document.createElement('input');
    fadeSlider.type = 'range';
    fadeSlider.className = 'slider';
    fadeSlider.id = `speciesFade${i}`;
    fadeSlider.min = '0.001';
    fadeSlider.max = '0.02';
    fadeSlider.step = '0.001';
    const currentFade = (synth && typeof synth.fadeLength !== 'undefined') ? synth.fadeLength : 0.002;
    fadeSlider.value = currentFade.toString();
    fadeSlider.style.flex = '1';
    fadeSlider.addEventListener('input', (e) => setSpeciesFadeLength(i, parseFloat(e.target.value)));
    
    const fadeValue = document.createElement('span');
    fadeValue.className = 'value-display';
    fadeValue.id = `speciesFade${i}-value`;
    fadeValue.textContent = `${Math.round(currentFade * 1000)}ms`;
    
    fadeRow.appendChild(fadeLabel);
    fadeRow.appendChild(fadeSlider);
    fadeRow.appendChild(fadeValue);
    
    // Activity indicators
    const activityRow = document.createElement('div');
    activityRow.className = 'audio-controls-row';
    
    const activityLabel = document.createElement('span');
    activityLabel.textContent = 'Grains:';
    activityLabel.style.minWidth = '50px';
    activityLabel.style.fontSize = '12px';
    
    const grainActivity = document.createElement('div');
    grainActivity.className = 'grain-activity';
    grainActivity.id = `grainActivity${i}`;
    
    // Create grain indicators
    for (let j = 0; j < 10; j++) {
        const indicator = document.createElement('div');
        indicator.className = 'grain-indicator';
        grainActivity.appendChild(indicator);
    }
    
    const audioMeter = document.createElement('div');
    audioMeter.className = 'audio-meter';
    
    const meterBar = document.createElement('div');
    meterBar.className = 'meter-bar';
    
    const meterFill = document.createElement('div');
    meterFill.className = 'meter-fill';
    meterFill.id = `meterFill${i}`;
    
    meterBar.appendChild(meterFill);
    audioMeter.appendChild(meterBar);
    
    const grainCount = document.createElement('span');
    grainCount.id = `grainCount${i}`;
    grainCount.textContent = '0/50';
    grainCount.style.fontSize = '11px';
    grainCount.style.color = '#888';
    
    audioMeter.appendChild(grainCount);
    
    activityRow.appendChild(activityLabel);
    activityRow.appendChild(grainActivity);
    activityRow.appendChild(audioMeter);
    
    // Gain reduction meter removed - too confusing for users
    
    // Assemble panel
    panel.appendChild(speciesParamsHeader);
    panel.appendChild(speciesParamsRow);
    panel.appendChild(header);
    panel.appendChild(fileControls);
    panel.appendChild(waveformContainer);
    panel.appendChild(audioModeTabsContainer);
    panel.appendChild(audioModeContent);
    panel.appendChild(volumeRow);
    panel.appendChild(pitchRow);
    panel.appendChild(detuneRow);
    panel.appendChild(fadeRow);
    panel.appendChild(activityRow);
    
    container.appendChild(panel);
    
    // Draw waveform if audio buffer exists
    if (synth && synth.audioBuffer) {
        drawWaveform(synth.audioBuffer, waveformCanvas, currentSpeciesColors[i] || [1,1,1], i);
    }
    
    // Setup draggable numbers for the species parameters (call from main script if available)
    if (typeof setupDraggableNumbers === 'function') {
        setTimeout(() => setupDraggableNumbers(), 0);
    }
}

// Set species trigger mode
function setSpeciesTriggerMode(speciesIndex, mode) {
    if (!speciesAudioSynths[speciesIndex]) return;
    
    const synth = speciesAudioSynths[speciesIndex];
    synth.setTriggerMode(mode);
    
    console.log(`🎵 Species ${String.fromCharCode(65 + speciesIndex)} trigger mode: ${mode}`);
}

// Update engine parameter
function updateEngineParameter(speciesIndex, parameter, value) {
    if (!speciesAudioSynths[speciesIndex]) return;
    
    const synth = speciesAudioSynths[speciesIndex];
    const settings = {};
    settings[parameter] = value;
    synth.updateEngineSettings(settings);
    
    // Update UI display
    const valueElement = document.getElementById(`species${parameter.charAt(0).toUpperCase() + parameter.slice(1)}${speciesIndex}-value`);
    if (valueElement) {
        if (parameter === 'ratio') {
            valueElement.textContent = `${value.toFixed(1)}:1`;
        } else {
            valueElement.textContent = value.toFixed(2);
        }
    }
}

// Update audio mode UI
function updateAudioModeUI(speciesIndex) {
    const audioModeContent = document.getElementById(`audioModeContent${speciesIndex}`);
    if (!audioModeContent || !speciesAudioSynths[speciesIndex]) return;
    
    const synth = speciesAudioSynths[speciesIndex];
    
    // Update tab appearance
    const tabs = audioModeContent.parentNode.querySelectorAll('.audio-mode-tab');
    tabs.forEach((tab, index) => {
        const isActive = (index === 0 && synth.triggerMode === TRIGGER_MODES.COLLISION) ||
                        (index === 1 && synth.triggerMode === TRIGGER_MODES.LOOPING);
        tab.classList.toggle('active', isActive);
    });
    
    // Show/hide appropriate panels
    const collisionPanel = document.getElementById(`collisionPanel${speciesIndex}`);
    const loopingPanel = document.getElementById(`loopingPanel${speciesIndex}`);
    
    if (collisionPanel && loopingPanel) {
        collisionPanel.classList.toggle('active', synth.triggerMode === TRIGGER_MODES.COLLISION);
        loopingPanel.classList.toggle('active', synth.triggerMode === TRIGGER_MODES.LOOPING);
    }
}

// Create audio mode panels (Collision and Looping)
function createAudioModePanels(container, speciesIndex, currentMode, synth) {
    container.innerHTML = '';
    
    // Collision mode panel
    const collisionPanel = document.createElement('div');
    collisionPanel.className = 'audio-mode-panel';
    collisionPanel.id = `collisionPanel${speciesIndex}`;
    if (currentMode === TRIGGER_MODES.COLLISION) collisionPanel.classList.add('active');
    
    createCollisionModePanel(collisionPanel, speciesIndex, synth);
    
    // Looping mode panel
    const loopingPanel = document.createElement('div');
    loopingPanel.className = 'audio-mode-panel';
    loopingPanel.id = `loopingPanel${speciesIndex}`;
    if (currentMode === TRIGGER_MODES.LOOPING) loopingPanel.classList.add('active');
    
    createLoopingModePanel(loopingPanel, speciesIndex, synth);
    
    container.appendChild(collisionPanel);
    container.appendChild(loopingPanel);
}

// Create collision mode panel with intuitive controls
function createCollisionModePanel(container, speciesIndex, synth) {
    // Threshold with visualization
    const thresholdGroup = document.createElement('div');
    thresholdGroup.className = 'audio-controls-group';
    
    const thresholdTitle = document.createElement('h4');
    thresholdTitle.textContent = 'Collision Threshold';
    thresholdGroup.appendChild(thresholdTitle);
    
    const thresholdContainer = document.createElement('div');
    thresholdContainer.className = 'threshold-container';
    thresholdContainer.style.position = 'relative'; // Required for absolute positioned children
    
    // Collision pulse visualization
    const collisionViz = document.createElement('div');
    collisionViz.className = 'collision-pulse-container';
    collisionViz.id = `collisionPulseContainer${speciesIndex}`;
    collisionViz.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        right: 50px;
        height: 6px;
        border-radius: 3px;
        overflow: hidden;
        z-index: 1;
        pointer-events: none;
    `;
    
    thresholdContainer.appendChild(collisionViz);
    
    // Hide the original threshold slider - we'll use the new drag interface
    const thresholdSlider = document.createElement('input');
    thresholdSlider.type = 'range';
    thresholdSlider.className = 'slider threshold-slider';
    thresholdSlider.id = `speciesThreshold${speciesIndex}`;
    thresholdSlider.min = '0.01';
    thresholdSlider.max = '1.0';
    thresholdSlider.step = '0.01';
    thresholdSlider.value = '0.15'; // Better default for collisions
    thresholdSlider.style.display = 'none'; // Hide original slider
    thresholdSlider.addEventListener('input', (e) => {
        updateEngineParameter(speciesIndex, 'threshold', parseFloat(e.target.value));
    });
    
    thresholdContainer.appendChild(thresholdSlider);
    
    const thresholdRow = document.createElement('div');
    thresholdRow.className = 'audio-controls-row';
    thresholdRow.appendChild(thresholdContainer);
    
    thresholdGroup.appendChild(thresholdRow);
    
    // Add smoothing dial to threshold group
    createSmoothingDial(thresholdContainer, speciesIndex, 'collision');
    
    // Species collision matrix
    const matrixGroup = document.createElement('div');
    matrixGroup.className = 'audio-controls-group';
    
    const matrixTitle = document.createElement('h4');
    matrixTitle.textContent = 'Collision Triggers';
    matrixGroup.appendChild(matrixTitle);
    
    createSpeciesCollisionMatrix(matrixGroup, speciesIndex);
    
    container.appendChild(thresholdGroup);
    container.appendChild(matrixGroup);
}

// Create looping mode panel
function createLoopingModePanel(container, speciesIndex, synth) {
    // Threshold with velocity visualization
    const thresholdGroup = document.createElement('div');
    thresholdGroup.className = 'audio-controls-group';
    
    const thresholdTitle = document.createElement('h4');
    thresholdTitle.textContent = 'Velocity Threshold';
    thresholdGroup.appendChild(thresholdTitle);
    
    const thresholdContainer = document.createElement('div');
    thresholdContainer.className = 'threshold-container';
    thresholdContainer.style.position = 'relative'; // Required for absolute positioned children
    
    // Velocity level visualization
    const velocityViz = document.createElement('div');
    velocityViz.className = 'threshold-visualization';
    
    const velocityBar = document.createElement('div');
    velocityBar.className = 'velocity-level-bar';
    velocityBar.id = `velocityBar${speciesIndex}`;
    
    velocityViz.appendChild(velocityBar);
    thresholdContainer.appendChild(velocityViz);
    
    // Hide the original threshold slider - we'll use the new drag interface
    const thresholdSlider = document.createElement('input');
    thresholdSlider.type = 'range';
    thresholdSlider.className = 'slider threshold-slider';
    thresholdSlider.id = `speciesThreshold${speciesIndex}`;
    thresholdSlider.min = '0.01';
    thresholdSlider.max = '1.0';
    thresholdSlider.step = '0.01';
    thresholdSlider.value = '0.05'; // Lower default for continuous looping
    thresholdSlider.style.display = 'none'; // Hide original slider
    thresholdSlider.addEventListener('input', (e) => {
        updateEngineParameter(speciesIndex, 'threshold', parseFloat(e.target.value));
    });
    
    thresholdContainer.appendChild(thresholdSlider);
    
    const thresholdRow = document.createElement('div');
    thresholdRow.className = 'audio-controls-row';
    thresholdRow.appendChild(thresholdContainer);
    
    thresholdGroup.appendChild(thresholdRow);
    
    // Add smoothing dial to threshold group
    createSmoothingDial(thresholdContainer, speciesIndex, 'looping');
    
    // Loop direction and crossfade
    const loopGroup = document.createElement('div');
    loopGroup.className = 'audio-controls-group';
    
    const loopTitle = document.createElement('h4');
    loopTitle.textContent = 'Loop Settings';
    loopGroup.appendChild(loopTitle);
    
    createLoopingControls(loopGroup, speciesIndex);
    
    container.appendChild(thresholdGroup);
    container.appendChild(loopGroup);
}

// Create smoothing dial component
function createSmoothingDial(container, speciesIndex, mode) {
    const dialContainer = document.createElement('div');
    dialContainer.className = 'smoothing-dial-container';
    dialContainer.style.cssText = `
        position: absolute;
        right: 0;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        align-items: center;
        gap: 4px;
        z-index: 3;
    `;
    
    const dial = document.createElement('div');
    dial.className = 'smoothing-dial';
    dial.id = `${mode}SmoothingDial${speciesIndex}`;
    dial.style.cssText = `
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: #444;
        border: 2px solid #666;
        position: relative;
        cursor: pointer;
        transition: border-color 0.2s ease;
    `;
    
    const indicator = document.createElement('div');
    indicator.className = 'smoothing-dial-indicator';
    indicator.id = `${mode}SmoothingDialIndicator${speciesIndex}`;
    indicator.style.cssText = `
        position: absolute;
        top: 2px;
        left: 50%;
        width: 2px;
        height: 8px;
        background: #4CAF50;
        transform-origin: center bottom;
        transform: translateX(-50%) rotate(0deg);
        border-radius: 1px;
        transition: transform 0.1s ease;
    `;
    
    dial.appendChild(indicator);
    
    const dialValue = document.createElement('div');
    dialValue.className = 'smoothing-dial-value';
    dialValue.id = `${mode}SmoothingDialValue${speciesIndex}`;
    dialValue.style.cssText = `
        font-size: 10px;
        color: #888;
        min-width: 20px;
        text-align: center;
    `;
    dialValue.textContent = '0.0';
    
    dialContainer.appendChild(dial);
    dialContainer.appendChild(dialValue);
    
    // Add smoothing visualization to the threshold container
    addSmoothingVisualization(container, speciesIndex, mode);
    
    // Setup dial interaction
    setupSmoothingDialInteraction(dial, speciesIndex, mode);
    
    container.appendChild(dialContainer);
}

// Add smoothing visualization to threshold container
function addSmoothingVisualization(container, speciesIndex, mode) {
    // Create new threshold visualization elements
    
    // Make the container bigger and adjust styling to fit within parent
    container.style.cssText += `
        height: 14px; /* 20% thicker than previous 12px */
        width: 100%; /* Fit within container */
        max-width: calc(100% - 60px); /* Leave space for smoothing dial */
        margin: 10px 0;
        box-sizing: border-box;
    `;
    
    // Create threshold line (vertical line that shows current threshold position)
    const thresholdLine = document.createElement('div');
    thresholdLine.className = 'threshold-line';
    thresholdLine.id = `${mode}ThresholdLine${speciesIndex}`;
    thresholdLine.style.cssText = `
        position: absolute;
        top: -2px;
        width: 2px;
        height: 18px; /* Match new container height + 4px extra */
        background: #fff;
        z-index: 5;
        left: 15%; /* Initial position */
        pointer-events: none;
        box-shadow: 0 0 4px rgba(255, 255, 255, 0.5);
    `;
    
    // Create drag tab underneath the meter
    const dragTab = document.createElement('div');
    dragTab.className = 'threshold-drag-tab';
    dragTab.id = `${mode}DragTab${speciesIndex}`;
    dragTab.style.cssText = `
        position: absolute;
        top: 16px; /* Adjusted for new container height */
        left: calc(15% - 8px);
        width: 16px;
        height: 8px;
        background: #4CAF50;
        border-radius: 0 0 4px 4px;
        cursor: ew-resize;
        z-index: 5;
        border: 1px solid #fff;
    `;
    
    // Create single smoothing ramp line (left side, ramping up to threshold)
    const smoothRampLine = document.createElement('div');
    smoothRampLine.className = 'smoothing-ramp-line';
    smoothRampLine.id = `${mode}SmoothRampLine${speciesIndex}`;
    smoothRampLine.style.cssText = `
        position: absolute;
        top: 0;
        width: 0px;
        height: 14px; /* Full height of container */
        background: linear-gradient(to right, transparent, rgba(76, 175, 80, 0.3));
        z-index: 3;
        right: 85%; /* Start from left, end at threshold (15% from left = 85% from right) */
        opacity: 0;
        transition: all 0.2s ease;
        border-radius: 2px 0 0 2px;
    `;
    
    container.appendChild(thresholdLine);
    container.appendChild(dragTab);
    container.appendChild(smoothRampLine);
    
    // Setup drag interaction for the new tab
    setupThresholdDragInteraction(dragTab, thresholdLine, smoothRampLine, speciesIndex, mode);
}

// Setup smoothing dial interaction
function setupSmoothingDialInteraction(dial, speciesIndex, mode) {
    let isDragging = false;
    let startY = 0;
    let startSmoothing = 0.0;
    
    dial.addEventListener('mousedown', (e) => {
        isDragging = true;
        startY = e.clientY;
        const synth = speciesAudioSynths[speciesIndex];
        startSmoothing = (synth && synth.currentEngine && synth.currentEngine.smoothing !== undefined) ? synth.currentEngine.smoothing : 0.0;
        e.preventDefault();
    });
    
    const handleMouseMove = (e) => {
        if (!isDragging) return;
        
        // Use vertical mouse movement: up increases smoothing, down decreases
        const deltaY = startY - e.clientY;
        const sensitivity = 0.01; // Smoothing change per pixel
        let newSmoothing = startSmoothing + (deltaY * sensitivity);
        newSmoothing = Math.max(0.0, Math.min(1.0, newSmoothing)); // Clamp to 0-1
        
        // Update visual indicator
        const indicator = document.getElementById(`${mode}SmoothingDialIndicator${speciesIndex}`);
        if (indicator) {
            const rotationDegrees = (newSmoothing * 180) - 90; // -90 to +90 degrees
            indicator.style.transform = `translateX(-50%) rotate(${rotationDegrees}deg)`;
        }
        
        // Update value display
        const valueDisplay = document.getElementById(`${mode}SmoothingDialValue${speciesIndex}`);
        if (valueDisplay) {
            valueDisplay.textContent = newSmoothing.toFixed(1);
        }
        
        // Update smoothing visualization
        updateSmoothingVisualization(speciesIndex, mode, newSmoothing);
        
        // Update engine parameter
        updateEngineParameter(speciesIndex, 'smoothing', newSmoothing);
    };
    
    const handleMouseUp = () => {
        if (isDragging) {
            isDragging = false;
        }
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
}

// Setup threshold drag interaction
function setupThresholdDragInteraction(dragTab, thresholdLine, smoothRampLine, speciesIndex, mode) {
    let isDragging = false;
    let startX = 0;
    let containerRect = null;
    
    dragTab.addEventListener('mousedown', (e) => {
        isDragging = true;
        startX = e.clientX;
        containerRect = dragTab.parentNode.getBoundingClientRect();
        e.preventDefault();
    });
    
    const handleMouseMove = (e) => {
        if (!isDragging || !containerRect) return;
        
        // Calculate position relative to container
        const relativeX = e.clientX - containerRect.left;
        const containerWidth = containerRect.width - 60; // Account for smoothing dial space
        let position = Math.max(0, Math.min(1, relativeX / containerWidth));
        
        // Update threshold value
        updateEngineParameter(speciesIndex, 'threshold', position);
        
        // Update visual elements
        const percentage = position * 100;
        thresholdLine.style.left = `${percentage}%`;
        dragTab.style.left = `calc(${percentage}% - 8px)`;
        
        // Update smoothing ramp position (ends at threshold)
        smoothRampLine.style.right = `${100 - percentage}%`;
    };
    
    const handleMouseUp = () => {
        if (isDragging) {
            isDragging = false;
            containerRect = null;
        }
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
}

// Update smoothing visualization on threshold slider
function updateSmoothingVisualization(speciesIndex, mode, smoothingValue) {
    const smoothRampLine = document.getElementById(`${mode}SmoothRampLine${speciesIndex}`);
    
    if (!smoothRampLine) return;
    
    if (smoothingValue > 0) {
        // Show smoothing ramp with width based on smoothing value
        const rampWidth = smoothingValue * 30; // Max 30% of container width
        
        smoothRampLine.style.opacity = '1';
        smoothRampLine.style.width = `${rampWidth}%`;
    } else {
        // Hide smoothing ramp when smoothing is 0
        smoothRampLine.style.opacity = '0';
        smoothRampLine.style.width = '0%';
    }
}

// Create species collision matrix (simplified from old version)
function createSpeciesCollisionMatrix(container, speciesIndex) {
    const matrixContainer = document.createElement('div');
    matrixContainer.style.display = 'grid';
    matrixContainer.style.gridTemplateColumns = 'repeat(4, 1fr)';
    matrixContainer.style.gap = '6px';
    
    const currentSpeciesCount = (typeof speciesCount !== 'undefined') ? speciesCount : 2;
    const currentSpeciesColors = (typeof speciesColors !== 'undefined') ? speciesColors : [[1,0,0],[0,0,1]];
    
    for (let i = 0; i < Math.min(currentSpeciesCount, 8); i++) {
        const checkboxContainer = document.createElement('label');
        checkboxContainer.style.display = 'flex';
        checkboxContainer.style.alignItems = 'center';
        checkboxContainer.style.gap = '6px';
        checkboxContainer.style.fontSize = '12px';
        checkboxContainer.style.color = rgbToHex(currentSpeciesColors[i] || [1,1,1]);
        checkboxContainer.style.cursor = 'pointer';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = true; // Default: all species can trigger
        checkbox.addEventListener('change', (e) => {
            updateCollisionMatrix(speciesIndex, i, e.target.checked);
        });
        
        const label = document.createElement('span');
        label.textContent = String.fromCharCode(65 + i);
        
        checkboxContainer.appendChild(checkbox);
        checkboxContainer.appendChild(label);
        matrixContainer.appendChild(checkboxContainer);
    }
    
    container.appendChild(matrixContainer);
}

// Species velocity/collision tracking for visualization
let speciesActivityLevels = new Array(8).fill(0);

// Update species activity levels (called from animation loop)
function updateSpeciesActivityLevels(particles) {
    const currentSpeciesCount = (typeof speciesCount !== 'undefined') ? speciesCount : 2;
    
    for (let i = 0; i < currentSpeciesCount; i++) {
        const speciesParticles = particles.filter(p => p.species === i);
        if (speciesParticles.length === 0) {
            speciesActivityLevels[i] = 0;
            continue;
        }
        
        // Calculate average activity for this species
        let totalActivity = 0;
        for (const particle of speciesParticles) {
            // For collision mode: use collision force
            const collisionActivity = particle.collisionForce || 0;
            
            // For looping mode: use velocity
            const velocity = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
            const velocityActivity = Math.min(1.0, velocity / 3.0); // Normalize to max velocity
            
            // Use the higher of the two
            totalActivity += Math.max(collisionActivity, velocityActivity);
        }
        
        // Smooth the activity level
        const targetLevel = totalActivity / speciesParticles.length;
        speciesActivityLevels[i] = speciesActivityLevels[i] * 0.9 + targetLevel * 0.1;
    }
    
    // Update UI visualization
    updateVelocityVisualization();
}

// Update velocity visualization bars (for looping mode only)
function updateVelocityVisualization() {
    const currentSpeciesCount = (typeof speciesCount !== 'undefined') ? speciesCount : 2;
    
    for (let i = 0; i < currentSpeciesCount; i++) {
        const velocityBar = document.getElementById(`velocityBar${i}`);
        if (velocityBar) {
            const level = Math.min(100, speciesActivityLevels[i] * 100);
            velocityBar.style.width = `${level}%`;
        }
    }
}

// Show collision pulse for collision mode visualization
function showCollisionPulse(speciesIndex, force, triggerSpecies) {
    const container = document.getElementById(`collisionPulseContainer${speciesIndex}`);
    if (!container) return;
    
    // Create pulse element
    const pulse = document.createElement('div');
    const intensity = Math.min(1.0, force);
    const opacity = 0.3 + (intensity * 0.7);
    
    pulse.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: ${intensity * 100}%;
        height: 100%;
        background: linear-gradient(to right, 
            rgba(255, 68, 68, ${opacity}), 
            rgba(255, 193, 7, ${opacity * 0.5}), 
            transparent);
        border-radius: 3px;
        animation: collisionPulse 0.3s ease-out forwards;
    `;
    
    // Add CSS animation if not already defined
    if (!document.getElementById('collisionPulseStyles')) {
        const style = document.createElement('style');
        style.id = 'collisionPulseStyles';
        style.textContent = `
            @keyframes collisionPulse {
                0% { transform: scaleX(0); opacity: 0.8; }
                50% { transform: scaleX(1); opacity: 1; }
                100% { transform: scaleX(0.1); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    }
    
    container.appendChild(pulse);
    
    // Remove pulse after animation
    setTimeout(() => {
        if (pulse.parentNode) {
            pulse.remove();
        }
    }, 300);
}

// Create looping controls (simplified version for new UI)
function createLoopingControls(container, speciesIndex) {
    // Loop direction controls
    const directionRow = document.createElement('div');
    directionRow.className = 'audio-controls-row';
    directionRow.style.marginBottom = '8px';
    
    const directionLabel = document.createElement('span');
    directionLabel.textContent = 'Direction:';
    directionLabel.style.minWidth = '60px';
    directionLabel.style.fontSize = '12px';
    directionLabel.style.color = '#ccc';
    
    const loopControls = document.createElement('div');
    loopControls.className = 'loop-controls';
    loopControls.style.flex = '1';
    
    const directions = [
        { mode: 'forward', icon: '▶', title: 'Forward' },
        { mode: 'reverse', icon: '◀', title: 'Reverse' },
        { mode: 'alternate', icon: '⇄', title: 'Alternating' }
    ];
    
    directions.forEach(dir => {
        const btn = document.createElement('button');
        btn.className = 'loop-button';
        btn.textContent = dir.icon;
        btn.title = dir.title;
        if (dir.mode === 'forward') btn.classList.add('active');
        btn.addEventListener('click', () => {
            updateEngineParameter(speciesIndex, 'loopDirection', dir.mode);
            loopControls.querySelectorAll('.loop-button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        });
        loopControls.appendChild(btn);
    });
    
    directionRow.appendChild(directionLabel);
    directionRow.appendChild(loopControls);
    
    // Crossfade amount
    const crossfadeRow = document.createElement('div');
    crossfadeRow.className = 'audio-controls-row';
    
    const crossfadeLabel = document.createElement('span');
    crossfadeLabel.textContent = 'Smoothness:';
    crossfadeLabel.style.minWidth = '60px';
    crossfadeLabel.style.fontSize = '12px';
    crossfadeLabel.style.color = '#ccc';
    
    const crossfadeSlider = document.createElement('input');
    crossfadeSlider.type = 'range';
    crossfadeSlider.className = 'slider';
    crossfadeSlider.min = '0.0';
    crossfadeSlider.max = '1.0';
    crossfadeSlider.step = '0.05';
    crossfadeSlider.value = '0.5';
    crossfadeSlider.style.flex = '1';
    crossfadeSlider.addEventListener('input', (e) => {
        updateEngineParameter(speciesIndex, 'crossfadeAmount', parseFloat(e.target.value));
        document.getElementById(`crossfade${speciesIndex}-value`).textContent = `${Math.round(parseFloat(e.target.value) * 100)}%`;
    });
    
    const crossfadeValue = document.createElement('span');
    crossfadeValue.className = 'value-display';
    crossfadeValue.id = `crossfade${speciesIndex}-value`;
    crossfadeValue.textContent = '50%';
    
    crossfadeRow.appendChild(crossfadeLabel);
    crossfadeRow.appendChild(crossfadeSlider);
    crossfadeRow.appendChild(crossfadeValue);
    
    container.appendChild(directionRow);
    container.appendChild(crossfadeRow);
}

// Update collision matrix
function updateCollisionMatrix(speciesIndex, triggerSpecies, enabled) {
    if (!speciesAudioSynths[speciesIndex] || !speciesAudioSynths[speciesIndex].collisionEngine) return;
    
    const engine = speciesAudioSynths[speciesIndex].collisionEngine;
    engine.collisionSpeciesMatrix[triggerSpecies] = enabled;
    
    console.log(`🎵 Species ${String.fromCharCode(65 + speciesIndex)} collision trigger from ${String.fromCharCode(65 + triggerSpecies)}: ${enabled}`);
}

// Update audio UI indicators - defined globally
function updateAudioUI() {
    const currentSpeciesCount = (typeof speciesCount !== 'undefined') ? speciesCount : 2;
    for (let i = 0; i < currentSpeciesCount; i++) {
        if (!speciesAudioSynths[i]) continue;
        
        const synth = speciesAudioSynths[i];
        const grainCount = synth.activeGrains;
        
        // Update grain count
        const grainCountElement = document.getElementById(`grainCount${i}`);
        if (grainCountElement) {
            grainCountElement.textContent = `${grainCount}/${synth.maxGrains}`;
        }
        
        // Update grain activity indicators
        const grainActivity = document.getElementById(`grainActivity${i}`);
        if (grainActivity) {
            const indicators = grainActivity.children;
            for (let j = 0; j < indicators.length; j++) {
                indicators[j].classList.toggle('active', j < Math.ceil(grainCount / 5));
            }
        }
        
        // Update audio level meter
        const meterFill = document.getElementById(`meterFill${i}`);
        if (meterFill) {
            const level = Math.min(100, (grainCount / synth.maxGrains) * 100);
            meterFill.style.width = `${level}%`;
        }
        
        // Update gain reduction meter
        const gainReductionFill = document.getElementById(`gainReduction${i}`);
        const gainReductionValue = document.getElementById(`gainReduction${i}-value`);
        if (gainReductionFill && gainReductionValue && synth.currentEngine) {
            const gainReduction = synth.currentEngine.gainReduction || 0;
            const reductionPercent = Math.min(100, gainReduction * 100);
            gainReductionFill.style.width = `${reductionPercent}%`;
            gainReductionValue.textContent = `${(gainReduction * -20).toFixed(1)}dB`; // Convert to dB
        }
    }
}
        
        // ===== PHYSICS CORE =====
        // Particle simulation, spatial optimization, and trail system

// ===== SPATIAL GRID SYSTEM =====
// Spatial Grid Class for O(N) force calculation optimization
class SpatialGrid {
    constructor(canvasWidth, canvasHeight, cellSize) {
        this.canvasWidth = canvasWidth;
        this.canvasHeight = canvasHeight;
        this.cellSize = cellSize;
        
        // Calculate grid dimensions
        this.gridWidth = Math.ceil(canvasWidth / cellSize);
        this.gridHeight = Math.ceil(canvasHeight / cellSize);
        
        // Create 2D grid array - each cell contains array of particles
        this.grid = [];
        for (let i = 0; i < this.gridWidth * this.gridHeight; i++) {
            this.grid[i] = [];
        }
        
        console.log(`Spatial Grid: ${this.gridWidth}x${this.gridHeight} cells, cell size: ${cellSize}`);
    }
    
    // Convert world coordinates to grid coordinates
    worldToGrid(x, y) {
        // Handle toroidal wrapping
        x = ((x % this.canvasWidth) + this.canvasWidth) % this.canvasWidth;
        y = ((y % this.canvasHeight) + this.canvasHeight) % this.canvasHeight;
        
        const gridX = Math.floor(x / this.cellSize);
        const gridY = Math.floor(y / this.cellSize);
        
        return {
            x: Math.max(0, Math.min(this.gridWidth - 1, gridX)),
            y: Math.max(0, Math.min(this.gridHeight - 1, gridY))
        };
    }
    
    // Convert grid coordinates to linear index
    gridToIndex(gridX, gridY) {
        return gridY * this.gridWidth + gridX;
    }
    
    // Clear all grid cells
    clear() {
        for (let i = 0; i < this.grid.length; i++) {
            this.grid[i].length = 0; // Fast array clear
        }
    }
    
    // Add particle to appropriate grid cell
    insertParticle(particle) {
        const gridPos = this.worldToGrid(particle.x, particle.y);
        const index = this.gridToIndex(gridPos.x, gridPos.y);
        this.grid[index].push(particle);
    }
    
    // Get all particles in neighboring cells (including current cell)
    // Returns particles that could potentially interact with a particle at (x, y)
    getNearbyParticles(x, y) {
        const centerGrid = this.worldToGrid(x, y);
        const nearbyParticles = [];
        
        // Check 3x3 neighborhood (including center cell)
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                let gridX = centerGrid.x + dx;
                let gridY = centerGrid.y + dy;
                
                // Handle toroidal wrapping for grid coordinates
                gridX = ((gridX % this.gridWidth) + this.gridWidth) % this.gridWidth;
                gridY = ((gridY % this.gridHeight) + this.gridHeight) % this.gridHeight;
                
                const index = this.gridToIndex(gridX, gridY);
                
                // Add all particles from this cell
                const cell = this.grid[index];
                for (let i = 0; i < cell.length; i++) {
                    nearbyParticles.push(cell[i]);
                }
            }
        }
        
        return nearbyParticles;
    }
    
    // Update grid cell size (when force radius changes)
    updateCellSize(newCellSize) {
        this.cellSize = newCellSize;
        this.gridWidth = Math.ceil(this.canvasWidth / newCellSize);
        this.gridHeight = Math.ceil(this.canvasHeight / newCellSize);
        
        // Recreate grid with new dimensions
        const newSize = this.gridWidth * this.gridHeight;
        if (this.grid.length !== newSize) {
            this.grid = [];
            for (let i = 0; i < newSize; i++) {
                this.grid[i] = [];
            }
            console.log(`Spatial Grid resized: ${this.gridWidth}x${this.gridHeight} cells`);
        }
    }
}


// ===== PARTICLE SYSTEM =====
// Particle class with motion blur trails
class Particle {
    constructor(species) {
        this.species = species;
        this.x = Math.random() * canvasWidth;
        this.y = Math.random() * canvasHeight;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2;
        this.updateSize();
        this.visualSize = this.size; // Initialize visual size
        
        // Set color based on species
        this.color = [...speciesColors[species]];
        
        // Audio fade state for smooth threshold transitions
        this.audioFadeState = 0.0; // 0.0 = silent, 1.0 = full volume
        this.wasAboveThreshold = false; // Track previous threshold state
        
        // Simple age tracking for particle sorting (temporal priority)
        this.age = 0;
        
        // Track previous position for trail particle spawning
        this.prevX = this.x;
        this.prevY = this.y;
        
        // Collision tracking for audio
        this.collisionEvents = []; // Array of recent collision events
        this.lastCollisionTime = 0;
        this.collisionForce = 0; // Current collision force magnitude
    }

    updateSize() {
        this.size = particleSizes[this.species];
        
        // Calculate visual size (enhanced when size = 10)
        this.visualSize = this.size;
        if (this.size >= 10) {
            this.visualSize = this.size * 1.5; // 50% larger visual representation
        }
    }

    update() {
        // Store old position for movement detection
        const oldX = this.x;
        const oldY = this.y;
        
        // Calculate forces from nearby particles only (using spatial grid)
        let fx = 0;
        let fy = 0;

        // Get nearby particles from spatial grid instead of all particles
        const nearbyParticles = spatialGrid.getNearbyParticles(this.x, this.y);

        for (let i = 0; i < nearbyParticles.length; i++) {
            const other = nearbyParticles[i];
            if (other === this) continue;

            // Calculate distance with toroidal wrapping (if enabled)
            let dx = other.x - this.x;
            let dy = other.y - this.y;
            
            // Handle toroidal space - find shortest distance across wrapping edges
            if (TOROIDAL_SPACE) {
                if (Math.abs(dx) > canvasWidth / 2) {
                    dx = dx > 0 ? dx - canvasWidth : dx + canvasWidth;
                }
                if (Math.abs(dy) > canvasHeight / 2) {
                    dy = dy > 0 ? dy - canvasHeight : dy + canvasHeight;
                }
            }
            
            let distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate collision distance using visual sizes to prevent visual overlap
            let collisionDistance = this.visualSize + other.visualSize;
            
            // Handle collision - push particles apart if they're overlapping
            if (distance < collisionDistance && distance > 0) {
                let overlap = collisionDistance - distance;
                let separationForce = overlap * 1.0; // Increased separation strength
                
                // Normalize direction vector
                let normalizedDx = dx / distance;
                let normalizedDy = dy / distance;
                
                // Apply separation force (push away from each other)
                fx -= separationForce * normalizedDx;
                fy -= separationForce * normalizedDy;
                
                // Calculate collision force magnitude for audio
                const velocityMagnitude = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const otherVelocityMagnitude = Math.sqrt(other.vx * other.vx + other.vy * other.vy);
                const totalVelocity = velocityMagnitude + otherVelocityMagnitude;
                const collisionForce = (separationForce + totalVelocity) * 0.5; // Combined force measure
                
                // Record collision event for audio processing
                const currentTime = performance.now();
                const collisionEvent = {
                    time: currentTime,
                    force: collisionForce,
                    otherSpecies: other.species,
                    distance: distance,
                    relativeVelocity: totalVelocity
                };
                
                // Add collision event to both particles
                this.collisionEvents.push(collisionEvent);
                other.collisionEvents.push({
                    ...collisionEvent,
                    otherSpecies: this.species
                });
                
                // Update current collision force
                this.collisionForce = Math.max(this.collisionForce, collisionForce);
                other.collisionForce = Math.max(other.collisionForce, collisionForce);
                this.lastCollisionTime = currentTime;
                other.lastCollisionTime = currentTime;
                
                // Debug logging (very rarely to avoid spam)
                if (Math.random() < 0.001) {
                    console.log(`💥 Collision detected - Species ${this.species} <-> ${other.species}, Force: ${collisionForce.toFixed(3)}`);
                }
                
                // Apply mutual velocity damping on collision (both particles affected)
                this.vx *= 0.7;
                this.vy *= 0.7;
                other.vx *= 0.7;
                other.vy *= 0.7;
                
                // Add a small repulsion force to ensure separation
                const repulsionForce = 0.2;
                fx -= repulsionForce * normalizedDx;
                fy -= repulsionForce * normalizedDy;
            }

            // Skip normal force calculation if outside force range
            if (distance > MAX_FORCE_DISTANCE || distance < 1) continue;

            // Get force strength from relationship matrix
            let forceStrength = RELATIONSHIP_MATRIX[this.species][other.species];

            // Calculate force falloff (smooth falloff to 0)
            let falloff = 1 - (distance / MAX_FORCE_DISTANCE);
            falloff = falloff * falloff; // Quadratic falloff for smoother effect

            // Calculate force components
            let force = forceStrength * falloff;
            let normalizedDx = dx / distance;
            let normalizedDy = dy / distance;

            fx += force * normalizedDx;
            fy += force * normalizedDy;
        }

        // Apply gravity force if active
        if (gravityPoint.active && GRAVITY_STRENGTH > 0) {
            const gravityDx = gravityPoint.x - this.x;
            const gravityDy = gravityPoint.y - this.y;
            const gravityDistance = Math.sqrt(gravityDx * gravityDx + gravityDy * gravityDy);
            
            if (gravityDistance > 1) { // Avoid division by zero
                // Calculate gravity force (inverse square law with minimum distance)
                const minDistance = 10; // Minimum distance to prevent extreme forces (reduced for better close-range control)
                const effectiveDistance = Math.max(gravityDistance, minDistance);
                const gravityForce = GRAVITY_STRENGTH / (effectiveDistance * effectiveDistance) * 5000; // Increased scale factor for stronger response
                
                // Normalize and apply gravity
                const normalizedGravityDx = gravityDx / gravityDistance;
                const normalizedGravityDy = gravityDy / gravityDistance;
                
                fx += gravityForce * normalizedGravityDx;
                fy += gravityForce * normalizedGravityDy;
            }
        }

        // Apply forces to velocity (scaled by simulation speed)
        this.vx += fx * 0.1 * SIMULATION_SPEED;
        this.vy += fy * 0.1 * SIMULATION_SPEED;

        // Apply friction
        this.vx *= FRICTION;
        this.vy *= FRICTION;

        // Limit maximum speed
        let speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        if (speed > MAX_SPEED) {
            this.vx = (this.vx / speed) * MAX_SPEED;
            this.vy = (this.vy / speed) * MAX_SPEED;
        }

        // Update position (scaled by simulation speed)
        this.x += this.vx * SIMULATION_SPEED;
        this.y += this.vy * SIMULATION_SPEED;

        // Handle boundary conditions based on toroidal space setting
        if (TOROIDAL_SPACE) {
            // Implement toroidal wrapping
            if (this.x < 0) this.x += canvasWidth;
            if (this.x > canvasWidth) this.x -= canvasWidth;
            if (this.y < 0) this.y += canvasHeight;
            if (this.y > canvasHeight) this.y -= canvasHeight;
        } else {
            // Implement bouncing off walls
            if (this.x < this.size) {
                this.x = this.size;
                this.vx = Math.abs(this.vx) * BOUNCE_DAMPING; // Bounce with configurable damping
            }
            if (this.x > canvasWidth - this.size) {
                this.x = canvasWidth - this.size;
                this.vx = -Math.abs(this.vx) * BOUNCE_DAMPING;
            }
            if (this.y < this.size) {
                this.y = this.size;
                this.vy = Math.abs(this.vy) * BOUNCE_DAMPING;
            }
            if (this.y > canvasHeight - this.size) {
                this.y = canvasHeight - this.size;
                this.vy = -Math.abs(this.vy) * BOUNCE_DAMPING;
            }
        }
        
        // Spawn trail particle if moved significantly
        const dx = this.x - this.prevX;
        const dy = this.y - this.prevY;
        const movement = Math.sqrt(dx * dx + dy * dy);
        
        if (movement > 2.0) { // Spawn trail when particle moves > 2 pixels
            // Only spawn trail particles if species has trails enabled
            const speciesTrailLength = speciesTrailLengths[this.species] !== undefined ? speciesTrailLengths[this.species] : 0.75;
            
            if (speciesTrailLength > 0.01) { // Use 0.01 threshold to handle floating point precision
                // Create trail particle at previous position
                trailParticles.push(new TrailParticle(
                    this.prevX, 
                    this.prevY, 
                    this.species, 
                    this.color, 
                    this.visualSize
                ));
            }
            
            // Update previous position
            this.prevX = this.x;
            this.prevY = this.y;
        }
        
        // Simple age increment for temporal sorting
        this.age++;
        
        // Update collision tracking for audio
        const currentTime = performance.now();
        
        // Remove old collision events (older than 100ms)
        this.collisionEvents = this.collisionEvents.filter(event => 
            currentTime - event.time < 100
        );
        
        // Decay collision force over time
        const timeSinceCollision = currentTime - this.lastCollisionTime;
        if (timeSinceCollision > 50) { // Start decaying after 50ms
            const decayFactor = Math.exp(-(timeSinceCollision - 50) / 100); // Exponential decay
            this.collisionForce *= decayFactor;
            if (this.collisionForce < 0.01) {
                this.collisionForce = 0;
            }
        }
    }
}

// ===== TRAIL PARTICLE SYSTEM =====
// TrailParticle class - lightweight, visual-only particles for trail effects
class TrailParticle {
    constructor(x, y, species, color, size) {
        // Position (fixed - trail particles don't move)
        this.x = x;
        this.y = y;
        
        // Visual properties inherited from parent particle
        this.species = species;
        this.color = [...color]; // Copy color array
        this.size = size;
        
        // Trail-specific properties
        this.creationTime = performance.now();
        this.age = 0;
        this.alpha = 1.0; // Start fully visible
    }
    
    // Update trail particle age and alpha based on species trail settings
    updateTrailParticle() {
        const currentTime = performance.now();
        this.age = currentTime - this.creationTime;
        
        // Get species trail length setting (0.0 to 0.99)
        const speciesTrailLength = speciesTrailLengths[this.species] !== undefined ? speciesTrailLengths[this.species] : 0.75;
        
        // If trail length is 0 or very close to 0, remove immediately (no trails)
        if (speciesTrailLength <= 0.01) {
            this.alpha = 0;
            return true;
        }
        
        // Calculate fade based on age and species setting
        const maxAge = 3000; // 3 seconds maximum trail life
        const ageRatio = Math.min(this.age / maxAge, 1.0);
        
        // Convert trail length to much more aggressive fade curve
        // Scale the 0.0-0.99 range to behave like the old 0.5-0.99 range
        const scaledTrailLength = 0.5 + (speciesTrailLength * 0.49); // Maps 0.0->0.5, 0.99->0.99
        const fadeRate = 1.0 - scaledTrailLength;
        
        // Calculate alpha: trails fade from 1.0 to 0.0 with more aggressive scaling
        this.alpha = Math.max(0, 1.0 - (ageRatio * fadeRate * 4.0)); // Increased multiplier for faster fade
        
        // Return true if trail particle should be removed
        return this.alpha <= 0;
    }
}

// Trail particles array - separate from main particles
let trailParticles = [];

// Initialize particles
function initParticles() {
    particles = [];
    
    // Create particles for each active species
    for (let species = 0; species < speciesCount; species++) {
        for (let i = 0; i < particleCounts[species]; i++) {
            particles.push(new Particle(species));
        }
    }
    
    updateParticleCountDisplay();
}

// Initialize spatial grid system
function initSpatialGrid() {
    // Use force radius as cell size for optimal performance
    spatialGrid = new SpatialGrid(canvasWidth, canvasHeight, MAX_FORCE_DISTANCE);
    console.log('🚀 Spatial partitioning enabled! Force calculations optimized from O(N²) to O(N)');
}

// ===== TRAIL PARTICLE TRAIL SYSTEM =====
// Initialize trail particle system
function initTrailSystem() {
    // Set up main 2D canvas context
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Clear main canvas to black
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    
    // Initialize empty trail particles array
    trailParticles = [];
    
    // Remove any existing off-screen canvases
    window.speciesTrailCanvases = null;
    window.speciesTrailContexts = null;
    
    console.log('🎨 Trail particle system initialized with individual species control!');
}



// ===== PARTICLE MANAGEMENT =====
// Adjust particle counts dynamically
function adjustParticleCounts() {
    // Count current particles by species
    let currentCounts = new Array(maxSpecies).fill(0);
    for (let particle of particles) {
        currentCounts[particle.species]++;
    }

    // Adjust each active species
    for (let species = 0; species < speciesCount; species++) {
        let currentCount = currentCounts[species];
        let targetCount = particleCounts[species];

        if (currentCount < targetCount) {
            // Add particles
            for (let i = currentCount; i < targetCount; i++) {
                particles.push(new Particle(species));
            }
        } else if (currentCount > targetCount) {
            // Remove particles
            let toRemove = currentCount - targetCount;
            for (let i = particles.length - 1; i >= 0 && toRemove > 0; i--) {
                if (particles[i].species === species) {
                    particles.splice(i, 1);
                    toRemove--;
                }
            }
        }
    }

    // Remove particles from inactive species
    for (let i = particles.length - 1; i >= 0; i--) {
        if (particles[i].species >= speciesCount) {
            particles.splice(i, 1);
        }
    }

    updateParticleCountDisplay();
}

// Update particle sizes
function updateParticleSizes() {
    for (let particle of particles) {
        particle.updateSize();
    }
}

// Update particle positions with audio integration
function updateParticles() {
    if (isPaused) return;
    
    // Rebuild spatial grid each frame for optimal performance
    spatialGrid.clear();
    
    // Insert all particles into spatial grid
    for (let i = 0; i < particles.length; i++) {
        spatialGrid.insertParticle(particles[i]);
    }
    
    // Update particles using spatial optimization
    for (let particle of particles) {
        particle.update();
    }
    
    // Update trail particles and remove expired ones
    updateTrailParticles();
    
    // Update audio system with new particle positions
    updateAudioSystem();
}

// Update trail particles and remove expired ones
function updateTrailParticles() {
    for (let i = trailParticles.length - 1; i >= 0; i--) {
        const trailParticle = trailParticles[i];
        const shouldRemove = trailParticle.updateTrailParticle();
        
        if (shouldRemove) {
            trailParticles.splice(i, 1);
        }
    }
}

// Remove all trail particles for a specific species (called when trail length set to 0)
function removeTrailParticlesForSpecies(speciesIndex) {
    for (let i = trailParticles.length - 1; i >= 0; i--) {
        if (trailParticles[i].species === speciesIndex) {
            trailParticles.splice(i, 1);
        }
    }
    console.log(`🧹 Cleared all trail particles for Species ${String.fromCharCode(65 + speciesIndex)}`);
}

// ===== RENDERING =====
// Render trail particles and species particles with temporal priority
function render() {
    // Get main canvas context
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Disable anti-aliasing for crisp effect
    ctx.imageSmoothingEnabled = false;
    
    // Step 1: Apply canvas fade only if any species have trails enabled
    let anyTrailsEnabled = false;
    for (let i = 0; i < speciesCount; i++) {
        const trailLength = speciesTrailLengths[i] !== undefined ? speciesTrailLengths[i] : 0.75;
        if (trailLength > 0.01) {
            anyTrailsEnabled = true;
            break;
        }
    }
    
    if (anyTrailsEnabled) {
        // Apply subtle fade for smoothing only when trails are active
        ctx.fillStyle = 'rgba(0, 0, 0, 0.02)';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    } else {
        // Complete clear when no trails are enabled
        ctx.fillStyle = 'rgba(0, 0, 0, 1.0)';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    }
    
    // Step 2: Render trail particles first (oldest to newest)
    ctx.globalCompositeOperation = 'source-over';
    
    // Sort trail particles by creation time (oldest first)
    const sortedTrailParticles = [...trailParticles].sort((a, b) => a.creationTime - b.creationTime);
    
    for (let trailParticle of sortedTrailParticles) {
        // Skip invisible trail particles
        if (trailParticle.alpha <= 0) continue;
        
        // Set alpha for this trail particle
        ctx.globalAlpha = trailParticle.alpha;
        
        // Get particle color
        const r = Math.round(trailParticle.color[0] * 255);
        const g = Math.round(trailParticle.color[1] * 255);
        const b = Math.round(trailParticle.color[2] * 255);
        
        // Render trail particle
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.beginPath();
        ctx.arc(trailParticle.x, trailParticle.y, trailParticle.size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Step 3: Render current species particles at full opacity (newest last)
    ctx.globalAlpha = 1.0;
    
    // Sort species particles by age (oldest first, newest last)
    const sortedParticles = [...particles].sort((a, b) => a.age - b.age);
    
    for (let particle of sortedParticles) {
        // Get particle color
        const r = Math.round(particle.color[0] * 255);
        const g = Math.round(particle.color[1] * 255);
        const b = Math.round(particle.color[2] * 255);
        
        // Render species particle at full opacity
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.visualSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Add stroke for definition
        ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.lineWidth = 1;
        ctx.stroke();
    }
    
    // Reset alpha
    ctx.globalAlpha = 1.0;
}


// ===== ANIMATION LOOP =====
// Animation loop with FPS tracking
let lastFrameTime = performance.now();
let frameCount = 0;
let fpsUpdateTime = performance.now();
let frameTimeHistory = [];

function animate() {
    const currentTime = performance.now();
    const frameTime = currentTime - lastFrameTime;
    
    updateParticles();
    render();
    
    // Track frame time for performance metrics
    frameTimeHistory.push(frameTime);
    if (frameTimeHistory.length > 60) {
        frameTimeHistory.shift(); // Keep only last 60 frames
    }
    
    // FPS and performance tracking
    frameCount++;
    if (currentTime - fpsUpdateTime >= 500) { // Update every 500ms
        const fps = Math.round((frameCount * 1000) / (currentTime - fpsUpdateTime));
        const avgFrameTime = frameTimeHistory.reduce((a, b) => a + b, 0) / frameTimeHistory.length;
        
        // Update performance displays
        const fpsElement = document.getElementById('fps-display');
        if (fpsElement) fpsElement.textContent = fps;
        
        const frameTimeElement = document.getElementById('frame-time');
        if (frameTimeElement) frameTimeElement.textContent = `${avgFrameTime.toFixed(1)}ms`;
        
        const canvasSizeElement = document.getElementById('canvas-size');
        if (canvasSizeElement) canvasSizeElement.textContent = `${canvasWidth}×${canvasHeight}`;
        
        const totalParticlesElement = document.getElementById('total-particles');
        if (totalParticlesElement) totalParticlesElement.textContent = particles.length;
        
        const trailParticlesElement = document.getElementById('trail-particles');
        if (trailParticlesElement) trailParticlesElement.textContent = trailParticles.length;
        
        // Update grid info
        if (spatialGrid) {
            const gridInfo = `${spatialGrid.gridWidth}×${spatialGrid.gridHeight}`;
            const gridElement = document.getElementById('grid-info');
            if (gridElement) gridElement.textContent = gridInfo;
        }
        
        // Update audio grain count
        let totalGrains = 0;
        if (typeof speciesAudioSynths !== 'undefined' && speciesAudioSynths.length > 0) {
            for (let synth of speciesAudioSynths) {
                if (synth && synth.grains) {
                    totalGrains += synth.grains.length;
                }
            }
        }
        const totalGrainsElement = document.getElementById('total-grains');
        if (totalGrainsElement) totalGrainsElement.textContent = totalGrains;
        
        // Update audio latency
        const audioLatencyElement = document.getElementById('audio-latency');
        if (audioLatencyElement && typeof audioContext !== 'undefined' && audioContext) {
            const latency = (audioContext.baseLatency * 1000).toFixed(1) + 'ms';
            audioLatencyElement.textContent = latency;
        }
        
        // Update species tab info
        if (typeof updateSpeciesTabInfo === 'function') {
            updateSpeciesTabInfo();
        }
        
        // Update species activity levels for audio visualization
        if (typeof updateSpeciesActivityLevels === 'function') {
            updateSpeciesActivityLevels(particles);
        }
        
        frameCount = 0;
        fpsUpdateTime = currentTime;
    }
    
    lastFrameTime = currentTime;
    requestAnimationFrame(animate);
}

// ===== CONTROL FUNCTIONS =====
// Control functions
function resetSimulation() {
    // Clear main canvas
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    
    // Clear trail particles
    trailParticles = [];
    
    // Reset particles
    initParticles();
    isPaused = false;
}

function togglePause() {
    isPaused = !isPaused;
}

function updateParticleCountDisplay() {
    // This function is no longer needed but kept for compatibility
}

// Setup canvas mouse interaction for gravity
function setupCanvasInteraction() {
    const canvas = document.getElementById('canvas');
    
    canvas.addEventListener('mousedown', (e) => {
        if (GRAVITY_STRENGTH > 0) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            gravityPoint.x = x;
            gravityPoint.y = y;
            gravityPoint.active = true;
            isMouseDown = true;
            
            console.log(`🌍 Gravity point activated at (${Math.round(x)}, ${Math.round(y)})`);
        }
        e.preventDefault();
    });
    
    canvas.addEventListener('mousemove', (e) => {
        if (isMouseDown && GRAVITY_STRENGTH > 0) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            gravityPoint.x = x;
            gravityPoint.y = y;
        }
        e.preventDefault();
    });
    
    canvas.addEventListener('mouseup', (e) => {
        if (isMouseDown) {
            gravityPoint.active = false;
            isMouseDown = false;
            console.log('🌍 Gravity point deactivated');
        }
        e.preventDefault();
    });
    
    canvas.addEventListener('mouseleave', (e) => {
        if (isMouseDown) {
            gravityPoint.active = false;
            isMouseDown = false;
            console.log('🌍 Gravity point deactivated (mouse left canvas)');
        }
    });
    
    // Update cursor based on gravity setting
    function updateCanvasCursor() {
        if (GRAVITY_STRENGTH > 0) {
            canvas.style.cursor = 'crosshair';
        } else {
            canvas.style.cursor = 'default';
        }
    }
    
    // Update cursor initially and when gravity changes
    updateCanvasCursor();
    
    // Update cursor when gravity strength changes
    document.getElementById('gravityStrength').addEventListener('input', updateCanvasCursor);
}
        
        // ===== MAIN APPLICATION =====
        // ===== CANVAS SETUP & RENDERING =====
        // 2D Canvas setup for motion blur particle system
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        if (!ctx) {
            alert('Canvas 2D not supported!');
        }

        // Canvas sizing system - using manual controls only
        let canvasWidth = 1200;
        let canvasHeight = 800;

        // Initialize canvas to default size
        function initCanvas() {
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            console.log(`🖥️ Canvas initialized to ${canvasWidth}×${canvasHeight}`);
        }

        // Particle data
        let particles = [];
        let isPaused = false;
        let spatialGrid; // Spatial partitioning system

        

        // Species management
        let speciesCount = 2;
        let maxSpecies = 8;
        let speciesColors = [
            [1.0, 0.27, 0.27], // Red
            [0.27, 0.27, 1.0], // Blue
            [0.27, 1.0, 0.27], // Green
            [1.0, 1.0, 0.27],  // Yellow
            [1.0, 0.27, 1.0],  // Magenta
            [0.27, 1.0, 1.0],  // Cyan
            [1.0, 0.5, 0.0],   // Orange
            [0.5, 0.0, 1.0]    // Purple
        ];

        // Configurable parameters
        let particleSizes = [4, 4, 4, 4, 4, 4, 4, 4];
        let particleCounts = [50, 50, 50, 50, 50, 50, 50, 50];
        let speciesTrailLengths = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]; // Individual trail fade per species (0.0-0.99 range)
        let FRICTION = 0.95;
        let MAX_FORCE_DISTANCE = 60;
        let SIMULATION_SPEED = 1.0;
        let TOROIDAL_SPACE = true; // Toggle for edge wrapping
        let GRAVITY_STRENGTH = 0.0; // Gravity pull strength
        let BOUNCE_DAMPING = 0.8; // Wall bounce damping factor (0.5-1.5)
        
        // Gravity system
        let gravityPoint = { x: 0, y: 0, active: false };
        let isMouseDown = false;

        // Species constants
        const SPECIES = {
            A: 0, // Red
            B: 1  // Blue
        };

        // Relationship matrix (force strengths) - now dynamic and expandable
        let RELATIONSHIP_MATRIX = [
            [-0.3, 0.8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],   // A relationships
            [-0.5, -0.3, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  // B relationships
            [0.0, 0.0, -0.1, 0.0, 0.0, 0.0, 0.0, 0.0],   // C relationships
            [0.0, 0.0, 0.0, -0.1, 0.0, 0.0, 0.0, 0.0],   // D relationships
            [0.0, 0.0, 0.0, 0.0, -0.1, 0.0, 0.0, 0.0],   // E relationships
            [0.0, 0.0, 0.0, 0.0, 0.0, -0.1, 0.0, 0.0],   // F relationships
            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.1, 0.0],   // G relationships
            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.1]    // H relationships
        ];

        // Force parameters
        const MAX_SPEED = 3;


        // ===== UI GENERATION =====

        // RGB to Hex conversion
        function rgbToHex(rgbArray) {
            const r = Math.round(rgbArray[0] * 255);
            const g = Math.round(rgbArray[1] * 255);
            const b = Math.round(rgbArray[2] * 255);
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        // ===== CONTROL SYSTEM & FORCE MATRIX =====
        // Slider event handlers
        function setupSliders() {
            // Species count slider
            document.getElementById('speciesCount').addEventListener('input', (e) => {
                speciesCount = parseInt(e.target.value);
                document.getElementById('speciesCount-value').textContent = speciesCount;
                
                // Regenerate UI and adjust particles
                createForceMatrix();
                setupDraggableNumbers();
                adjustParticleCounts();
                
                // Regenerate species tabs
                createSpeciesTabs();
                
                // Ensure current tab is valid
                if (currentSpeciesTab >= speciesCount) {
                    currentSpeciesTab = 0;
                    selectedSpeciesForAudio = 0;
                }
                
                // Regenerate audio controls if audio is initialized
                if (isAudioEnabled && speciesAudioSynths.length > 0) {
                    // Just regenerate the UI, don't recreate synths
                    createSpeciesAudioControls();
                    // Setup draggable numbers for new audio controls
                    setTimeout(() => setupDraggableNumbers(), 0);
                }
            });

            // Physics sliders
            document.getElementById('friction').addEventListener('input', (e) => {
                FRICTION = parseFloat(e.target.value);
                document.getElementById('friction-value').textContent = FRICTION.toFixed(2);
            });

            document.getElementById('forceRadius').addEventListener('input', (e) => {
                MAX_FORCE_DISTANCE = parseInt(e.target.value);
                document.getElementById('forceRadius-value').textContent = MAX_FORCE_DISTANCE;
                
                // Update spatial grid cell size
                if (spatialGrid) {
                    spatialGrid.updateCellSize(MAX_FORCE_DISTANCE);
                }
            });

            document.getElementById('simSpeed').addEventListener('input', (e) => {
                SIMULATION_SPEED = parseFloat(e.target.value);
                document.getElementById('simSpeed-value').textContent = SIMULATION_SPEED.toFixed(1);
            });

            document.getElementById('gravityStrength').addEventListener('input', (e) => {
                GRAVITY_STRENGTH = parseFloat(e.target.value);
                document.getElementById('gravityStrength-value').textContent = GRAVITY_STRENGTH.toFixed(1);
            });

            document.getElementById('bounceDamping').addEventListener('input', (e) => {
                BOUNCE_DAMPING = parseFloat(e.target.value);
                document.getElementById('bounceDamping-value').textContent = BOUNCE_DAMPING.toFixed(1);
            });

            document.getElementById('toroidalSpace').addEventListener('change', (e) => {
                TOROIDAL_SPACE = e.target.checked;
            });

            // Audio sliders
            document.getElementById('masterVolume').addEventListener('input', (e) => {
                setMasterVolume(parseFloat(e.target.value));
            });

            document.getElementById('freqLow').addEventListener('input', (e) => {
                const low = parseInt(e.target.value);
                const high = frequencyRange.high;
                if (low < high) {
                    setFrequencyRange(low, high);
                }
            });

            document.getElementById('freqHigh').addEventListener('input', (e) => {
                const high = parseInt(e.target.value);
                const low = frequencyRange.low;
                if (high > low) {
                    setFrequencyRange(low, high);
                }
            });

            document.getElementById('velocityGainCurve').addEventListener('input', (e) => {
                setGlobalVelocityGainCurve(parseFloat(e.target.value));
            });

            document.getElementById('velocityThreshold').addEventListener('input', (e) => {
                setGlobalVelocityThreshold(parseFloat(e.target.value));
            });

            document.getElementById('masterMute').addEventListener('click', toggleMasterMute);
            
            document.getElementById('audioInit').addEventListener('click', () => {
                initAudioSystem();
            });
            
            // Randomize matrix button
            document.getElementById('randomizeMatrix').addEventListener('click', randomizeForceMatrix);
        }

        function setupDraggableNumbers() {
            const draggableNumbers = document.querySelectorAll('.draggable-number');
            
            draggableNumbers.forEach(element => {
                let isDragging = false;
                let startY = 0;
                let startValue = 0;
                
                element.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startY = e.clientY;
                    startValue = parseFloat(element.textContent);
                    element.classList.add('dragging');
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaY = startY - e.clientY; // Inverted for natural feel
                    let sensitivity = 1;
                    let newValue = startValue;
                    
                    // Determine parameter type and apply appropriate sensitivity
                    if (element.id.includes('count')) {
                        sensitivity = 0.5;
                        newValue = Math.max(1, Math.min(1000, Math.round(startValue + deltaY * sensitivity)));
                        
                        // Update particle count
                        const speciesIndex = parseInt(element.id.split('-')[1]);
                        particleCounts[speciesIndex] = newValue;
                        adjustParticleCounts();
                        
                    } else if (element.id.includes('size')) {
                        sensitivity = 0.1;
                        newValue = Math.max(2, Math.min(20, Math.round((startValue + deltaY * sensitivity) * 10) / 10));
                        
                        // Update particle size
                        const speciesIndex = parseInt(element.id.split('-')[1]);
                        particleSizes[speciesIndex] = newValue;
                        updateParticleSizes();
                        
                    } else if (element.id.includes('trail')) {
                        sensitivity = 0.01;
                        newValue = Math.max(0.0, Math.min(0.99, Math.round((startValue + deltaY * sensitivity) * 100) / 100));
                        
                        // Update trail length
                        const speciesIndex = parseInt(element.id.split('-')[1]);
                        speciesTrailLengths[speciesIndex] = newValue;
                        
                        // If trail length is set to 0 or very close to 0, immediately remove all trail particles for this species
                        if (newValue <= 0.01) {
                            removeTrailParticlesForSpecies(speciesIndex);
                        }
                        
                    } else if (element.id === 'canvas-width') {
                        sensitivity = 5;
                        newValue = Math.max(400, Math.min(1600, Math.round(startValue + deltaY * sensitivity)));
                        
                        // Update canvas width
                        updateCanvasSize(newValue, canvasHeight);
                        
                    } else if (element.id === 'canvas-height') {
                        sensitivity = 3;
                        newValue = Math.max(300, Math.min(1200, Math.round(startValue + deltaY * sensitivity)));
                        
                        // Update canvas height
                        updateCanvasSize(canvasWidth, newValue);
                    }
                    
                    element.textContent = element.id.includes('trail') ? newValue.toFixed(2) : newValue;
                });
                
                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        element.classList.remove('dragging');
                    }
                });
            });
        }

        function createForceMatrix() {
            const matrixGrid = document.getElementById('forceMatrix');
            matrixGrid.innerHTML = '';
            
            // Set grid layout
            matrixGrid.style.gridTemplateColumns = `repeat(${speciesCount + 1}, 1fr)`;
            
            // Add corner cell (empty)
            const cornerCell = document.createElement('div');
            cornerCell.className = 'matrix-header';
            matrixGrid.appendChild(cornerCell);
            
            // Add column headers
            for (let i = 0; i < speciesCount; i++) {
                const header = document.createElement('div');
                header.className = 'matrix-header';
                header.style.color = rgbToHex(speciesColors[i]);
                header.innerHTML = `<span>${String.fromCharCode(65 + i)}</span>`;
                matrixGrid.appendChild(header);
            }
            
            // Add row headers and matrix cells
            for (let fromSpecies = 0; fromSpecies < speciesCount; fromSpecies++) {
                // Row header
                const rowHeader = document.createElement('div');
                rowHeader.className = 'matrix-header';
                rowHeader.style.color = rgbToHex(speciesColors[fromSpecies]);
                rowHeader.textContent = String.fromCharCode(65 + fromSpecies);
                matrixGrid.appendChild(rowHeader);
                
                // Matrix cells for this row
                for (let toSpecies = 0; toSpecies < speciesCount; toSpecies++) {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    cell.dataset.from = fromSpecies;
                    cell.dataset.to = toSpecies;
                    
                    const value = RELATIONSHIP_MATRIX[fromSpecies][toSpecies];
                    cell.textContent = value.toFixed(1);
                    
                    // Color coding based on force value
                    if (value > 0.1) {
                        // Green for attraction (positive values)
                        const intensity = Math.abs(value);
                        cell.style.backgroundColor = `rgb(${Math.round(50 * (1 - intensity))}, ${Math.round(150 + intensity * 105)}, ${Math.round(50 * (1 - intensity))})`;
                    } else if (value < -0.1) {
                        // Red for repulsion (negative values)
                        const intensity = Math.abs(value);
                        cell.style.backgroundColor = `rgb(${Math.round(150 + intensity * 105)}, ${Math.round(50 * (1 - intensity))}, ${Math.round(50 * (1 - intensity))})`;
                    } else {
                        cell.style.backgroundColor = '#666';
                    }
                    
                    // Add drag interaction for force values
                    (function(cellElement, from, to) {
                        let isDragging = false;
                        let startY = 0;
                        let startValue = 0;
                        
                        cellElement.addEventListener('mousedown', (e) => {
                            isDragging = true;
                            startY = e.clientY;
                            startValue = RELATIONSHIP_MATRIX[from][to];
                            cellElement.classList.add('dragging');
                            e.preventDefault();
                        });
                        
                        const handleMouseMove = (e) => {
                            if (!isDragging) return;
                            
                            const deltaY = startY - e.clientY;
                            const sensitivity = 0.01;
                            const newValue = Math.max(-1, Math.min(1, startValue + deltaY * sensitivity));
                            const clampedValue = Math.round(newValue * 10) / 10;
                            
                            cellElement.textContent = clampedValue.toFixed(1);
                            
                            // Update color
                            if (clampedValue > 0.1) {
                                // Green for attraction (positive values)
                                const intensity = Math.abs(clampedValue);
                                cellElement.style.backgroundColor = `rgb(${Math.round(50 * (1 - intensity))}, ${Math.round(150 + intensity * 105)}, ${Math.round(50 * (1 - intensity))})`;
                            } else if (clampedValue < -0.1) {
                                // Red for repulsion (negative values)
                                const intensity = Math.abs(clampedValue);
                                cellElement.style.backgroundColor = `rgb(${Math.round(150 + intensity * 105)}, ${Math.round(50 * (1 - intensity))}, ${Math.round(50 * (1 - intensity))})`;
                            } else {
                                cellElement.style.backgroundColor = '#666';
                            }
                            
                            // Update the relationship matrix
                            RELATIONSHIP_MATRIX[from][to] = clampedValue;
                        };
                        
                        const handleMouseUp = () => {
                            if (isDragging) {
                                isDragging = false;
                                cellElement.classList.remove('dragging');
                            }
                        };
                        
                        document.addEventListener('mousemove', handleMouseMove);
                        document.addEventListener('mouseup', handleMouseUp);
                    })(cell, fromSpecies, toSpecies);
                    
                    matrixGrid.appendChild(cell);
                }
            }
        }

        // Ensure matrix size matches species count
        function ensureMatrixSize() {
            while (RELATIONSHIP_MATRIX.length < maxSpecies) {
                RELATIONSHIP_MATRIX.push(new Array(maxSpecies).fill(-0.1));
            }
            for (let i = 0; i < RELATIONSHIP_MATRIX.length; i++) {
                while (RELATIONSHIP_MATRIX[i].length < maxSpecies) {
                    RELATIONSHIP_MATRIX[i].push(-0.1);
                }
            }
        }

        function randomizeForceMatrix() {
            // Randomize the relationship matrix values
            for (let i = 0; i < speciesCount; i++) {
                for (let j = 0; j < speciesCount; j++) {
                    // Generate random value between -1 and 1, rounded to 1 decimal place
                    RELATIONSHIP_MATRIX[i][j] = Math.round((Math.random() * 2 - 1) * 10) / 10;
                }
            }
            
            // Recreate the matrix UI to reflect new values
            createForceMatrix();
            
            console.log('🎲 Force matrix randomized');
        }

        function updateCanvasSize(newWidth, newHeight) {
            // Store old dimensions for proportional scaling
            const oldWidth = canvasWidth;
            const oldHeight = canvasHeight;
            
            // Update canvas dimensions
            canvasWidth = newWidth;
            canvasHeight = newHeight;
            
            // Update canvas size
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // No species trail canvases to update in single canvas system
            
            // Update WebGL viewport (if WebGL context exists)
            if (typeof gl !== 'undefined' && gl) {
                gl.viewport(0, 0, canvasWidth, canvasHeight);
            }
            
            // Scale particle positions proportionally (preserves audio mappings)
            if (particles.length > 0 && oldWidth > 0 && oldHeight > 0) {
                const scaleX = canvasWidth / oldWidth;
                const scaleY = canvasHeight / oldHeight;
                
                for (let particle of particles) {
                    particle.x *= scaleX;
                    particle.y *= scaleY;
                    
                }
            }
            
            // Update spatial grid for new dimensions
            if (spatialGrid) {
                spatialGrid.canvasWidth = canvasWidth;
                spatialGrid.canvasHeight = canvasHeight;
                spatialGrid.gridWidth = Math.ceil(canvasWidth / spatialGrid.cellSize);
                spatialGrid.gridHeight = Math.ceil(canvasHeight / spatialGrid.cellSize);
                
                // Recreate grid with new dimensions
                const newSize = spatialGrid.gridWidth * spatialGrid.gridHeight;
                spatialGrid.grid = [];
                for (let i = 0; i < newSize; i++) {
                    spatialGrid.grid[i] = [];
                }
            }
            
            // Update gravity point if active (scale it proportionally)
            if (gravityPoint.active && oldWidth > 0 && oldHeight > 0) {
                gravityPoint.x *= (canvasWidth / oldWidth);
                gravityPoint.y *= (canvasHeight / oldHeight);
            }
            
            // Update the canvas size display
            document.getElementById('canvas-size').textContent = `${canvasWidth}×${canvasHeight}`;
            
            // Update the draggable controls
            document.getElementById('canvas-width').textContent = canvasWidth;
            document.getElementById('canvas-height').textContent = canvasHeight;
        }

        // ===== TAB SYSTEM =====
        // Tab switching functionality
        function initTabSystem() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabPanels = document.querySelectorAll('.tab-panel');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetTab = button.getAttribute('data-tab');
                    
                    // Remove active class from all buttons and panels
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabPanels.forEach(panel => panel.classList.remove('active'));
                    
                    // Add active class to clicked button
                    button.classList.add('active');
                    
                    // Show corresponding panel
                    const targetPanel = document.getElementById(`${targetTab}-panel`);
                    if (targetPanel) {
                        targetPanel.classList.add('active');
                    }
                });
            });
            
            console.log('🎯 Tab system initialized');
        }
        
        // ===== COLLAPSIBLE SECTIONS =====
        function toggleCollapsible(sectionId) {
            const section = document.getElementById(sectionId);
            const content = section.querySelector('.collapsible-content');
            const toggle = section.querySelector('.collapsible-toggle');
            
            section.classList.toggle('collapsed');
            content.classList.toggle('collapsed');
            
            // Save state to localStorage
            const isCollapsed = section.classList.contains('collapsed');
            localStorage.setItem(`collapsible-${sectionId}`, isCollapsed.toString());
        }
        
        // Initialize collapsible sections from saved state
        function initCollapsibleSections() {
            const sections = document.querySelectorAll('.collapsible-section');
            sections.forEach(section => {
                const sectionId = section.id;
                const saved = localStorage.getItem(`collapsible-${sectionId}`);
                if (saved === 'true') {
                    section.classList.add('collapsed');
                    const content = section.querySelector('.collapsible-content');
                    content.classList.add('collapsed');
                }
            });
        }
        
        // ===== SPECIES TAB SYSTEM =====
        let currentSpeciesTab = 0;
        
        function createSpeciesTabs() {
            const tabContainer = document.getElementById('speciesTabs');
            if (!tabContainer) return;
            
            tabContainer.innerHTML = '';
            
            for (let i = 0; i < speciesCount; i++) {
                const tab = document.createElement('div');
                tab.className = 'species-tab';
                if (i === currentSpeciesTab) tab.classList.add('active');
                tab.style.color = rgbToHex(speciesColors[i]);
                tab.addEventListener('click', () => selectSpeciesTab(i));
                
                const label = document.createElement('div');
                label.className = 'species-tab-label';
                label.textContent = `Species ${String.fromCharCode(65 + i)}`;
                
                const info = document.createElement('div');
                info.className = 'species-tab-info';
                
                const particleCount = document.createElement('span');
                particleCount.textContent = particleCounts[i] || 0;
                particleCount.id = `species-count-${i}`;
                
                const audioStatus = document.createElement('div');
                audioStatus.className = 'species-audio-status';
                audioStatus.id = `species-audio-status-${i}`;
                
                info.appendChild(particleCount);
                info.appendChild(audioStatus);
                
                tab.appendChild(label);
                tab.appendChild(info);
                tabContainer.appendChild(tab);
            }
            
            console.log(`🎯 Created ${speciesCount} species tabs`);
        }
        
        function selectSpeciesTab(speciesIndex) {
            if (speciesIndex === currentSpeciesTab) return;
            
            currentSpeciesTab = speciesIndex;
            selectedSpeciesForAudio = speciesIndex;
            
            // Update tab appearance
            const tabs = document.querySelectorAll('.species-tab');
            tabs.forEach((tab, index) => {
                tab.classList.toggle('active', index === speciesIndex);
            });
            
            // Regenerate audio controls for selected species
            createSpeciesAudioControls();
            
            // Setup draggable numbers
            if (typeof setupDraggableNumbers === 'function') {
                setTimeout(() => setupDraggableNumbers(), 0);
            }
            
            console.log(`🎯 Selected species ${String.fromCharCode(65 + speciesIndex)}`);
        }
        
        // Update species tab info (particle counts, audio status)
        function updateSpeciesTabInfo() {
            for (let i = 0; i < speciesCount; i++) {
                const countElement = document.getElementById(`species-count-${i}`);
                if (countElement) {
                    countElement.textContent = particleCounts[i] || 0;
                }
                
                const statusElement = document.getElementById(`species-audio-status-${i}`);
                if (statusElement && speciesAudioSynths[i]) {
                    const hasAudio = speciesAudioSynths[i].audioBuffer && isAudioEnabled;
                    const isActive = hasAudio && !speciesAudioSynths[i].isMuted;
                    statusElement.classList.toggle('active', isActive);
                }
            }
        }
        
        // ===== KEYBOARD SHORTCUTS =====
        let keyboardEnabled = true;
        
        function initKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Skip if user is typing in an input field
                if (['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) {
                    return;
                }
                
                if (!keyboardEnabled) return;
                
                switch(e.code) {
                    case 'Space':
                        e.preventDefault();
                        togglePause();
                        showToast('Simulation ' + (isPaused ? 'Paused' : 'Resumed'));
                        break;
                        
                    case 'KeyR':
                        if (e.ctrlKey || e.metaKey) return; // Don't interfere with refresh
                        e.preventDefault();
                        resetSimulation();
                        showToast('Simulation Reset');
                        break;
                        
                    case 'KeyM':
                        e.preventDefault();
                        toggleMasterMute();
                        showToast('Master ' + (isMasterMuted ? 'Muted' : 'Unmuted'));
                        break;
                        
                    case 'KeyS':
                        if (e.ctrlKey || e.metaKey) return; // Don't interfere with save
                        e.preventDefault();
                        soloCurrentSpecies();
                        break;
                        
                    case 'Equal': // Plus key
                        if (!e.shiftKey) break; // Only on Shift+= (+)
                        e.preventDefault();
                        adjustMasterVolume(0.05);
                        break;
                        
                    case 'Minus':
                        e.preventDefault();
                        adjustMasterVolume(-0.05);
                        break;
                        
                    case 'Digit1':
                    case 'Digit2':
                    case 'Digit3':
                    case 'Digit4':
                    case 'Digit5':
                    case 'Digit6':
                    case 'Digit7':
                    case 'Digit8':
                        e.preventDefault();
                        const speciesIndex = parseInt(e.code.slice(-1)) - 1;
                        if (speciesIndex < speciesCount) {
                            selectSpeciesTab(speciesIndex);
                            showToast(`Species ${String.fromCharCode(65 + speciesIndex)} Selected`);
                        }
                        break;
                        
                    case 'ArrowUp':
                    case 'ArrowDown':
                    case 'ArrowLeft':
                    case 'ArrowRight':
                        // Fine-tune selected parameter (could be expanded)
                        e.preventDefault();
                        break;
                        
                    case 'KeyH':
                        e.preventDefault();
                        showKeyboardHelp();
                        break;
                }
            });
            
            console.log('⌨️ Keyboard shortcuts initialized');
        }
        
        function adjustMasterVolume(delta) {
            const newVolume = Math.max(0, Math.min(1, masterVolume + delta));
            setMasterVolume(newVolume);
            document.getElementById('masterVolume').value = newVolume;
            showToast(`Master Volume: ${Math.round(newVolume * 100)}%`);
        }
        
        function soloCurrentSpecies() {
            const currentSynth = speciesAudioSynths[currentSpeciesTab];
            if (!currentSynth) return;
            
            // Toggle solo: if current is unmuted and others are muted, unmute all
            // Otherwise, mute all except current
            let othersMuted = true;
            for (let i = 0; i < speciesCount; i++) {
                if (i !== currentSpeciesTab && speciesAudioSynths[i] && !speciesAudioSynths[i].isMuted) {
                    othersMuted = false;
                    break;
                }
            }
            
            if (!currentSynth.isMuted && othersMuted) {
                // Unsolo - unmute all
                for (let i = 0; i < speciesCount; i++) {
                    if (speciesAudioSynths[i]) {
                        speciesAudioSynths[i].setMute(false);
                        const button = document.getElementById(`speciesMute${i}`);
                        if (button) {
                            button.textContent = '🔊';
                            button.classList.add('active');
                        }
                    }
                }
                showToast('All Species Unmuted');
            } else {
                // Solo current species
                for (let i = 0; i < speciesCount; i++) {
                    const shouldMute = i !== currentSpeciesTab;
                    if (speciesAudioSynths[i]) {
                        speciesAudioSynths[i].setMute(shouldMute);
                        const button = document.getElementById(`speciesMute${i}`);
                        if (button) {
                            button.textContent = shouldMute ? '🔇' : '🔊';
                            button.classList.toggle('active', !shouldMute);
                        }
                    }
                }
                showToast(`Species ${String.fromCharCode(65 + currentSpeciesTab)} Soloed`);
            }
        }
        
        function showKeyboardHelp() {
            const helpText = `
🎹 KEYBOARD SHORTCUTS:

Space     - Pause/Resume simulation
R         - Reset simulation
M         - Master mute toggle
S         - Solo current species
+/-       - Adjust master volume
1-8       - Switch species tabs
H         - Show this help

📱 Click OK to dismiss`;
            
            alert(helpText);
        }
        
        // ===== TOAST NOTIFICATIONS =====
        function showToast(message, duration = 2000) {
            // Remove existing toast
            const existingToast = document.getElementById('toast');
            if (existingToast) {
                existingToast.remove();
            }
            
            // Create new toast
            const toast = document.createElement('div');
            toast.id = 'toast';
            toast.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: #333;
                color: #fff;
                padding: 10px 20px;
                border-radius: 6px;
                border: 1px solid #555;
                font-size: 14px;
                font-weight: bold;
                z-index: 10000;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
                font-family: Arial, sans-serif;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                max-width: 300px;
            `;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            // Animate in
            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateX(0)';
            }, 10);
            
            // Animate out and remove
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.remove();
                    }
                }, 300);
            }, duration);
        }
        
        // ===== PRESET SYSTEM =====
        function getCurrentState() {
            const state = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                
                // Canvas settings
                canvasWidth: canvasWidth,
                canvasHeight: canvasHeight,
                
                // Species settings
                speciesCount: speciesCount,
                particleCounts: [...particleCounts],
                particleSizes: [...particleSizes],
                speciesTrailLengths: [...speciesTrailLengths],
                speciesColors: speciesColors.map(color => [...color]),
                
                // Physics settings
                friction: FRICTION,
                maxForceDistance: MAX_FORCE_DISTANCE,
                simulationSpeed: SIMULATION_SPEED,
                toroidalSpace: TOROIDAL_SPACE,
                gravityStrength: GRAVITY_STRENGTH,
                bounceDamping: BOUNCE_DAMPING,
                relationshipMatrix: RELATIONSHIP_MATRIX.map(row => [...row]),
                
                // Audio settings
                masterVolume: masterVolume,
                frequencyRange: {...frequencyRange},
                globalVelocityGainCurve: globalVelocityGainCurve,
                globalVelocityThreshold: globalVelocityThreshold,
                
                // Species audio settings (excluding audio buffers)
                speciesAudioSettings: speciesAudioSynths.map(synth => ({
                    volume: synth ? synth.volume : 0.7,
                    isMuted: synth ? synth.isMuted : false,
                    loopMode: synth ? synth.loopMode : 'forward',
                    pitch: synth ? synth.pitch : 0,
                    detune: synth ? synth.detune : 0,
                    fadeLength: synth ? synth.fadeLength : 0.002,
                    sampleStart: synth ? synth.sampleStart : 0.0,
                    sampleEnd: synth ? synth.sampleEnd : 1.0
                }))
            };
            
            return state;
        }
        
        function applyState(state) {
            try {
                // Validate version compatibility
                if (!state.version || state.version !== '1.0') {
                    throw new Error('Incompatible preset version');
                }
                
                // Apply canvas settings
                updateCanvasSize(state.canvasWidth || 1200, state.canvasHeight || 800);
                
                // Apply species settings
                speciesCount = state.speciesCount || 2;
                document.getElementById('speciesCount').value = speciesCount;
                document.getElementById('speciesCount-value').textContent = speciesCount;
                
                if (state.particleCounts) particleCounts.splice(0, particleCounts.length, ...state.particleCounts);
                if (state.particleSizes) particleSizes.splice(0, particleSizes.length, ...state.particleSizes);
                if (state.speciesTrailLengths) speciesTrailLengths.splice(0, speciesTrailLengths.length, ...state.speciesTrailLengths);
                if (state.speciesColors) {
                    speciesColors.splice(0, speciesColors.length, ...state.speciesColors.map(color => [...color]));
                }
                
                // Apply physics settings
                FRICTION = state.friction || 0.95;
                MAX_FORCE_DISTANCE = state.maxForceDistance || 60;
                SIMULATION_SPEED = state.simulationSpeed || 1.0;
                TOROIDAL_SPACE = state.toroidalSpace !== undefined ? state.toroidalSpace : true;
                GRAVITY_STRENGTH = state.gravityStrength || 0.0;
                BOUNCE_DAMPING = state.bounceDamping || 0.8;
                
                if (state.relationshipMatrix) {
                    RELATIONSHIP_MATRIX.splice(0, RELATIONSHIP_MATRIX.length, ...state.relationshipMatrix.map(row => [...row]));
                }
                
                // Update physics UI
                document.getElementById('friction').value = FRICTION;
                document.getElementById('friction-value').textContent = FRICTION.toFixed(2);
                document.getElementById('forceRadius').value = MAX_FORCE_DISTANCE;
                document.getElementById('forceRadius-value').textContent = MAX_FORCE_DISTANCE;
                document.getElementById('simSpeed').value = SIMULATION_SPEED;
                document.getElementById('simSpeed-value').textContent = SIMULATION_SPEED.toFixed(1);
                document.getElementById('gravityStrength').value = GRAVITY_STRENGTH;
                document.getElementById('gravityStrength-value').textContent = GRAVITY_STRENGTH.toFixed(1);
                document.getElementById('bounceDamping').value = BOUNCE_DAMPING;
                document.getElementById('bounceDamping-value').textContent = BOUNCE_DAMPING.toFixed(1);
                document.getElementById('toroidalSpace').checked = TOROIDAL_SPACE;
                
                // Apply audio settings
                masterVolume = state.masterVolume || 0.3;
                document.getElementById('masterVolume').value = masterVolume;
                setMasterVolume(masterVolume);
                
                if (state.frequencyRange) {
                    setFrequencyRange(state.frequencyRange.low || 80, state.frequencyRange.high || 8000);
                    document.getElementById('freqLow').value = frequencyRange.low;
                    document.getElementById('freqHigh').value = frequencyRange.high;
                }
                
                setGlobalVelocityGainCurve(state.globalVelocityGainCurve || 1.0);
                document.getElementById('velocityGainCurve').value = globalVelocityGainCurve;
                
                setGlobalVelocityThreshold(state.globalVelocityThreshold || 0.0);
                document.getElementById('velocityThreshold').value = globalVelocityThreshold;
                
                // Apply species audio settings (preserve existing audio buffers)
                if (state.speciesAudioSettings) {
                    state.speciesAudioSettings.forEach((settings, i) => {
                        if (speciesAudioSynths[i] && settings) {
                            speciesAudioSynths[i].volume = settings.volume || 0.7;
                            speciesAudioSynths[i].isMuted = settings.isMuted || false;
                            speciesAudioSynths[i].loopMode = settings.loopMode || 'forward';
                            speciesAudioSynths[i].pitch = settings.pitch || 0;
                            speciesAudioSynths[i].detune = settings.detune || 0;
                            speciesAudioSynths[i].fadeLength = settings.fadeLength || 0.002;
                            speciesAudioSynths[i].sampleStart = settings.sampleStart || 0.0;
                            speciesAudioSynths[i].sampleEnd = settings.sampleEnd || 1.0;
                        }
                    });
                }
                
                // Regenerate UI
                ensureMatrixSize();
                createForceMatrix();
                createSpeciesTabs();
                adjustParticleCounts();
                
                // Update spatial grid if needed
                if (spatialGrid) {
                    spatialGrid.updateCellSize(MAX_FORCE_DISTANCE);
                }
                
                // Regenerate audio controls
                if (isAudioEnabled) {
                    createSpeciesAudioControls();
                    setTimeout(() => setupDraggableNumbers(), 0);
                }
                
                console.log('⚙️ Preset applied successfully');
                return true;
                
            } catch (error) {
                console.error('Failed to apply preset:', error);
                showToast('Failed to load preset: ' + error.message, 3000);
                return false;
            }
        }
        
        function savePreset() {
            const name = prompt('Enter preset name:');
            if (!name || !name.trim()) return;
            
            const state = getCurrentState();
            state.name = name.trim();
            
            // Save to localStorage
            const presets = getStoredPresets();
            presets[name] = state;
            localStorage.setItem('granular-presets', JSON.stringify(presets));
            
            updatePresetSelect();
            showToast(`Preset "${name}" saved`);
            
            console.log(`💾 Preset saved: ${name}`);
        }
        
        function loadPreset() {
            const select = document.getElementById('presetSelect');
            const presetName = select.value;
            
            if (!presetName) {
                showToast('Please select a preset to load');
                return;
            }
            
            const presets = getStoredPresets();
            const preset = presets[presetName];
            
            if (!preset) {
                showToast('Preset not found');
                return;
            }
            
            if (applyState(preset)) {
                showToast(`Preset "${presetName}" loaded`);
                console.log(`📁 Preset loaded: ${presetName}`);
            }
        }
        
        function deletePreset() {
            const select = document.getElementById('presetSelect');
            const presetName = select.value;
            
            if (!presetName) {
                showToast('Please select a preset to delete');
                return;
            }
            
            if (!confirm(`Delete preset "${presetName}"?`)) {
                return;
            }
            
            const presets = getStoredPresets();
            delete presets[presetName];
            localStorage.setItem('granular-presets', JSON.stringify(presets));
            
            updatePresetSelect();
            showToast(`Preset "${presetName}" deleted`);
            
            console.log(`🗑️ Preset deleted: ${presetName}`);
        }
        
        function exportPreset() {
            const select = document.getElementById('presetSelect');
            const presetName = select.value;
            
            let preset, filename;
            
            if (presetName) {
                const presets = getStoredPresets();
                preset = presets[presetName];
                filename = `granular-preset-${presetName.replace(/[^a-zA-Z0-9]/g, '-')}.json`;
            } else {
                preset = getCurrentState();
                preset.name = 'Current State';
                filename = `granular-preset-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
            }
            
            if (!preset) {
                showToast('No preset to export');
                return;
            }
            
            // Create download link
            const dataStr = JSON.stringify(preset, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportLink = document.createElement('a');
            exportLink.setAttribute('href', dataUri);
            exportLink.setAttribute('download', filename);
            exportLink.click();
            
            showToast(`Preset exported as ${filename}`);
            
            console.log(`📤 Preset exported: ${filename}`);
        }
        
        function importPreset() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const preset = JSON.parse(e.target.result);
                        
                        if (applyState(preset)) {
                            // Also save to localStorage if it has a name
                            if (preset.name) {
                                const presets = getStoredPresets();
                                presets[preset.name] = preset;
                                localStorage.setItem('granular-presets', JSON.stringify(presets));
                                updatePresetSelect();
                                showToast(`Preset "${preset.name}" imported and saved`);
                            } else {
                                showToast('Preset imported (not saved)');
                            }
                        }
                    } catch (error) {
                        console.error('Import error:', error);
                        showToast('Invalid preset file');
                    }
                };
                reader.readAsText(file);
            });
            input.click();
        }
        
        function getStoredPresets() {
            try {
                return JSON.parse(localStorage.getItem('granular-presets') || '{}');
            } catch (error) {
                console.error('Failed to load presets:', error);
                return {};
            }
        }
        
        function updatePresetSelect() {
            const select = document.getElementById('presetSelect');
            const presets = getStoredPresets();
            
            select.innerHTML = '<option value="">Select Preset...</option>';
            
            Object.keys(presets).sort().forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
        }
        
        function initPresetSystem() {
            updatePresetSelect();
            
            // Add import functionality to the load button's context menu
            const loadButton = document.querySelector('button[onclick="loadPreset()"]');
            if (loadButton) {
                loadButton.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    importPreset();
                });
                loadButton.title = 'Left-click: Load selected preset\nRight-click: Import preset file';
            }
            
            console.log('🎯 Preset system initialized');
        }

        // ===== INITIALIZATION =====
        // Initialize and start
        initCanvas(); // Initialize canvas to default size
        ensureMatrixSize();
        createForceMatrix();
        setupSliders();
        setupDraggableNumbers();
        setupCanvasInteraction(); // Setup gravity interaction
        initSpatialGrid(); // Initialize spatial partitioning system
        initTrailSystem(); // Initialize colorful trail system
        initParticles();
        
        // Initialize audio UI (controls visible immediately)
        initAudioUI();
        updateAudioStatus('Click to Start');
        
        // Initialize interface systems
        initTabSystem();
        initCollapsibleSections();
        createSpeciesTabs();
        initKeyboardShortcuts();
        initPresetSystem();
        
        animate(); // Use original animation loop from physics-core.js
        
        // Show welcome message
        setTimeout(() => {
            showToast('Press H for keyboard shortcuts', 3000);
        }, 1000);
    </script>
</body>
</html>