<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Life Simulator - GPU Optimized</title>
    <style>
        /* Tab Interface Styles */
        .tab-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #111;
            border-bottom: 2px solid #333;
            z-index: 1000;
            display: flex;
            justify-content: center;
            padding: 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .tab-button {
            background: #222;
            color: #ccc;
            border: none;
            padding: 15px 30px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            min-width: 200px;
        }

        .tab-button:hover {
            background: #333;
            color: #fff;
        }

        .tab-button.active {
            background: #444;
            color: #4CAF50;
            border-bottom-color: #4CAF50;
        }

        .tab-content {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 10;
            pointer-events: none;
        }

        .tab-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 400px;
            height: 100%;
            background: #111;
            border-right: 2px solid #333;
            transform: translateX(-100%);
            transition: transform 0.4s ease;
            pointer-events: auto;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            z-index: 1;
        }

        .tab-panel.active {
            transform: translateX(0);
            z-index: 2;
        }

        .tab-panel .control-panel {
            width: 100%;
            height: 100%;
            padding: 20px;
            overflow-y: auto;
            max-height: none;
            position: static;
            border: none;
            border-radius: 0;
            background: #111;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow-x: hidden;
        }
        
        .main-content {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 5;
            /* Ensure canvas stays in front of scrollbars and properly centered */
            overflow: hidden;
            background: #000;
        }
        canvas {
            border: 1px solid #333;
            display: block;
        }
        #canvas {
            position: relative;
            z-index: 2;
            background: #000;
        }
        .control-panel {
            width: 100%;
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 0;
            height: 100%;
            position: static;
            overflow-y: auto;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group h3 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 6px;
        }
        .slider-row {
            margin-bottom: 10px;
        }
        .slider-row label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #ccc;
        }
        .checkbox-label {
            display: flex !important;
            align-items: center;
        }
        .slider-row label input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
        }
        .value-display {
            min-width: 50px;
            text-align: right;
            font-size: 12px;
            color: #888;
            font-family: monospace;
        }
        .species-a { color: #ff4444; }
        .species-b { color: #4444ff; }
        
        /* Particle Settings Styles */
        .particle-settings {
            margin-bottom: 15px;
        }
        .species-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
            font-size: 14px;
        }
        .species-label {
            min-width: 70px;
            font-weight: bold;
        }
        .param-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .param-label {
            color: #ccc;
            font-size: 12px;
        }
        .draggable-number {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: ns-resize;
            user-select: none;
            min-width: 40px;
            text-align: center;
            font-family: monospace;
            font-size: 12px;
        }
        .draggable-number:hover {
            background: #444;
            border-color: #666;
        }
        .draggable-number.dragging {
            background: #555;
            border-color: #888;
        }
        
        /* Force Matrix Styles */
        .matrix-container {
            margin-top: 15px;
        }
        .matrix-grid {
            display: grid;
            gap: 0px;
            background: #555;
            border: 2px solid #666;
            border-radius: 4px;
            overflow: hidden;
        }
        .matrix-header {
            background: #222;
            padding: 6px;
            text-align: center;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            border: 2px solid #444;
        }
        .species-color-picker {
            width: 20px;
            height: 20px;
            border: 1px solid #666;
            border-radius: 3px;
            cursor: pointer;
            padding: 0;
        }
        .matrix-cell {
            background: #444;
            padding: 0;
            text-align: center;
            font-size: 10px;
            font-weight: bold;
            cursor: ns-resize;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: background-color 0.1s ease;
            border: 2px solid #333;
        }
        .matrix-cell:hover {
            border: 2px solid #888;
        }
        .matrix-cell.dragging {
            border: 2px solid #fff;
        }
        .force-legend {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 10px;
            color: #888;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        .controls {
            text-align: center;
            margin: 20px;
        }
        button {
            background: #333;
            color: #fff;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            border-radius: 5px;
        }
        button:hover {
            background: #555;
        }
        
        /* Responsive design for tabbed interface */
        @media (max-width: 1024px) {
            .tab-panel {
                width: 320px;
            }
            .tab-button {
                min-width: 180px;
                padding: 12px 20px;
                font-size: 13px;
            }
        }
        
        @media (max-width: 768px) {
            .tab-header {
                flex-direction: column;
                height: auto;
                position: relative;
            }
            
            .tab-button {
                min-width: auto;
                width: 100%;
                padding: 15px;
                border-bottom: 1px solid #333;
                border-right: none;
            }
            
            .tab-button.active {
                border-bottom-color: #4CAF50;
                border-right-color: transparent;
            }
            
            .tab-content {
                position: relative;
                top: 0;
                height: 40vh;
            }
            
            .tab-panel {
                width: 100%;
                left: 0;
                transform: translateY(-100%);
                border-right: none;
                border-bottom: 2px solid #333;
            }
            
            .tab-panel.active {
                transform: translateY(0);
            }
            
            .main-content {
                position: relative;
                top: 0;
                height: 60vh;
                min-height: 60vh;
            }
        }
        
        @media (max-width: 480px) {
            .tab-content {
                height: 45vh;
            }
            
            .main-content {
                height: 55vh;
                min-height: 55vh;
            }
            
            .tab-button {
                font-size: 12px;
                padding: 12px;
            }
        }
        
        /* Audio Control Styles */
        .audio-master-controls {
            margin-bottom: 15px;
            padding: 10px;
            background: #0a0a0a;
            border: 1px solid #444;
            border-radius: 6px;
        }
        
        /* Species Tab System */
        .species-tab-container {
            margin-bottom: 15px;
        }
        
        /* Audio Mode Tab System */
        .audio-mode-tabs {
            display: flex;
            margin-bottom: 15px;
            background: #1a1a1a;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #333;
        }
        
        .audio-mode-tab {
            flex: 1;
            padding: 12px 16px;
            background: #222;
            color: #ccc;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .audio-mode-tab:hover {
            background: #333;
            color: #fff;
        }
        
        .audio-mode-tab.active {
            background: #4CAF50;
            color: #000;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .audio-mode-tab:first-child {
            border-right: 1px solid #333;
        }
        
        .audio-mode-content {
            min-height: 200px;
        }
        
        /* [REMOVED] Legacy audio-mode-panel styles - no longer used */
        
        /* [REMOVED] Legacy threshold visualization styles - no longer used */
        
        .species-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 15px;
            padding: 10px;
            background: #0a0a0a;
            border: 1px solid #444;
            border-radius: 6px;
        }
        
        .species-tab {
            flex: 1;
            min-width: 80px;
            padding: 8px 12px;
            background: #222;
            border: 2px solid #444;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }
        
        .species-tab:hover {
            background: #333;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .species-tab.active {
            background: #444;
            border-color: currentColor;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            transform: translateY(-2px);
        }
        
        .species-tab-label {
            display: block;
            margin-bottom: 2px;
        }
        
        .species-tab-info {
            font-size: 10px;
            opacity: 0.8;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .species-audio-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
        }
        
        .species-audio-status:hover {
            transform: scale(1.1);
        }
        
        .species-audio-status.active {
            background: #4CAF50;
            box-shadow: 0 0 4px #4CAF50;
        }
        
        .species-audio-status.muted {
            background: #f44336;
            box-shadow: 0 0 4px #f44336;
        }
        
        /* Collapsible Sections */
        .collapsible-section {
            margin-bottom: 15px;
        }
        
        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }
        
        .collapsible-header:hover {
            background: #252525;
        }
        
        .collapsible-header h3 {
            margin: 0;
            font-size: 15px;
        }
        
        .collapsible-toggle {
            font-size: 14px;
            transition: transform 0.2s ease;
        }
        
        .collapsible-content {
            border: 1px solid #444;
            border-top: none;
            border-radius: 0 0 6px 6px;
            background: #111;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .collapsible-content.collapsed {
            max-height: 0;
            border: none;
        }
        
        .collapsible-content:not(.collapsed) {
            max-height: 1000px;
        }
        
        .collapsible-section.collapsed .collapsible-toggle {
            transform: rotate(180deg);
        }
        
        .collapsible-inner {
            padding: 15px;
        }
        
        .audio-button {
            background: #444;
            color: #fff;
            border: none;
            padding: 4px 8px;
            margin-left: 8px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
            min-width: 35px;
        }
        
        .audio-button:hover {
            background: #666;
        }
        
        .audio-button.active {
            background: #4CAF50;
        }
        
        .loop-controls {
            display: flex;
            gap: 4px;
            flex: 1;
        }
        
        .loop-button {
            min-width: 32px;
            height: 24px;
            padding: 2px 6px;
            font-size: 12px;
            background: #444;
            color: #fff;
            border: 1px solid #666;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .loop-button:hover {
            background: #555;
            border-color: #777;
        }
        
        .loop-button.active {
            background: #4CAF50;
            color: #000;
            border-color: #4CAF50;
        }
        
        .freq-range-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .freq-range {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .freq-label {
            min-width: 35px;
            font-size: 12px;
            color: #ccc;
        }
        
        .freq-slider {
            flex: 1;
        }
        
        .audio-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 12px;
        }
        
        .species-audio-container {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .species-audio-panel {
            margin-bottom: 15px;
            padding: 12px;
            background: #0f0f0f;
            border: 1px solid #333;
            border-radius: 6px;
        }
        
        .species-audio-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .species-audio-title {
            font-weight: bold;
            font-size: 14px;
        }
        
        .audio-file-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .file-input-label {
            background: #333;
            color: #fff;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            border: 1px solid #555;
        }
        
        .file-input-label:hover {
            background: #444;
        }
        
        .file-name {
            flex: 1;
            font-size: 11px;
            color: #888;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .waveform-container {
            width: 100%;
            height: 40px;
            background: #222;
            border: 1px solid #444;
            border-radius: 3px;
            margin-bottom: 8px;
            position: relative;
            overflow: hidden;
        }
        
        .waveform-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .audio-controls-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .audio-controls-group {
            background: #0f0f0f;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }
        
        .audio-controls-group h4 {
            margin: 0 0 10px 0;
            color: #ccc;
            font-size: 13px;
            border-bottom: 1px solid #333;
            padding-bottom: 6px;
        }
        
        .grain-activity {
            display: flex;
            gap: 2px;
            flex-wrap: wrap;
        }
        
        .grain-indicator {
            width: 8px;
            height: 8px;
            background: #333;
            border-radius: 50%;
            transition: background-color 0.1s ease;
        }
        
        .grain-indicator.active {
            background: #4CAF50;
        }
        
        .audio-meter {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
        }
        
        .meter-bar {
            width: 50px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .meter-fill {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #FFC107, #FF5722);
            width: 0%;
            transition: width 0.1s ease;
        }
        
        /* Rotary Dial for Ratio Control */
        .ratio-dial-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 12px;
        }
        
        .ratio-dial {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #333;
            border: 3px solid #555;
            position: relative;
            cursor: pointer;
            transition: border-color 0.2s ease;
        }
        
        .ratio-dial:hover {
            border-color: #4CAF50;
        }
        
        .ratio-dial-indicator {
            position: absolute;
            top: 3px;
            left: 50%;
            width: 3px;
            height: 20px;
            background: #4CAF50;
            transform-origin: center bottom;
            transform: translateX(-50%) rotate(0deg);
            border-radius: 2px;
            transition: transform 0.1s ease;
        }
        
        .ratio-dial-label {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 4px;
        }
        
        .ratio-dial-value {
            font-size: 14px;
            font-weight: bold;
            color: #4CAF50;
            text-align: center;
        }
        
        /* Keyboard Shortcuts Display */
        .keyboard-shortcuts {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #111;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 15px;
            color: #ccc;
            font-size: 12px;
            font-family: monospace;
            line-height: 1.4;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            min-width: 200px;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .keyboard-shortcuts.hidden {
            opacity: 0;
            transform: translateX(100%);
            pointer-events: none;
        }
        
        .shortcuts-header {
            color: #4CAF50;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
            border-bottom: 1px solid #333;
            padding-bottom: 4px;
        }
        
        .shortcut-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }
        
        .shortcut-key {
            color: #4CAF50;
            font-weight: bold;
        }
        
        .shortcut-action {
            color: #ccc;
        }
        
        .shortcuts-toggle {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background: #333;
            border: 1px solid #555;
            border-radius: 50%;
            color: #ccc;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            transition: all 0.2s ease;
        }
        
        .shortcuts-toggle:hover {
            background: #444;
            color: #fff;
        }
        
        /* Performance Metrics Display */
        .performance-metrics {
            position: fixed;
            top: 80px;
            right: 20px;
            background: #111;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 12px;
            color: #ccc;
            font-size: 12px;
            font-family: monospace;
            line-height: 1.4;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            min-width: 150px;
        }
        
        .metrics-header {
            color: #4CAF50;
            font-weight: bold;
            margin-bottom: 6px;
            text-align: center;
            border-bottom: 1px solid #333;
            padding-bottom: 3px;
            font-size: 11px;
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }
        
        .metric-label {
            color: #888;
        }
        
        .metric-value {
            color: #4CAF50;
            font-weight: bold;
        }
        
    </style>
</head>
<body>
    <!-- Tab Navigation Header -->
    <div class="tab-header">
        <button class="tab-button active" data-tab="physics">
            ⚛️ Physics & Simulation
        </button>
        <button class="tab-button" data-tab="audio">
            🎵 Audio Engine
        </button>
    </div>

    <!-- Tabbed Control Panels -->
    <div class="tab-content">
        <!-- Physics & Simulation Panel -->
        <div class="tab-panel active" id="physics-panel">
            <div class="control-panel physics-panel">
        <div class="collapsible-section" id="presetSection">
            <div class="collapsible-header" onclick="toggleCollapsible('presetSection')">
                <h3>Presets & Control</h3>
                <span class="collapsible-toggle">▼</span>
            </div>
            <div class="collapsible-content" id="presetContent">
                <div class="collapsible-inner">
                    <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                        <button onclick="savePreset()" style="flex: 1; background: #2a5f2a; font-size: 12px; padding: 8px;">💾 Save</button>
                        <button onclick="loadPreset()" style="flex: 1; background: #2a2a5f; font-size: 12px; padding: 8px;">📁 Load</button>
                        <button onclick="exportPreset()" style="flex: 1; background: #5f2a5f; font-size: 12px; padding: 8px;">📤 Export</button>
                    </div>
                    <div style="display: flex; gap: 8px; margin-bottom: 15px;">
                        <select id="presetSelect" style="flex: 1; background: #333; color: #fff; border: 1px solid #555; padding: 5px; border-radius: 3px; font-size: 12px;">
                            <option value="">Select Preset...</option>
                        </select>
                        <button onclick="deletePreset()" style="background: #5f2a2a; font-size: 12px; padding: 5px 10px;">🗑️</button>
                    </div>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button onclick="resetSimulation()" style="flex: 1; font-size: 12px; padding: 8px;">🔄 Reset</button>
                        <button onclick="togglePause()" style="flex: 1; font-size: 12px; padding: 8px;">⏯️ Pause</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <div class="slider-row">
                <label>Canvas Width</label>
                <div class="slider-container">
                    <span class="draggable-number" id="canvas-width">1200</span>
                    <span style="color: #888; font-size: 12px;">px</span>
                </div>
            </div>
            <div class="slider-row">
                <label>Canvas Height</label>
                <div class="slider-container">
                    <span class="draggable-number" id="canvas-height">800</span>
                    <span style="color: #888; font-size: 12px;">px</span>
                </div>
            </div>
        </div>


        <div class="collapsible-section" id="forceMatrixSection">
            <div class="collapsible-header" onclick="toggleCollapsible('forceMatrixSection')">
                <h3>Force Relationships</h3>
                <span class="collapsible-toggle">▼</span>
            </div>
            <div class="collapsible-content" id="forceMatrixContent">
                <div class="collapsible-inner">
                    <div class="matrix-container">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin: 0 0 10px 0;">
                            <h4 style="margin: 0; color: #ccc; font-size: 14px;">Force Relationship Matrix</h4>
                            <button id="randomizeMatrix" class="audio-button" style="font-size: 12px; padding: 4px 8px;">🎲 Randomize</button>
                        </div>
                        <div class="matrix-grid" id="forceMatrix">
                            <!-- Matrix will be generated dynamically -->
                        </div>
                        <div class="force-legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #ff4444;"></div>
                                <span>Repulsion (-1.0)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #666;"></div>
                                <span>Neutral (0.0)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #44ff44;"></div>
                                <span>Attraction (+1.0)</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>


        <div class="control-group">
            <h3>Physics Settings</h3>
            <div class="slider-row">
                <label class="checkbox-label">
                    <input type="checkbox" id="toroidalSpace" checked style="margin-right: 8px;">
                    Toroidal Space (Edge Wrapping)
                </label>
            </div>
            <div class="slider-row">
                <label>Friction</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="friction" min="0.85" max="1.0" step="0.01" value="0.95">
                    <span class="value-display" id="friction-value">0.95</span>
                </div>
            </div>
            <div class="slider-row">
                <label>Force Radius</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="forceRadius" min="20" max="200" step="10" value="60">
                    <span class="value-display" id="forceRadius-value">60</span>
                </div>
            </div>
            <div class="slider-row">
                <label>Simulation Speed</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="simSpeed" min="0.1" max="2.0" step="0.1" value="1.0">
                    <span class="value-display" id="simSpeed-value">1.0</span>
                </div>
            </div>
            <div class="slider-row">
                <label>Gravity Strength</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="gravityStrength" min="0.0" max="10.0" step="0.05" value="0.0">
                    <span class="value-display" id="gravityStrength-value">0.0</span>
                </div>
            </div>
            <div class="slider-row">
                <label>Wall Bounce Damping</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="bounceDamping" min="0.5" max="1.5" step="0.1" value="0.8">
                    <span class="value-display" id="bounceDamping-value">0.8</span>
                </div>
            </div>
            <div style="font-size: 12px; color: #888; margin-top: 8px;">
                Click and hold on simulation to create gravity pull
            </div>
        </div>

            </div>
        </div>

        <!-- Audio Engine Panel -->
        <div class="tab-panel" id="audio-panel">
            <div class="control-panel audio-panel">
                
                <div class="control-group">
                    <h3>Species Configuration</h3>
                    <div class="slider-row">
                        <label>Species Count</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="speciesCount" min="2" max="8" step="1" value="2">
                            <span class="value-display" id="speciesCount-value">2</span>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Master Audio Controls</h3>
                    <div class="audio-master-controls">
                        <div class="slider-row">
                            <label>Master Volume</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="masterVolume" min="0" max="1.0" step="0.05" value="0.3">
                                <span class="value-display" id="masterVolume-value">0.30</span>
                                <button id="masterMute" class="audio-button">🔇</button>
                            </div>
                        </div>
                        <div class="slider-row">
                            <label>Frequency Range</label>
                            <div class="freq-range-container">
                                <div class="freq-range">
                                    <span class="freq-label">Low:</span>
                                    <input type="range" class="slider freq-slider" id="freqLow" min="20" max="500" step="10" value="80">
                                    <span class="value-display" id="freqLow-value">80Hz</span>
                                </div>
                                <div class="freq-range">
                                    <span class="freq-label">High:</span>
                                    <input type="range" class="slider freq-slider" id="freqHigh" min="1000" max="20000" step="100" value="8000">
                                    <span class="value-display" id="freqHigh-value">8000Hz</span>
                                </div>
                            </div>
                        </div>
                        <div class="slider-row">
                            <label>Velocity x Gain Curve</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="velocityGainCurve" min="0.1" max="3.0" step="0.1" value="1.0">
                                <span class="value-display" id="velocityGainCurve-value">1.0</span>
                            </div>
                        </div>
                        <div class="slider-row">
                            <label>Velocity Threshold</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="velocityThreshold" min="0.0" max="1.0" step="0.01" value="0.0">
                                <span class="value-display" id="velocityThreshold-value">0.00</span>
                            </div>
                        </div>
                        <div class="audio-status">
                            <span>Audio: </span><span id="audioStatus" style="color: #888;">Initializing...</span>
                            <button id="audioInit" class="audio-button">🎵 Start Audio</button>
                        </div>
                    </div>
                </div>
                
                <div class="collapsible-section" id="speciesAudioSection">
                    <div class="collapsible-header" onclick="toggleCollapsible('speciesAudioSection')">
                        <h3>Individual Species Audio</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content" id="speciesAudioContent">
                        <div class="collapsible-inner">
                            <div class="species-tab-container">
                                <div class="species-tabs" id="speciesTabs">
                                    <!-- Species tabs will be generated dynamically -->
                                </div>
                            </div>
                            <div class="species-audio-container" id="speciesAudioControls">
                                <!-- Species audio controls will be generated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
    </div>

    <!-- Centered Canvas -->
    <div class="main-content">
        <canvas id="canvas"></canvas>
    </div>
    
    <!-- Performance Metrics Display -->
    <div id="performanceMetrics" class="performance-metrics">
        <div class="metrics-header">⚡ METRICS</div>
        <div class="metric-row">
            <span class="metric-label">FPS:</span>
            <span id="fps-display" class="metric-value">60</span>
        </div>
        <div class="metric-row">
            <span class="metric-label">Canvas:</span>
            <span id="canvas-size" class="metric-value">1200×800</span>
        </div>
        <div class="metric-row">
            <span class="metric-label">Particles:</span>
            <span id="total-particles" class="metric-value">400</span>
        </div>
        <div class="metric-row">
            <span class="metric-label">Audio grains:</span>
            <span id="total-grains" class="metric-value">0</span>
        </div>
        <div class="metric-row">
            <span class="metric-label">Audio latency:</span>
            <span id="audio-latency" class="metric-value">N/A</span>
        </div>
    </div>
    
    <!-- Keyboard Shortcuts Display -->
    <div id="keyboardShortcuts" class="keyboard-shortcuts">
        <div class="shortcuts-toggle" onclick="toggleKeyboardShortcuts()" title="Hide shortcuts">×</div>
        <div class="shortcuts-header">🎹 SHORTCUTS</div>
        <div class="shortcut-row">
            <span class="shortcut-key">Space</span>
            <span class="shortcut-action">Pause/Resume</span>
        </div>
        <div class="shortcut-row">
            <span class="shortcut-key">R</span>
            <span class="shortcut-action">Reset</span>
        </div>
        <div class="shortcut-row">
            <span class="shortcut-key">M</span>
            <span class="shortcut-action">Master mute</span>
        </div>
        <div class="shortcut-row">
            <span class="shortcut-key">S</span>
            <span class="shortcut-action">Solo species</span>
        </div>
        <div class="shortcut-row">
            <span class="shortcut-key">+/-</span>
            <span class="shortcut-action">Volume</span>
        </div>
        <div class="shortcut-row">
            <span class="shortcut-key">1-8</span>
            <span class="shortcut-action">Species tabs</span>
        </div>
        <div class="shortcut-row">
            <span class="shortcut-key">H</span>
            <span class="shortcut-action">Show shortcuts</span>
        </div>
    </div>

    <!-- ===== JAVASCRIPT MODULES ===== -->
    
    
    <!-- ===== MAIN APPLICATION ===== -->
    <script>
        // ===== AUDIO SYSTEM =====
        // Granular synthesis engine for particle-driven audio

// Audio System Variables
let audioContext = null;
let masterGainNode = null;
let compressorNode = null;
let isAudioEnabled = false;
let isMasterMuted = false;
let masterVolume = 0.3;
let frequencyRange = { low: 80, high: 8000 };

// Global velocity controls
let globalVelocityGainCurve = 1.0; // Exponential curve for velocity->gain (0.1-3.0)
let globalVelocityThreshold = 0.0; // Minimum velocity to trigger audio (0.0-1.0)
let globalVelocityThresholdSquared = 0.0; // Cached squared threshold for performance
let audioFadeDuration = 0.05; // Fade duration in seconds for threshold transitions (50ms)

// Species audio synthesizers
let speciesAudioSynths = [];

// Playback direction constants for velocity-based grain control
const PLAYBACK_DIRECTIONS = {
    FORWARD: 'forward',
    REVERSE: 'reverse', 
    ALTERNATING: 'alternating'
};


// Particle-Grain Manager: Direct 1:1 particle to grain mapping
class ParticleGrainManager {
    constructor(speciesIndex, audioContext, masterGain, parentSynth) {
        this.speciesIndex = speciesIndex;
        this.audioContext = audioContext;
        this.masterGain = masterGain;
        this.parentSynth = parentSynth;
        
        // Audio buffer reference
        this.audioBuffer = null;
        
        // Grain management - maps particle to grain
        this.particleGrains = new Map();
        this.maxGrains = 32; // Limit for performance
        
        // Audio-visual size correlation factor (user adjustable)
        this.sizeCorrelationFactor = 1.0; // 1.0 = exact correlation
        
        // Velocity thresholds for direction detection
        this.velocityThreshold = 0.1;
        this.alternatingGrainStates = new Map(); // Track alternating state per particle
        
        console.log(`🎵 ParticleGrainManager created for Species ${speciesIndex}`);
    }
    
    // Set audio buffer from parent synth
    setAudioBuffer(buffer) {
        this.audioBuffer = buffer;
    }
    
    // Calculate exact proportional grain parameters from particle
    calculateGrainParameters(particle) {
        // Get current canvas dimensions
        const canvas = document.getElementById('canvas');
        const currentCanvasWidth = canvas ? canvas.width : (typeof canvasWidth !== 'undefined' ? canvasWidth : 1200);
        const currentCanvasHeight = canvas ? canvas.height : (typeof canvasHeight !== 'undefined' ? canvasHeight : 800);
        
        // Get selected audio section
        const sampleStart = this.parentSynth ? this.parentSynth.sampleStart : 0.0;
        const sampleEnd = this.parentSynth ? this.parentSynth.sampleEnd : 1.0;
        const selectedAudioDuration = (sampleEnd - sampleStart) * this.audioBuffer.duration;
        
        // X-Axis: Exact proportional grain length
        const visualSizeRatioX = (particle.size * 2) / currentCanvasWidth; // particle diameter as % of canvas width
        const baseGrainLength = visualSizeRatioX * selectedAudioDuration; // same % of selected audio
        const grainLength = baseGrainLength * this.sizeCorrelationFactor; // apply correlation factor
        
        // Y-Axis: Exact proportional frequency band
        const visualSizeRatioY = (particle.size * 2) / currentCanvasHeight; // particle diameter as % of canvas height
        const totalFrequencyRange = frequencyRange.high - frequencyRange.low;
        const frequencyBandWidth = visualSizeRatioY * totalFrequencyRange * this.sizeCorrelationFactor;
        
        // Calculate center frequency from Y position (unchanged logic)
        const normalizedY = 1 - (particle.y / currentCanvasHeight); // invert Y
        const logLow = Math.log(frequencyRange.low);
        const logHigh = Math.log(frequencyRange.high);
        const centerFrequency = Math.exp(logLow + (normalizedY * (logHigh - logLow)));
        
        // Calculate frequency band boundaries
        const lowFreq = Math.max(frequencyRange.low, centerFrequency - (frequencyBandWidth / 2));
        const highFreq = Math.min(frequencyRange.high, centerFrequency + (frequencyBandWidth / 2));
        
        // Grain positioning: center at particle X position
        const canvasPosition = particle.x / currentCanvasWidth;
        const audioSectionPosition = sampleStart + (canvasPosition * (sampleEnd - sampleStart));
        const grainStartOffset = Math.max(sampleStart, audioSectionPosition - (grainLength / this.audioBuffer.duration / 2));
        const grainEndOffset = Math.min(sampleEnd, audioSectionPosition + (grainLength / this.audioBuffer.duration / 2));
        
        return {
            grainLength: grainLength,
            grainStartOffset: grainStartOffset * this.audioBuffer.duration,
            grainEndOffset: grainEndOffset * this.audioBuffer.duration,
            centerFrequency: centerFrequency,
            frequencyBandWidth: frequencyBandWidth,
            lowFreq: lowFreq,
            highFreq: highFreq,
            visualSizeRatioX: visualSizeRatioX,
            visualSizeRatioY: visualSizeRatioY
        };
    }
    
    // Determine playback direction from particle velocity
    getPlaybackDirection(particle) {
        const vx = particle.vx || 0;
        const vy = particle.vy || 0;
        
        if (Math.abs(vx) > this.velocityThreshold) {
            return vx > 0 ? PLAYBACK_DIRECTIONS.FORWARD : PLAYBACK_DIRECTIONS.REVERSE;
        } else {
            // Vertical movement or stationary - use alternating
            return PLAYBACK_DIRECTIONS.ALTERNATING;
        }
    }
    
    // Set size correlation factor (0.1x to 5.0x)
    setSizeCorrelationFactor(factor) {
        this.sizeCorrelationFactor = Math.max(0.1, Math.min(5.0, factor));
    }
    
    // Update all particle grains
    update(particles) {
        if (!this.audioBuffer) {
            console.log(`🔇 ParticleGrainManager Species ${this.speciesIndex}: No audio buffer`);
            return;
        }
        
        const speciesParticles = particles.filter(p => p.species === this.speciesIndex);
        const activeParticleSet = new Set(speciesParticles);
        
        // [REMOVED] Verbose debug logging
        
        // Remove grains for particles that no longer exist
        for (const [particle, grain] of this.particleGrains.entries()) {
            if (!activeParticleSet.has(particle)) {
                this.stopGrain(grain);
                this.particleGrains.delete(particle);
            }
        }
        
        // Update or create grains for active particles
        for (const particle of speciesParticles) {
            this.updateParticleGrain(particle);
        }
    }
    
    // Update or create grain for specific particle
    updateParticleGrain(particle) {
        const existingGrain = this.particleGrains.get(particle);
        const grainParams = this.calculateGrainParameters(particle);
        const playbackDirection = this.getPlaybackDirection(particle);
        
        // If grain exists and parameters haven't changed significantly, just update it
        if (existingGrain && this.shouldUpdateExistingGrain(existingGrain, grainParams, playbackDirection)) {
            this.updateGrainParameters(existingGrain, particle, grainParams, playbackDirection);
        } else {
            // Create new grain
            if (existingGrain) {
                this.stopGrain(existingGrain);
            }
            
            const newGrain = this.createGrain(particle, grainParams, playbackDirection);
            if (newGrain) {
                this.particleGrains.set(particle, newGrain);
                console.log(`✨ Created grain for Species ${this.speciesIndex}, total grains: ${this.particleGrains.size}`);
            } else {
                console.log(`❌ Failed to create grain for Species ${this.speciesIndex}`);
            }
        }
    }
    
    // Check if we should update existing grain vs create new one
    shouldUpdateExistingGrain(grain, newParams, newDirection) {
        if (!grain.isPlaying) return false;
        
        // If direction changed significantly, create new grain
        if (grain.playbackDirection !== newDirection) return false;
        
        // If grain length changed significantly (>10%), create new grain  
        const lengthChange = Math.abs(grain.grainLength - newParams.grainLength) / grain.grainLength;
        if (lengthChange > 0.1) return false;
        
        return true;
    }
    
    // Create new audio grain for particle
    createGrain(particle, grainParams, playbackDirection) {
        if (this.particleGrains.size >= this.maxGrains) return null;
        
        // Create audio nodes
        const source = this.audioContext.createBufferSource();
        const gainNode = this.audioContext.createGain();
        const filterNode = this.audioContext.createBiquadFilter();
        const pannerNode = this.audioContext.createStereoPanner();
        
        // Setup audio graph
        source.buffer = this.audioBuffer;
        source.connect(filterNode);
        filterNode.connect(gainNode);
        gainNode.connect(pannerNode);
        pannerNode.connect(this.masterGain);
        
        // Configure filter as bandpass using frequency band
        filterNode.type = 'bandpass';
        filterNode.frequency.value = grainParams.centerFrequency;
        const Q = grainParams.frequencyBandWidth > 0 ? grainParams.centerFrequency / grainParams.frequencyBandWidth : 2.0;
        filterNode.Q.value = Math.max(0.5, Math.min(30, Q));
        
        // Set initial gain - particles always generate audio at full volume
        const volume = this.parentSynth ? this.parentSynth.volume : 0.5;
        gainNode.gain.value = volume;
        
        // Set panning based on X position
        const canvas = document.getElementById('canvas');
        const currentCanvasWidth = canvas ? canvas.width : 1200;
        const pan = (particle.x / currentCanvasWidth) * 2 - 1;
        pannerNode.pan.value = pan;
        
        const grain = {
            source,
            gainNode,
            filterNode,
            pannerNode,
            particle,
            startTime: this.audioContext.currentTime,
            isPlaying: true,
            playbackDirection,
            grainLength: grainParams.grainLength,
            grainParams
        };
        
        // Start playback based on direction
        this.startGrainPlayback(grain, grainParams, playbackDirection);
        
        return grain;
    }
    
    // Start grain playback with appropriate direction and timing
    startGrainPlayback(grain, grainParams, playbackDirection) {
        const now = this.audioContext.currentTime;
        
        if (playbackDirection === PLAYBACK_DIRECTIONS.ALTERNATING) {
            // Handle alternating playback
            this.startAlternatingGrain(grain, grainParams, now);
        } else {
            // Handle forward/reverse playback
            const isReverse = playbackDirection === PLAYBACK_DIRECTIONS.REVERSE;
            grain.source.playbackRate.value = isReverse ? -1 : 1;
            
            const startOffset = isReverse ? grainParams.grainEndOffset : grainParams.grainStartOffset;
            const duration = grainParams.grainLength / 1000; // grainLength is in ms, convert to seconds
            
            grain.source.start(now, startOffset, duration); // startOffset already in seconds
            grain.source.stop(now + duration);
        }
        
        // Cleanup when finished
        grain.source.onended = () => {
            this.particleGrains.delete(grain.particle);
        };
    }
    
    // Handle alternating playback for vertical/stationary particles
    startAlternatingGrain(grain, grainParams, startTime) {
        // Implementation for alternating grain playback
        // This would involve scheduling multiple grain segments with alternating directions
        const halfDuration = grainParams.grainLength / 2000; // Convert ms to seconds and split
        
        // Start with forward direction
        grain.source.playbackRate.value = 1;
        grain.source.start(startTime, grainParams.grainStartOffset, halfDuration); // startOffset already in seconds
        
        // Schedule the reverse part (would need more complex implementation for seamless alternating)
        // For now, just play forward
        grain.source.stop(startTime + halfDuration);
    }
    
    // Update existing grain parameters
    updateGrainParameters(grain, particle, grainParams, playbackDirection) {
        if (!grain.isPlaying) return;
        
        const now = this.audioContext.currentTime;
        
        // Update frequency
        grain.filterNode.frequency.setTargetAtTime(grainParams.centerFrequency, now, 0.01);
        const Q = grainParams.frequencyBandWidth > 0 ? grainParams.centerFrequency / grainParams.frequencyBandWidth : 2.0;
        grain.filterNode.Q.setTargetAtTime(Math.max(0.5, Math.min(30, Q)), now, 0.01);
        
        // Update volume - particles always generate audio at consistent level
        const volume = this.parentSynth ? this.parentSynth.volume : 0.5;
        grain.gainNode.gain.setTargetAtTime(volume, now, 0.01);
        
        // Update panning
        const canvas = document.getElementById('canvas');
        const currentCanvasWidth = canvas ? canvas.width : 1200;
        const pan = (particle.x / currentCanvasWidth) * 2 - 1;
        grain.pannerNode.pan.setTargetAtTime(pan, now, 0.01);
    }
    
    // Stop and cleanup grain
    stopGrain(grain) {
        if (grain && grain.isPlaying) {
            try {
                grain.source.stop();
                grain.isPlaying = false;
            } catch (e) {
                // Grain may have already stopped
            }
        }
    }
    
    // Clean up all grains
    cleanup() {
        for (const grain of this.particleGrains.values()) {
            this.stopGrain(grain);
        }
        this.particleGrains.clear();
        this.alternatingGrainStates.clear();
    }
}



// Enhanced Granular Synthesizer Class with particle-grain manager
class GranularSynth {
    constructor(speciesIndex, audioContext, masterGain) {
        this.speciesIndex = speciesIndex;
        this.audioContext = audioContext;
        this.masterGain = masterGain;
        
        // Audio graph (only create if audioContext exists)
        if (audioContext && masterGain) {
            this.gainNode = audioContext.createGain();
            this.gainNode.connect(masterGain);
            this.gainNode.gain.value = 0.7;
        } else {
            this.gainNode = null;
        }
        
        // Sample buffer and selection
        this.audioBuffer = null;
        this.fileName = '';
        this.sampleStart = 0.0; // Start position in sample (0-1)
        this.sampleEnd = 1.0;   // End position in sample (0-1)
        
        // New particle-grain manager (replaces dual engine system)
        this.particleGrainManager = null;
        
        // Audio-visual size correlation factor (user adjustable)
        this.sizeCorrelationFactor = 1.0; // 1.0 = exact correlation
        
        // Velocity control parameters (user adjustable)
        this.velocityScale = 1.0; // Scale factor for speed-to-volume relationship (0.1x - 10.0x)
        this.volumeThreshold = 0.05; // Minimum volume threshold - grains below this are filtered out (0.0 - 0.5)
        
        // Legacy parameters (maintained for compatibility with existing UI)
        this.pitch = 0; // Semitones (0-24)
        this.detune = 0; // Cents (0-50, randomized per grain)
        this.fadeLength = 0.002; // Crossfade length (1ms-20ms)
        
        // State
        this.isMuted = false;
        this.volume = 0.7;
        this.activeGrains = 0;
        
        // Initialize particle-grain manager
        this.initializeParticleGrainManager();
        
        console.log(`🎵 Enhanced granular synth created for Species ${String.fromCharCode(65 + speciesIndex)}`);
    }
    
    initializeParticleGrainManager() {
        if (!this.audioContext || !this.gainNode) return;
        
        this.particleGrainManager = new ParticleGrainManager(this.speciesIndex, this.audioContext, this.gainNode, this);
        
        // Set audio buffer if we already have one
        if (this.audioBuffer) {
            this.particleGrainManager.setAudioBuffer(this.audioBuffer);
        }
        
        // Set size correlation factor
        this.particleGrainManager.setSizeCorrelationFactor(this.sizeCorrelationFactor);
    }
    
    // Connect audio graph when context becomes available
    connectAudioGraph(audioContext, masterGain) {
        this.audioContext = audioContext;
        this.masterGain = masterGain;
        
        if (!this.gainNode && audioContext && masterGain) {
            this.gainNode = audioContext.createGain();
            this.gainNode.connect(masterGain);
            this.gainNode.gain.value = this.volume || 0.7;
        }
        
        // Initialize particle grain manager with new context
        this.initializeParticleGrainManager();
    }
    
    // Load audio sample
    async loadSample(arrayBuffer) {
        try {
            // If no audio context yet, create a temporary one for display purposes
            if (!this.audioContext || this.audioContext.state === 'closed') {
                this.rawAudioData = arrayBuffer;
                this.fileName = 'Sample loaded (awaiting audio start)';
                
                // Create temporary audioContext just for decoding and display
                try {
                    const tempContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.audioBuffer = await tempContext.decodeAudioData(arrayBuffer.slice(0)); // Use copy of buffer
                    await tempContext.close(); // Clean up temporary context
                    console.log(`🎵 Sample decoded for display for Species ${String.fromCharCode(65 + this.speciesIndex)}: ${this.audioBuffer.duration.toFixed(2)}s`);
                } catch (tempError) {
                    console.warn('Could not decode for display:', tempError);
                }
                
                return true;
            }
            
            // Make sure audioContext is in good state before decoding
            if (this.audioContext.state === 'suspended') {
                console.warn('AudioContext suspended, storing sample for later decode');
                this.rawAudioData = arrayBuffer;
                this.fileName = 'Sample loaded (awaiting audio start)';
                return true;
            }
            
            // Decode immediately if audio context exists and is running
            this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            
            // Share audio buffer with particle grain manager
            if (this.particleGrainManager) this.particleGrainManager.setAudioBuffer(this.audioBuffer);
            
            console.log(`🎵 Sample loaded for Species ${String.fromCharCode(65 + this.speciesIndex)}: ${this.audioBuffer.duration.toFixed(2)}s`);
            return true;
        } catch (error) {
            console.error('Audio decode error:', error);
            return false;
        }
    }
    
    // Decode stored audio data when audio context becomes available
    async decodeStoredAudio() {
        if (this.rawAudioData && this.audioContext) {
            try {
                // If we already have an audioBuffer from temp decode, re-decode with proper audioContext
                // This ensures the audioBuffer is compatible with the main audio system
                this.audioBuffer = await this.audioContext.decodeAudioData(this.rawAudioData);
                this.rawAudioData = null; // Clear raw data after decoding
                
                // Share audio buffer with particle grain manager
                if (this.particleGrainManager) this.particleGrainManager.setAudioBuffer(this.audioBuffer);
                
                console.log(`🎵 Re-decoded sample for audio system for Species ${String.fromCharCode(65 + this.speciesIndex)}: ${this.audioBuffer.duration.toFixed(2)}s`);
                return true;
            } catch (error) {
                console.error('Stored audio decode error:', error);
                return false;
            }
        }
        return false;
    }
    
    // Legacy method - now handled automatically by velocity-based direction detection
    setTriggerMode(mode) {
        console.log(`🔧 setTriggerMode called for Species ${this.speciesIndex}: ${mode} - now handled automatically by ParticleGrainManager`);
        // No longer needed - ParticleGrainManager handles direction automatically based on velocity
    }
    
    // Get current settings for UI (simplified for new system)
    getSettings() {
        return {
            sizeCorrelationFactor: this.sizeCorrelationFactor,
            volume: this.volume,
            isMuted: this.isMuted,
            velocityThreshold: this.particleGrainManager ? this.particleGrainManager.velocityThreshold : 0.1,
            activeGrains: this.activeGrains
        };
    }
    
    // Update settings (simplified for new system)
    updateSettings(settings) {
        if (settings.sizeCorrelationFactor !== undefined) {
            this.setSizeCorrelationFactor(settings.sizeCorrelationFactor);
        }
        if (settings.velocityThreshold !== undefined && this.particleGrainManager) {
            this.particleGrainManager.velocityThreshold = settings.velocityThreshold;
            console.log(`🎯 Velocity threshold updated to: ${settings.velocityThreshold}`);
        }
        if (settings.volume !== undefined) {
            this.setVolume(settings.volume);
        }
        if (settings.isMuted !== undefined) {
            this.setMute(settings.isMuted);
        }
    }
    
    // Legacy method - now handled automatically by ParticleGrainManager
    createGrain(particle) {
        // No longer needed - ParticleGrainManager handles grain creation automatically
        console.log(`🔧 createGrain called for Species ${this.speciesIndex} - now handled automatically by ParticleGrainManager`);
        return null;
    }
    
    // Legacy method - now handled automatically by ParticleGrainManager
    removeGrain(grain) {
        // No longer needed - ParticleGrainManager handles grain cleanup automatically
        console.log(`🔧 removeGrain called for Species ${this.speciesIndex} - now handled automatically by ParticleGrainManager`);
    }
    
    // Update grain parameters based on particle movement
    updateGrain(grain, particle) {
        if (!grain.isPlaying) return;
        
        const now = this.audioContext.currentTime;
        // Get canvas dimensions reliably
        const canvas = document.getElementById('canvas');
        const currentCanvasHeight = canvas ? canvas.height : (typeof canvasHeight !== 'undefined' ? canvasHeight : 800);
        const currentCanvasWidth = canvas ? canvas.width : (typeof canvasWidth !== 'undefined' ? canvasWidth : 1200);
        
        const { frequency, bandwidth } = this.calculateFrequencyAndBandwidth(particle.y / currentCanvasHeight, particle.size);
        // Use cached velocity magnitude for performance optimization
        const velocity = particle.velocityMagnitude || Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        const volume = Math.min(1, velocity / MAX_SPEED) * this.volume;
        const pan = (particle.x / currentCanvasWidth) * 2 - 1; // -1 (left) to +1 (right)
        
        // Update frequency and bandwidth smoothly
        grain.filterNode.frequency.setTargetAtTime(frequency, now, 0.01);
        grain.filterNode.Q.setTargetAtTime(bandwidth, now, 0.01);
        
        // Update volume based on velocity
        grain.gainNode.gain.setTargetAtTime(volume, now, 0.01);
        
        // Update panning based on X position
        grain.pannerNode.pan.setTargetAtTime(pan, now, 0.01);
    }
    
    // Calculate frequency and bandwidth from Y position and particle size (narrower bands for smaller particles)
    calculateFrequencyAndBandwidth(normalizedY, particleSize) {
        // Invert Y (top = high frequency, bottom = low frequency)
        const invY = 1 - normalizedY;
        
        // Logarithmic scaling for musical frequency perception
        const logLow = Math.log(frequencyRange.low);
        const logHigh = Math.log(frequencyRange.high);
        const logFreq = logLow + (invY * (logHigh - logLow));
        const frequency = Math.exp(logFreq);
        
        // Map particle size to filter bandwidth - REVERSED: smaller particles = narrower bands
        const minSize = 2; // Minimum particle size
        const maxSize = 10; // Maximum particle size
        const normalizedSize = Math.max(0, Math.min(1, (particleSize - minSize) / (maxSize - minSize)));
        
        // Smaller particles = higher Q (narrower band), larger particles = lower Q (wider band)
        // Adjusted for narrower base frequency at size 2.0
        const minQ = 1.0; // Wide bandwidth for large particles
        const maxQ = 12.0; // Very narrow bandwidth for small particles (size 2.0)
        const bandwidth = maxQ - (normalizedSize * (maxQ - minQ));
        
        return { frequency, bandwidth };
    }
    
    // Map trail length to grain duration - direct mapping to 2ms-200ms range
    mapTrailLengthToGrainDuration(particle) {
        const speciesTrailLength = (typeof speciesTrailLengths !== 'undefined' ? speciesTrailLengths[particle.species] : null) || 0.5;
        
        const minDuration = 0.002; // 2ms
        const maxDuration = 0.2;   // 200ms
        
        // Direct linear mapping of species trail length (0-1) to grain duration (2ms-200ms)
        return minDuration + (speciesTrailLength * (maxDuration - minDuration));
    }
    
    // Update all grains for this species (now uses engine system)
    update(particles) {
        if (!this.particleGrainManager || this.isMuted || !isAudioEnabled) {
            this.activeGrains = 0;
            return;
        }
        
        // [REMOVED] Verbose debug logging
        
        // Update particle grain manager
        this.particleGrainManager.update(particles);
        this.activeGrains = this.particleGrainManager.particleGrains.size;
    }
    
    // Set volume
    setVolume(volume) {
        this.volume = Math.max(0, Math.min(1, volume));
        this.gainNode.gain.setTargetAtTime(this.isMuted ? 0 : this.volume, this.audioContext.currentTime, 0.01);
    }
    
    // Mute/unmute
    setMute(muted) {
        this.isMuted = muted;
        this.gainNode.gain.setTargetAtTime(muted ? 0 : this.volume, this.audioContext.currentTime, 0.01);
    }
    
    // Set audio-visual size correlation factor (0.1x to 5.0x)
    setSizeCorrelationFactor(factor) {
        this.sizeCorrelationFactor = Math.max(0.1, Math.min(5.0, factor));
        if (this.particleGrainManager) {
            this.particleGrainManager.setSizeCorrelationFactor(this.sizeCorrelationFactor);
        }
        console.log(`🎵 Species ${String.fromCharCode(65 + this.speciesIndex)} size correlation factor: ${this.sizeCorrelationFactor.toFixed(1)}x`);
    }
    
    // Set velocity scale factor (0.1x to 10.0x)
    setVelocityScale(scale) {
        this.velocityScale = Math.max(0.1, Math.min(10.0, scale));
        if (this.particleGrainManager) {
            this.particleGrainManager.setVelocityScale(this.velocityScale);
        }
        console.log(`🎵 Species ${String.fromCharCode(65 + this.speciesIndex)} velocity scale: ${this.velocityScale.toFixed(1)}x`);
    }
    
    // Set volume threshold for grain filtering (0.0 to 0.5)
    setVolumeThreshold(threshold) {
        this.volumeThreshold = Math.max(0.0, Math.min(0.5, threshold));
        if (this.particleGrainManager) {
            this.particleGrainManager.setVolumeThreshold(this.volumeThreshold);
        }
        console.log(`🎵 Species ${String.fromCharCode(65 + this.speciesIndex)} volume threshold: ${this.volumeThreshold.toFixed(2)}`);
    }
    
    // Set loop mode
    setLoopMode(mode) {
        this.loopMode = mode;
        this.alternateDirection = 1; // Reset alternate direction
        console.log(`🎵 Species ${String.fromCharCode(65 + this.speciesIndex)} loop mode: ${mode}`);
    }
    
    // Stop all grains
    stopAll() {
        if (this.particleGrainManager) {
            this.particleGrainManager.cleanup();
        }
        console.log(`🔇 All grains stopped for Species ${this.speciesIndex}`);
    }
    
    // New system compatibility - expose grains info
    get grains() {
        return this.particleGrainManager ? Array.from(this.particleGrainManager.particleGrains.values()) : [];
    }
    
    // New system compatibility - expose maxGrains property  
    get maxGrains() {
        return this.particleGrainManager ? this.particleGrainManager.maxGrains : 32;
    }
}

// Initialize Audio System
async function initAudioSystem() {
    // Prevent multiple initializations
    if (isAudioEnabled && audioContext && audioContext.state === 'running') {
        console.log('🎵 Audio system already initialized');
        return true;
    }
    
    try {
        // Only create new context if one doesn't exist or is closed
        if (!audioContext || audioContext.state === 'closed') {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } else if (audioContext.state === 'suspended') {
            await audioContext.resume();
        }
        
        // Create master audio graph only if needed
        if (!masterGainNode || !compressorNode) {
            masterGainNode = audioContext.createGain();
            compressorNode = audioContext.createDynamicsCompressor();
            
            // Setup audio chain: species synths -> master gain -> compressor -> destination
            masterGainNode.connect(compressorNode);
            compressorNode.connect(audioContext.destination);
        }
        
        // Configure compressor for safety
        compressorNode.threshold.value = -20;
        compressorNode.knee.value = 10;
        compressorNode.ratio.value = 8;
        compressorNode.attack.value = 0.001;
        compressorNode.release.value = 0.1;
        
        // Set master volume
        masterGainNode.gain.value = masterVolume;
        
        // Connect existing synths to audio context and decode any stored audio
        for (let i = 0; i < speciesAudioSynths.length; i++) {
            if (speciesAudioSynths[i]) {
                speciesAudioSynths[i].connectAudioGraph(audioContext, masterGainNode);
                // Decode any stored audio data
                await speciesAudioSynths[i].decodeStoredAudio();
            }
        }
        
        // Update waveforms for any newly decoded audio
        for (let i = 0; i < speciesAudioSynths.length; i++) {
            const synth = speciesAudioSynths[i];
            if (synth && synth.audioBuffer) {
                const waveformCanvas = document.getElementById(`waveform${i}`);
                if (waveformCanvas) {
                    const currentSpeciesColors = (typeof speciesColors !== 'undefined') ? speciesColors : [[1,0,0],[0,0,1]];
                    drawWaveform(synth.audioBuffer, waveformCanvas, currentSpeciesColors[i] || [1,1,1], i);
                }
                
                // Update file name
                const fileNameElement = document.getElementById(`fileName${i}`);
                if (fileNameElement && synth.fileName) {
                    fileNameElement.textContent = synth.fileName;
                }
            }
        }
        
        isAudioEnabled = true;
        updateAudioStatus('Ready');
        
        console.log('🎵 Audio system initialized successfully');
        return true;
        
    } catch (error) {
        console.error('Audio initialization failed:', error);
        updateAudioStatus('Failed');
        return false;
    }
}

// Initialize audio UI only (no audio context required)
function initAudioUI() {
    speciesAudioSynths = [];
    
    // Create UI-only synths (no audioContext)
    for (let i = 0; i < maxSpecies; i++) {
        const synth = new GranularSynth(i, null, null);
        speciesAudioSynths.push(synth);
    }
    
    // Generate species audio UI
    createSpeciesAudioControls();
    
    // Note: Dial controls have custom drag handlers - setupDraggableNumbers() not needed for audio dials
    
    console.log('🎵 Audio UI initialized (controls ready, audio awaiting start)');
}

// Initialize species synthesizers (preserves existing audio buffers)
function initSpeciesSynths() {
    const existingData = [];
    
    // Preserve existing audio data
    for (let i = 0; i < speciesAudioSynths.length; i++) {
        if (speciesAudioSynths[i]) {
            existingData[i] = {
                audioBuffer: speciesAudioSynths[i].audioBuffer,
                fileName: speciesAudioSynths[i].fileName,
                volume: speciesAudioSynths[i].volume,
                isMuted: speciesAudioSynths[i].isMuted,
                loopMode: speciesAudioSynths[i].loopMode,
                sampleStart: speciesAudioSynths[i].sampleStart || 0.0,
                sampleEnd: speciesAudioSynths[i].sampleEnd || 1.0,
                pitch: speciesAudioSynths[i].pitch || 0,
                detune: speciesAudioSynths[i].detune || 0,
                fadeLength: speciesAudioSynths[i].fadeLength || 0.002
            };
        }
    }
    
    speciesAudioSynths = [];
    
    for (let i = 0; i < maxSpecies; i++) {
        const synth = new GranularSynth(i, audioContext, masterGainNode);
        
        // Restore existing data if available
        if (existingData[i]) {
            synth.audioBuffer = existingData[i].audioBuffer;
            synth.fileName = existingData[i].fileName || 'No Sample';
            synth.volume = existingData[i].volume;
            synth.isMuted = existingData[i].isMuted;
            synth.loopMode = existingData[i].loopMode;
            synth.sampleStart = existingData[i].sampleStart || 0.0;
            synth.sampleEnd = existingData[i].sampleEnd || 1.0;
            synth.pitch = existingData[i].pitch || 0;
            synth.detune = existingData[i].detune || 0;
            synth.fadeLength = existingData[i].fadeLength || 0.002;
            synth.alternateDirection = 1; // Reset alternate direction
        }
        
        speciesAudioSynths.push(synth);
    }
    
    // Generate species audio UI
    createSpeciesAudioControls();
    
    // Note: Dial controls have custom drag handlers - setupDraggableNumbers() not needed for audio dials
}

// Update audio system with particle data
function updateAudioSystem() {
    if (!isAudioEnabled || !audioContext || audioContext.state !== 'running') return;
    
    // Update each species synth with its particles
    for (let i = 0; i < speciesCount; i++) {
        if (speciesAudioSynths[i]) {
            speciesAudioSynths[i].update(particles);
        }
    }
    
    // Update UI indicators
    updateAudioUI();
}

// Update audio status display
function updateAudioStatus(status) {
    const statusElement = document.getElementById('audioStatus');
    if (statusElement) {
        statusElement.textContent = status;
        statusElement.style.color = status === 'Ready' ? '#4CAF50' : 
                                  status === 'Failed' ? '#ff4444' : '#888';
    }
}

// Audio control functions - defined globally for event handlers
function toggleSpeciesMute(speciesIndex) {
    if (!speciesAudioSynths[speciesIndex]) return;
    
    const synth = speciesAudioSynths[speciesIndex];
    synth.setMute(!synth.isMuted);
    
    // Update species tab status indicator
    if (typeof updateSpeciesTabInfo === 'function') {
        updateSpeciesTabInfo();
    }
}

function setSpeciesVolume(speciesIndex, volume) {
    if (!speciesAudioSynths[speciesIndex]) return;
    
    speciesAudioSynths[speciesIndex].setVolume(volume);
    
    const valueDisplay = document.getElementById(`speciesVolume${speciesIndex}-value`);
    if (valueDisplay) {
        valueDisplay.textContent = volume.toFixed(2);
    }
}

function setMasterVolume(volume) {
    masterVolume = volume;
    if (masterGainNode) {
        masterGainNode.gain.setTargetAtTime(isMasterMuted ? 0 : volume, audioContext.currentTime, 0.01);
    }
    
    const valueDisplay = document.getElementById('masterVolume-value');
    if (valueDisplay) {
        valueDisplay.textContent = volume.toFixed(2);
    }
}

function toggleMasterMute() {
    isMasterMuted = !isMasterMuted;
    if (masterGainNode) {
        masterGainNode.gain.setTargetAtTime(isMasterMuted ? 0 : masterVolume, audioContext.currentTime, 0.01);
    }
    
    const button = document.getElementById('masterMute');
    if (button) {
        button.textContent = isMasterMuted ? '🔇' : '🔊';
        button.classList.toggle('active', !isMasterMuted);
    }
}

function setFrequencyRange(low, high) {
    frequencyRange.low = low;
    frequencyRange.high = high;
    
    const lowDisplay = document.getElementById('freqLow-value');
    const highDisplay = document.getElementById('freqHigh-value');
    if (lowDisplay) lowDisplay.textContent = `${low}Hz`;
    if (highDisplay) highDisplay.textContent = `${high}Hz`;
}

function setGlobalVelocityGainCurve(curve) {
    globalVelocityGainCurve = curve;
    
    const valueDisplay = document.getElementById('velocityGainCurve-value');
    if (valueDisplay) {
        valueDisplay.textContent = curve.toFixed(1);
    }
}

function setGlobalVelocityThreshold(threshold) {
    globalVelocityThreshold = threshold;
    
    // Pre-calculate squared threshold for performance (MAX_SPEED = 3)
    const MAX_SPEED = 3;
    globalVelocityThresholdSquared = (threshold * MAX_SPEED) * (threshold * MAX_SPEED);
    
    const valueDisplay = document.getElementById('velocityThreshold-value');
    if (valueDisplay) {
        valueDisplay.textContent = threshold.toFixed(2);
    }
}

// New audio control functions
function setSpeciesPitch(speciesIndex, pitch) {
    if (!speciesAudioSynths[speciesIndex]) return;
    
    speciesAudioSynths[speciesIndex].pitch = pitch;
    
    const valueDisplay = document.getElementById(`speciesPitch${speciesIndex}-value`);
    if (valueDisplay) {
        valueDisplay.textContent = pitch >= 0 ? `+${pitch}st` : `${pitch}st`;
    }
}

function setSpeciesDetune(speciesIndex, detune) {
    if (!speciesAudioSynths[speciesIndex]) return;
    
    speciesAudioSynths[speciesIndex].detune = detune;
    
    const valueDisplay = document.getElementById(`speciesDetune${speciesIndex}-value`);
    if (valueDisplay) {
        valueDisplay.textContent = `${detune}¢`;
    }
}


function setSpeciesFadeLength(speciesIndex, fadeLength) {
    if (!speciesAudioSynths[speciesIndex]) return;
    
    speciesAudioSynths[speciesIndex].fadeLength = fadeLength;
    
    const valueDisplay = document.getElementById(`speciesFade${speciesIndex}-value`);
    if (valueDisplay) {
        valueDisplay.textContent = `${Math.round(fadeLength * 1000)}ms`;
    }
}

// Set species loop mode - defined globally for loop button handlers
function setSpeciesLoopMode(speciesIndex, mode) {
    if (!speciesAudioSynths[speciesIndex]) return;
    
    // Update the synth's loop mode
    speciesAudioSynths[speciesIndex].setLoopMode(mode);
    
    // Update UI to show selected mode
    const buttons = document.querySelectorAll(`[data-species="${speciesIndex}"][data-loop-mode]`);
    buttons.forEach(button => {
        button.classList.remove('active');
        if (button.dataset.loopMode === mode) {
            button.classList.add('active');
        }
    });
    
    console.log(`🎵 Species ${String.fromCharCode(65 + speciesIndex)} loop mode set to: ${mode}`);
}

// Load audio file for species - defined globally for file input handlers
async function loadAudioFile(event, speciesIndex) {
    const file = event.target.files[0];
    if (!file || !speciesAudioSynths[speciesIndex]) return;
    
    try {
        const arrayBuffer = await file.arrayBuffer();
        const success = await speciesAudioSynths[speciesIndex].loadSample(arrayBuffer);
        
        if (success) {
            // Update UI with actual file name
            const fileNameElement = document.getElementById(`fileName${speciesIndex}`);
            if (fileNameElement) {
                fileNameElement.textContent = file.name;
            }
            
            // Store the actual file name in the synth for proper display
            speciesAudioSynths[speciesIndex].fileName = file.name;
            
            // Update waveform if audioBuffer is available (should be available now even before Start Audio)
            const waveformCanvas = document.getElementById(`waveform${speciesIndex}`);
            if (waveformCanvas && speciesAudioSynths[speciesIndex].audioBuffer) {
                const currentSpeciesColors = (typeof speciesColors !== 'undefined') ? speciesColors : [[1,0,0],[0,0,1]];
                drawWaveform(speciesAudioSynths[speciesIndex].audioBuffer, waveformCanvas, currentSpeciesColors[speciesIndex] || [1,1,1], speciesIndex);
            }
            
            console.log(`🎵 Loaded audio file for Species ${String.fromCharCode(65 + speciesIndex)}: ${file.name}`);
        } else {
            alert('Failed to load audio file. Please try a different file.');
        }
    } catch (error) {
        console.error('File loading error:', error);
        alert('Error loading audio file.');
    }
}

// Waveform selection state
let waveformSelection = {
    isSelecting: false,
    speciesIndex: -1,
    startX: 0,
    currentX: 0,
    canvas: null
};

// Draw waveform visualization with selection overlay
function drawWaveform(audioBuffer, canvas, color, speciesIndex) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    ctx.clearRect(0, 0, width, height);
    
    if (!audioBuffer) return;
    
    const data = audioBuffer.getChannelData(0);
    const step = Math.ceil(data.length / width);
    const amp = height / 2;
    
    // Draw waveform
    ctx.strokeStyle = `rgb(${Math.round(color[0] * 255)}, ${Math.round(color[1] * 255)}, ${Math.round(color[2] * 255)})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    for (let i = 0; i < width; i++) {
        let min = 1.0;
        let max = -1.0;
        
        for (let j = 0; j < step; j++) {
            const datum = data[(i * step) + j];
            if (datum < min) min = datum;
            if (datum > max) max = datum;
        }
        
        ctx.moveTo(i, (1 + min) * amp);
        ctx.lineTo(i, (1 + max) * amp);
    }
    
    ctx.stroke();
    
    // Draw center line
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, amp);
    ctx.lineTo(width, amp);
    ctx.stroke();
    
    // Draw selection overlay if this species has selection data
    if (speciesAudioSynths[speciesIndex] && typeof speciesIndex !== 'undefined') {
        const synth = speciesAudioSynths[speciesIndex];
        if (synth.sampleStart !== 0 || synth.sampleEnd !== 1) {
            const startX = synth.sampleStart * width;
            const endX = synth.sampleEnd * width;
            const selectionWidth = endX - startX;
            
            // Draw selection rectangle
            ctx.fillStyle = `rgba(${Math.round(color[0] * 255)}, ${Math.round(color[1] * 255)}, ${Math.round(color[2] * 255)}, 0.3)`;
            ctx.fillRect(startX, 0, selectionWidth, height);
            
            // Draw selection borders
            ctx.strokeStyle = `rgb(${Math.round(color[0] * 255)}, ${Math.round(color[1] * 255)}, ${Math.round(color[2] * 255)})`;
            ctx.lineWidth = 2;
            ctx.strokeRect(startX, 0, selectionWidth, height);
        }
    }
    
    // Draw current selection if actively selecting on this canvas
    if (waveformSelection.isSelecting && waveformSelection.canvas === canvas) {
        const startX = Math.min(waveformSelection.startX, waveformSelection.currentX);
        const endX = Math.max(waveformSelection.startX, waveformSelection.currentX);
        const selectionWidth = endX - startX;
        
        // Draw active selection
        ctx.fillStyle = `rgba(${Math.round(color[0] * 255)}, ${Math.round(color[1] * 255)}, ${Math.round(color[2] * 255)}, 0.4)`;
        ctx.fillRect(startX, 0, selectionWidth, height);
        
        ctx.strokeStyle = `rgb(${Math.round(color[0] * 255)}, ${Math.round(color[1] * 255)}, ${Math.round(color[2] * 255)})`;
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(startX, 0, selectionWidth, height);
        ctx.setLineDash([]); // Reset line dash
    }
}

// Setup waveform selection handlers
function setupWaveformSelection(canvas, speciesIndex) {
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        
        waveformSelection.isSelecting = true;
        waveformSelection.speciesIndex = speciesIndex;
        waveformSelection.startX = x;
        waveformSelection.currentX = x;
        waveformSelection.canvas = canvas;
        
        e.preventDefault();
    });
    
    canvas.addEventListener('mousemove', (e) => {
        if (!waveformSelection.isSelecting || waveformSelection.canvas !== canvas) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        waveformSelection.currentX = Math.max(0, Math.min(canvas.width, x));
        
        // Redraw waveform with current selection
        if (speciesAudioSynths[speciesIndex] && speciesAudioSynths[speciesIndex].audioBuffer) {
            drawWaveform(speciesAudioSynths[speciesIndex].audioBuffer, canvas, (typeof speciesColors !== 'undefined' ? speciesColors[speciesIndex] : [1,1,1]), speciesIndex);
        }
        
        e.preventDefault();
    });
    
    canvas.addEventListener('mouseup', (e) => {
        if (!waveformSelection.isSelecting || waveformSelection.canvas !== canvas) return;
        
        const startX = Math.min(waveformSelection.startX, waveformSelection.currentX);
        const endX = Math.max(waveformSelection.startX, waveformSelection.currentX);
        const width = canvas.width;
        
        // Convert pixels to normalized positions (0-1)
        const startPos = Math.max(0, Math.min(1, startX / width));
        const endPos = Math.max(0, Math.min(1, endX / width));
        
        // Only update if there's a meaningful selection (at least 2% of the waveform)
        if (Math.abs(endPos - startPos) > 0.02) {
            const synth = speciesAudioSynths[speciesIndex];
            if (synth) {
                synth.sampleStart = startPos;
                synth.sampleEnd = endPos;
                console.log(`🎵 Species ${String.fromCharCode(65 + speciesIndex)} sample selection: ${(startPos * 100).toFixed(1)}% - ${(endPos * 100).toFixed(1)}%`);
            }
        } else {
            console.log(`⚠️ Selection too small for Species ${String.fromCharCode(65 + speciesIndex)}: ${(startPos * 100).toFixed(1)}% - ${(endPos * 100).toFixed(1)}% (${((endPos - startPos) * 100).toFixed(1)}% - minimum 2%)`);
        }
        
        // Reset selection state
        waveformSelection.isSelecting = false;
        waveformSelection.speciesIndex = -1;
        waveformSelection.canvas = null;
        
        // Final redraw
        if (speciesAudioSynths[speciesIndex] && speciesAudioSynths[speciesIndex].audioBuffer) {
            drawWaveform(speciesAudioSynths[speciesIndex].audioBuffer, canvas, (typeof speciesColors !== 'undefined' ? speciesColors[speciesIndex] : [1,1,1]), speciesIndex);
        }
        
        e.preventDefault();
    });
    
    // Handle mouse leaving the canvas
    canvas.addEventListener('mouseleave', () => {
        if (waveformSelection.isSelecting && waveformSelection.canvas === canvas) {
            // Cancel selection
            waveformSelection.isSelecting = false;
            waveformSelection.speciesIndex = -1;
            waveformSelection.canvas = null;
            
            // Redraw without selection
            if (speciesAudioSynths[speciesIndex] && speciesAudioSynths[speciesIndex].audioBuffer) {
                drawWaveform(speciesAudioSynths[speciesIndex].audioBuffer, canvas, (typeof speciesColors !== 'undefined' ? speciesColors[speciesIndex] : [1,1,1]), speciesIndex);
            }
        }
    });
    
    // Double-click to reset selection to full waveform
    canvas.addEventListener('dblclick', (e) => {
        const synth = speciesAudioSynths[speciesIndex];
        if (synth) {
            synth.sampleStart = 0.0;
            synth.sampleEnd = 1.0;
            console.log(`🎵 Species ${String.fromCharCode(65 + speciesIndex)} sample selection reset to full waveform`);
            
            // Redraw waveform
            if (synth.audioBuffer) {
                drawWaveform(synth.audioBuffer, canvas, (typeof speciesColors !== 'undefined' ? speciesColors[speciesIndex] : [1,1,1]), speciesIndex);
            }
        }
        e.preventDefault();
    });
    
    // Make canvas cursor indicate it's selectable
    canvas.style.cursor = 'crosshair';
}

// RGB to Hex conversion function - ensure it's defined before createSpeciesAudioControls
function rgbToHex(rgbArray) {
    const r = Math.round(rgbArray[0] * 255);
    const g = Math.round(rgbArray[1] * 255);
    const b = Math.round(rgbArray[2] * 255);
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

// ===== UI UTILITY FUNCTIONS =====
// Utility functions to reduce code duplication in UI generation

// Event listener cleanup tracking
const eventListenerCleanup = [];

function addEventListenerWithCleanup(element, event, handler) {
    element.addEventListener(event, handler);
    eventListenerCleanup.push({ element, event, handler });
}

function cleanupEventListeners() {
    eventListenerCleanup.forEach(({ element, event, handler }) => {
        element.removeEventListener(event, handler);
    });
    eventListenerCleanup.length = 0;
}

function createControlRow(labelText, control, valueDisplay) {
    const row = document.createElement('div');
    row.className = 'audio-controls-row';
    
    const label = document.createElement('span');
    label.textContent = labelText;
    label.style.minWidth = '50px';
    label.style.fontSize = '12px';
    
    row.appendChild(label);
    row.appendChild(control);
    if (valueDisplay) row.appendChild(valueDisplay);
    
    return row;
}

function createSlider(id, min, max, step, defaultValue, changeHandler) {
    const slider = document.createElement('input');
    slider.type = 'range';
    slider.className = 'slider';
    slider.id = id;
    slider.min = min;
    slider.max = max;
    slider.step = step;
    slider.value = defaultValue.toString();
    slider.style.flex = '1';
    slider.addEventListener('input', changeHandler);
    return slider;
}

function createValueDisplay(id, initialText) {
    const display = document.createElement('span');
    display.className = 'value-display';
    display.id = id;
    display.textContent = initialText;
    return display;
}

function createControlGroup(title, className = 'audio-controls-group') {
    const group = document.createElement('div');
    group.className = className;
    
    if (title) {
        const titleElement = document.createElement('h4');
        titleElement.textContent = title;
        group.appendChild(titleElement);
    }
    
    return group;
}

// ===== UI GENERATION (Audio UI only) =====
// Global variable to track currently selected species for audio controls
let selectedSpeciesForAudio = 0;

// Species selector is now handled by the species tab system in main HTML

// Create species audio controls UI - defined globally (now shows single species)
function createSpeciesAudioControls() {
    const container = document.getElementById('speciesAudioControls');
    if (!container) return;
    
    container.innerHTML = '';
    
    // Use window variables if available, fallback to defaults
    const currentSpeciesCount = (typeof speciesCount !== 'undefined') ? speciesCount : 2;
    const currentSpeciesColors = (typeof speciesColors !== 'undefined') ? speciesColors : [[1,0,0],[0,0,1]];
    const currentParticleCounts = (typeof particleCounts !== 'undefined') ? particleCounts : [200, 200];
    const currentParticleSizes = (typeof particleSizes !== 'undefined') ? particleSizes : [4, 4];
    const currentSpeciesTrailLengths = (typeof speciesTrailLengths !== 'undefined') ? speciesTrailLengths : [0.75, 0.65];
    
    // Only create panel for selected species
    const i = selectedSpeciesForAudio;
    if (i >= currentSpeciesCount) {
        selectedSpeciesForAudio = 0;
        return;
    }
    
    const synth = speciesAudioSynths[i];
    const panel = document.createElement('div');
    panel.className = 'species-audio-panel';
    
    // Add count/size/trail controls at top of panel
    const speciesParamsHeader = document.createElement('div');
    speciesParamsHeader.innerHTML = '<h4 style="margin: 0 0 10px 0; color: #ccc; font-size: 14px; border-bottom: 1px solid #333; padding-bottom: 5px;">Species Parameters</h4>';
    
    const speciesParamsGrid = document.createElement('div');
    speciesParamsGrid.className = 'species-params-grid';
    speciesParamsGrid.style.cssText = `
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
        margin-bottom: 15px;
        padding: 10px;
        background: rgba(255,255,255,0.05);
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.1);
    `;

    const speciesLabel = document.createElement('div');
    speciesLabel.className = 'species-label';
    speciesLabel.style.cssText = `
        grid-column: 1 / -1;
        color: ${rgbToHex(currentSpeciesColors[i] || [1,1,1])};
        font-weight: bold;
        font-size: 14px;
        text-align: center;
        margin-bottom: 8px;
        padding-bottom: 8px;
        border-bottom: 1px solid rgba(255,255,255,0.2);
    `;
    speciesLabel.textContent = `Species ${String.fromCharCode(65 + i)}`;

    // Helper function to create simple dial parameter
    const createDial = (labelText, value, id) => {
        const group = document.createElement('div');
        group.className = 'param-dial';
        group.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.1);
        `;
        
        const label = document.createElement('span');
        label.className = 'param-label';
        label.style.cssText = `
            font-size: 11px;
            color: #ccc;
            margin-bottom: 6px;
            text-align: center;
            line-height: 1.2;
        `;
        label.textContent = labelText;
        
        // Create dial container
        const dialContainer = document.createElement('div');
        dialContainer.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            margin-bottom: 4px;
        `;
        
        // Create dial background (this will be the draggable element)
        const dialBg = document.createElement('div');
        dialBg.className = 'draggable-number audio-dial';
        dialBg.id = id;
        dialBg.style.cssText = `
            width: 40px;
            height: 40px;
            min-width: 40px;
            min-height: 40px;
            max-width: 40px;
            max-height: 40px;
            border-radius: 50%;
            background: #2a2a2a;
            border: 2px solid #444;
            position: relative;
            cursor: ns-resize;
            transition: border-color 0.2s;
            flex-shrink: 0;
        `;
        
        // Store the current value on the dial element (not as text content)
        // Clean value by removing any 'x' suffix before parsing
        const cleanValue = typeof value === 'string' ? value.replace('x', '') : value;
        dialBg.currentValue = parseFloat(cleanValue);
        
        // Fallback to appropriate default if parsing failed
        if (isNaN(dialBg.currentValue)) {
            console.warn(`Invalid dial value: "${value}", using default as fallback`);
            // Use parameter-specific defaults
            if (id.includes('count')) {
                dialBg.currentValue = 200;
            } else if (id.includes('size')) {
                dialBg.currentValue = 4;
            } else if (id.includes('trail')) {
                dialBg.currentValue = 0.75;
            } else if (id.includes('correlation') || id.includes('velocity')) {
                dialBg.currentValue = 1.0;
            } else if (id.includes('threshold')) {
                dialBg.currentValue = 0.05;
            } else {
                dialBg.currentValue = 1.0;
            }
        }
        
        // Add hover effect to dial
        dialBg.addEventListener('mouseenter', () => {
            dialBg.style.borderColor = '#666';
        });
        dialBg.addEventListener('mouseleave', () => {
            dialBg.style.borderColor = '#444';
        });
        
        // Create dial indicator line
        const dialIndicator = document.createElement('div');
        dialIndicator.style.cssText = `
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 12px;
            background: #fff;
            border-radius: 1px;
            pointer-events: none;
        `;
        
        dialBg.appendChild(dialIndicator);
        dialContainer.appendChild(dialBg);
        
        // Value display (read-only)
        const valueEl = document.createElement('div');
        valueEl.className = 'dial-value-display';
        valueEl.style.cssText = `
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            text-align: center;
            min-width: 40px;
            pointer-events: none;
        `;
        valueEl.textContent = value;
        valueEl.id = id + '-display';
        
        // Custom drag functionality for this dial (after valueEl is created)
        let isDragging = false;
        let startY = 0;
        let startValue = 0;
        
        dialBg.addEventListener('mousedown', (e) => {
            isDragging = true;
            startY = e.clientY;
            startValue = dialBg.currentValue;
            dialBg.style.borderColor = '#888';
            e.preventDefault();
        });
        
        const handleMouseMove = (e) => {
            if (!isDragging) return;
            
            const deltaY = startY - e.clientY;
            let sensitivity = 0.1;
            let newValue = startValue;
            
            // Parameter-specific sensitivity and range handling
            if (id.includes('count')) {
                sensitivity = 0.5;
                newValue = Math.max(1, Math.min(1000, Math.round(startValue + deltaY * sensitivity)));
                const speciesIndex = parseInt(id.split('-')[1]);
                if (typeof particleCounts !== 'undefined') {
                    particleCounts[speciesIndex] = newValue;
                    if (typeof adjustParticleCounts === 'function') adjustParticleCounts();
                }
            } else if (id.includes('size')) {
                sensitivity = 0.1;
                newValue = Math.max(2, Math.min(20, Math.round((startValue + deltaY * sensitivity) * 10) / 10));
                const speciesIndex = parseInt(id.split('-')[1]);
                if (typeof particleSizes !== 'undefined') {
                    particleSizes[speciesIndex] = newValue;
                    if (typeof updateParticleSizes === 'function') updateParticleSizes();
                }
            } else if (id.includes('trail')) {
                sensitivity = 0.01;
                newValue = Math.max(0.0, Math.min(0.99, Math.round((startValue + deltaY * sensitivity) * 100) / 100));
                const speciesIndex = parseInt(id.split('-')[1]);
                if (typeof speciesTrailLengths !== 'undefined') {
                    speciesTrailLengths[speciesIndex] = newValue;
                    if (newValue <= 0.01 && typeof removeTrailParticlesForSpecies === 'function') {
                        removeTrailParticlesForSpecies(speciesIndex);
                    }
                }
            } else if (id.includes('correlation')) {
                sensitivity = 0.05;
                newValue = Math.max(0.1, Math.min(5.0, Math.round((startValue + deltaY * sensitivity) * 10) / 10));
                const speciesIndex = parseInt(id.split('-')[1]);
                if (speciesAudioSynths[speciesIndex]) {
                    speciesAudioSynths[speciesIndex].setSizeCorrelationFactor(newValue);
                }
            } else if (id.includes('velocity')) {
                sensitivity = 0.1;
                newValue = Math.max(0.1, Math.min(10.0, Math.round((startValue + deltaY * sensitivity) * 10) / 10));
                const speciesIndex = parseInt(id.split('-')[1]);
                if (speciesAudioSynths[speciesIndex]) {
                    speciesAudioSynths[speciesIndex].setVelocityScale(newValue);
                }
            } else if (id.includes('threshold')) {
                sensitivity = 0.01;
                newValue = Math.max(0.0, Math.min(0.5, Math.round((startValue + deltaY * sensitivity) * 100) / 100));
                const speciesIndex = parseInt(id.split('-')[1]);
                if (speciesAudioSynths[speciesIndex]) {
                    speciesAudioSynths[speciesIndex].setVolumeThreshold(newValue);
                }
            }
            
            // Update stored value and display
            dialBg.currentValue = newValue;
            if (id.includes('trail')) {
                valueEl.textContent = newValue.toFixed(2);
            } else if (id.includes('correlation') || id.includes('velocity')) {
                valueEl.textContent = newValue.toFixed(1) + 'x';
            } else if (id.includes('threshold')) {
                valueEl.textContent = newValue.toFixed(2);
            } else {
                valueEl.textContent = newValue;
            }
        };
        
        const handleMouseUp = () => {
            if (isDragging) {
                isDragging = false;
                dialBg.style.borderColor = '#444';
            }
        };
        
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        
        group.appendChild(label);
        group.appendChild(dialContainer);
        group.appendChild(valueEl);
        
        return group;
    };

    // Create all parameter dials
    const countGroup = createDial('Count', currentParticleCounts[i] || 200, `count-${i}`);
    const sizeGroup = createDial('Size', currentParticleSizes[i] || 4, `size-${i}`);
    const trailGroup = createDial('Trail', (currentSpeciesTrailLengths[i] || 0.75).toFixed(2), `trail-${i}`);
    const correlationGroup = createDial('Audio X Visual Scaling', (synth && synth.sizeCorrelationFactor ? synth.sizeCorrelationFactor.toFixed(1) + 'x' : '1.0x'), `correlation-${i}`);
    correlationGroup.title = 'Audio-Visual Size Correlation (0.1x - 5.0x)';
    const velocityGroup = createDial('Velocity Multiplier', (synth && synth.velocityScale ? synth.velocityScale.toFixed(1) + 'x' : '1.0x'), `velocity-${i}`);
    velocityGroup.title = 'Speed-to-Volume Scale (0.1x - 10.0x)';
    const thresholdGroup = createDial('Audio Grain Filter', (synth && synth.volumeThreshold !== undefined ? synth.volumeThreshold.toFixed(2) : '0.05'), `threshold-${i}`);
    thresholdGroup.title = 'Volume Filter Threshold (0.00 - 0.50)';

    speciesParamsGrid.appendChild(speciesLabel);
    speciesParamsGrid.appendChild(countGroup);
    speciesParamsGrid.appendChild(sizeGroup);
    speciesParamsGrid.appendChild(trailGroup);
    speciesParamsGrid.appendChild(correlationGroup);
    speciesParamsGrid.appendChild(velocityGroup);
    speciesParamsGrid.appendChild(thresholdGroup);
    
    const header = document.createElement('div');
    header.className = 'species-audio-header';
    header.innerHTML = '<h4 style="margin: 0 0 10px 0; color: #ccc; font-size: 14px; border-bottom: 1px solid #333; padding-bottom: 5px;">Audio Controls</h4>';
    
    const title = document.createElement('div');
    title.className = 'species-audio-title';
    title.style.color = rgbToHex(currentSpeciesColors[i] || [1,1,1]);
    title.textContent = `Species ${String.fromCharCode(65 + i)}`;
    
    header.appendChild(title);
    
    // File controls
    const fileControls = document.createElement('div');
    fileControls.className = 'audio-file-controls';
    
    const fileWrapper = document.createElement('div');
    fileWrapper.className = 'file-input-wrapper';
    
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.id = `audioFile${i}`;
    fileInput.accept = '.wav,.mp3,.m4a,.ogg';
    fileInput.addEventListener('change', (e) => loadAudioFile(e, i));
    
    const fileLabel = document.createElement('label');
    fileLabel.className = 'file-input-label';
    fileLabel.htmlFor = `audioFile${i}`;
    fileLabel.textContent = '📁 Load Sample';
    
    const fileName = document.createElement('div');
    fileName.className = 'file-name';
    fileName.id = `fileName${i}`;
    fileName.textContent = (synth && synth.fileName) || 'No Sample';
    
    fileWrapper.appendChild(fileInput);
    fileWrapper.appendChild(fileLabel);
    fileControls.appendChild(fileWrapper);
    fileControls.appendChild(fileName);
    
    // Waveform display
    const waveformContainer = document.createElement('div');
    waveformContainer.className = 'waveform-container';
    
    const waveformCanvas = document.createElement('canvas');
    waveformCanvas.className = 'waveform-canvas';
    waveformCanvas.id = `waveform${i}`;
    waveformCanvas.width = 280;
    waveformCanvas.height = 40;
    
    waveformContainer.appendChild(waveformCanvas);
    
    // Setup waveform selection handlers
    setupWaveformSelection(waveformCanvas, i);
    
    // Audio Direction Status Display (automatic based on particle velocity)
    const audioDirectionDisplay = document.createElement('div');
    audioDirectionDisplay.className = 'audio-direction-display';
    audioDirectionDisplay.innerHTML = `
        <h4 style="margin: 0 0 10px 0; color: #ccc; font-size: 14px;">Audio Direction</h4>
        <div style="font-size: 12px; color: #aaa; line-height: 1.4;">
            <div>🎵 <strong>Automatic</strong> - based on particle movement:</div>
            <div style="margin-top: 5px; padding-left: 10px;">
                <div>→ Moving right: Forward playback</div>
                <div>← Moving left: Reverse playback</div>
                <div>↕ Vertical/stationary: Alternating</div>
            </div>
        </div>
    `;
    
    // Volume control
    const currentVolume = (synth && typeof synth.volume !== 'undefined') ? synth.volume : 0.7;
    const volumeSlider = createSlider(`speciesVolume${i}`, '0', '1', '0.05', currentVolume, (e) => setSpeciesVolume(i, parseFloat(e.target.value)));
    const volumeValue = createValueDisplay(`speciesVolume${i}-value`, currentVolume.toFixed(2));
    const volumeRow = createControlRow('Volume:', volumeSlider, volumeValue);
    
    // Legacy mode panels removed - now using automatic direction detection based on particle velocity
    // No mode-specific panels needed since direction is automatic
    
    // Pitch control
    const currentPitch = (synth && typeof synth.pitch !== 'undefined') ? synth.pitch : 0;
    const pitchSlider = createSlider(`speciesPitch${i}`, '-12', '12', '1', currentPitch, (e) => setSpeciesPitch(i, parseInt(e.target.value)));
    const pitchValue = createValueDisplay(`speciesPitch${i}-value`, currentPitch >= 0 ? `+${currentPitch}st` : `${currentPitch}st`);
    const pitchRow = createControlRow('Pitch:', pitchSlider, pitchValue);
    
    // Detune control
    const currentDetune = (synth && typeof synth.detune !== 'undefined') ? synth.detune : 0;
    const detuneSlider = createSlider(`speciesDetune${i}`, '0', '50', '1', currentDetune, (e) => setSpeciesDetune(i, parseInt(e.target.value)));
    const detuneValue = createValueDisplay(`speciesDetune${i}-value`, `${currentDetune}¢`);
    const detuneRow = createControlRow('Detune:', detuneSlider, detuneValue);
    
    // Fade Length control
    const currentFade = (synth && typeof synth.fadeLength !== 'undefined') ? synth.fadeLength : 0.002;
    const fadeSlider = createSlider(`speciesFade${i}`, '0.001', '0.02', '0.001', currentFade, (e) => setSpeciesFadeLength(i, parseFloat(e.target.value)));
    const fadeValue = createValueDisplay(`speciesFade${i}-value`, `${Math.round(currentFade * 1000)}ms`);
    const fadeRow = createControlRow('Fade:', fadeSlider, fadeValue);
    
    // Activity indicators
    const activityRow = document.createElement('div');
    activityRow.className = 'audio-controls-row';
    
    const activityLabel = document.createElement('span');
    activityLabel.textContent = 'Grains:';
    activityLabel.style.minWidth = '50px';
    activityLabel.style.fontSize = '12px';
    
    const grainActivity = document.createElement('div');
    grainActivity.className = 'grain-activity';
    grainActivity.id = `grainActivity${i}`;
    
    // Create grain indicators
    for (let j = 0; j < 10; j++) {
        const indicator = document.createElement('div');
        indicator.className = 'grain-indicator';
        grainActivity.appendChild(indicator);
    }
    
    const audioMeter = document.createElement('div');
    audioMeter.className = 'audio-meter';
    
    const meterBar = document.createElement('div');
    meterBar.className = 'meter-bar';
    
    const meterFill = document.createElement('div');
    meterFill.className = 'meter-fill';
    meterFill.id = `meterFill${i}`;
    
    meterBar.appendChild(meterFill);
    audioMeter.appendChild(meterBar);
    
    const grainCount = document.createElement('span');
    grainCount.id = `grainCount${i}`;
    grainCount.textContent = '0/50';
    grainCount.style.fontSize = '11px';
    grainCount.style.color = '#888';
    
    audioMeter.appendChild(grainCount);
    
    activityRow.appendChild(activityLabel);
    activityRow.appendChild(grainActivity);
    activityRow.appendChild(audioMeter);
    
    // Gain reduction meter removed - too confusing for users
    
    // Assemble panel
    panel.appendChild(speciesParamsHeader);
    panel.appendChild(speciesParamsGrid);
    panel.appendChild(header);
    panel.appendChild(fileControls);
    panel.appendChild(waveformContainer);
    panel.appendChild(audioDirectionDisplay);
    panel.appendChild(volumeRow);
    panel.appendChild(pitchRow);
    panel.appendChild(detuneRow);
    panel.appendChild(fadeRow);
    panel.appendChild(activityRow);
    
    container.appendChild(panel);
    
    // Draw waveform if audio buffer exists
    if (synth && synth.audioBuffer) {
        drawWaveform(synth.audioBuffer, waveformCanvas, currentSpeciesColors[i] || [1,1,1], i);
    }
    
    console.log('🎛️ Audio controls initialized with dial interface');
}

// Legacy function - trigger modes no longer needed (now automatic based on velocity)
// [REMOVED] Legacy setSpeciesTriggerMode function - automatic direction detection
function setSpeciesTriggerMode(speciesIndex, mode) {
    console.log(`🎮 setSpeciesTriggerMode called: Species ${speciesIndex}, Mode: ${mode} - now handled automatically by ParticleGrainManager`);
    // No longer needed - direction is automatic based on particle velocity
    
    console.log(`🎵 Species ${String.fromCharCode(65 + speciesIndex)} trigger mode set to: ${mode}`);
}

// Update engine parameter
// [REMOVED] Legacy updateEngineParameter function - parameters now controlled by dials
function updateEngineParameter(speciesIndex, parameter, value) {
    if (!speciesAudioSynths[speciesIndex]) return;
    
    const synth = speciesAudioSynths[speciesIndex];
    const settings = {};
    settings[parameter] = value;
    synth.updateEngineSettings(settings);
    
    // Update UI display
    const valueElement = document.getElementById(`species${parameter.charAt(0).toUpperCase() + parameter.slice(1)}${speciesIndex}-value`);
    if (valueElement) {
        if (parameter === 'ratio') {
            valueElement.textContent = `${value.toFixed(1)}:1`;
        } else {
            valueElement.textContent = value.toFixed(2);
        }
    }
}

// Legacy function - audio mode UI no longer needed (automatic direction detection)
// [REMOVED] Legacy updateAudioModeUI function - no longer needed
function updateAudioModeUI(speciesIndex) {
    console.log(`🎮 updateAudioModeUI called for species ${speciesIndex} - no longer needed with automatic direction detection`);
    // No UI updates needed - direction is automatic based on particle velocity
}


// Species velocity/collision tracking for visualization
let speciesActivityLevels = new Array(8).fill(0);

// Update collision matrix
function updateCollisionMatrix(speciesIndex, triggerSpecies, enabled) {
    if (!speciesAudioSynths[speciesIndex] || !speciesAudioSynths[speciesIndex].collisionEngine) return;
    
    const engine = speciesAudioSynths[speciesIndex].collisionEngine;
    engine.collisionSpeciesMatrix[triggerSpecies] = enabled;
    
    console.log(`🎵 Species ${String.fromCharCode(65 + speciesIndex)} collision trigger from ${String.fromCharCode(65 + triggerSpecies)}: ${enabled}`);
}

// Update audio UI indicators - defined globally
function updateAudioUI() {
    const currentSpeciesCount = (typeof speciesCount !== 'undefined') ? speciesCount : 2;
    for (let i = 0; i < currentSpeciesCount; i++) {
        if (!speciesAudioSynths[i]) continue;
        
        const synth = speciesAudioSynths[i];
        const grainCount = synth.activeGrains;
        
        // Update grain count
        const grainCountElement = document.getElementById(`grainCount${i}`);
        if (grainCountElement) {
            grainCountElement.textContent = `${grainCount}/${synth.maxGrains}`;
        }
        
        // Update grain activity indicators
        const grainActivity = document.getElementById(`grainActivity${i}`);
        if (grainActivity) {
            const indicators = grainActivity.children;
            for (let j = 0; j < indicators.length; j++) {
                indicators[j].classList.toggle('active', j < Math.ceil(grainCount / 5));
            }
        }
        
        // Update audio level meter
        const meterFill = document.getElementById(`meterFill${i}`);
        if (meterFill) {
            const level = Math.min(100, (grainCount / synth.maxGrains) * 100);
            meterFill.style.width = `${level}%`;
        }
        
        // Update gain reduction meter
        const gainReductionFill = document.getElementById(`gainReduction${i}`);
        const gainReductionValue = document.getElementById(`gainReduction${i}-value`);
        if (gainReductionFill && gainReductionValue && synth.currentEngine) {
            const gainReduction = synth.currentEngine.gainReduction || 0;
            const reductionPercent = Math.min(100, gainReduction * 100);
            gainReductionFill.style.width = `${reductionPercent}%`;
            gainReductionValue.textContent = `${(gainReduction * -20).toFixed(1)}dB`; // Convert to dB
        }
    }
}
        
        // ===== PHYSICS CORE =====
        // Particle simulation, spatial optimization, and trail system

// ===== SPATIAL GRID SYSTEM =====
// Spatial Grid Class for O(N) force calculation optimization
class SpatialGrid {
    constructor(canvasWidth, canvasHeight, cellSize) {
        this.canvasWidth = canvasWidth;
        this.canvasHeight = canvasHeight;
        this.cellSize = cellSize;
        
        // Calculate grid dimensions
        this.gridWidth = Math.ceil(canvasWidth / cellSize);
        this.gridHeight = Math.ceil(canvasHeight / cellSize);
        
        // Create 2D grid array - each cell contains array of particles
        this.grid = [];
        for (let i = 0; i < this.gridWidth * this.gridHeight; i++) {
            this.grid[i] = [];
        }
        
        console.log(`Spatial Grid: ${this.gridWidth}x${this.gridHeight} cells, cell size: ${cellSize}`);
    }
    
    // Convert world coordinates to grid coordinates
    worldToGrid(x, y) {
        // Handle toroidal wrapping
        x = ((x % this.canvasWidth) + this.canvasWidth) % this.canvasWidth;
        y = ((y % this.canvasHeight) + this.canvasHeight) % this.canvasHeight;
        
        const gridX = Math.floor(x / this.cellSize);
        const gridY = Math.floor(y / this.cellSize);
        
        return {
            x: Math.max(0, Math.min(this.gridWidth - 1, gridX)),
            y: Math.max(0, Math.min(this.gridHeight - 1, gridY))
        };
    }
    
    // Convert grid coordinates to linear index
    gridToIndex(gridX, gridY) {
        return gridY * this.gridWidth + gridX;
    }
    
    // Clear all grid cells
    clear() {
        for (let i = 0; i < this.grid.length; i++) {
            this.grid[i].length = 0; // Fast array clear
        }
    }
    
    // Add particle to appropriate grid cell
    insertParticle(particle) {
        const gridPos = this.worldToGrid(particle.x, particle.y);
        const index = this.gridToIndex(gridPos.x, gridPos.y);
        this.grid[index].push(particle);
    }
    
    // Get all particles in neighboring cells (including current cell)
    // Returns particles that could potentially interact with a particle at (x, y)
    getNearbyParticles(x, y) {
        const centerGrid = this.worldToGrid(x, y);
        const nearbyParticles = [];
        
        // Check 3x3 neighborhood (including center cell)
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                let gridX = centerGrid.x + dx;
                let gridY = centerGrid.y + dy;
                
                // Handle toroidal wrapping for grid coordinates
                gridX = ((gridX % this.gridWidth) + this.gridWidth) % this.gridWidth;
                gridY = ((gridY % this.gridHeight) + this.gridHeight) % this.gridHeight;
                
                const index = this.gridToIndex(gridX, gridY);
                
                // Add all particles from this cell
                const cell = this.grid[index];
                for (let i = 0; i < cell.length; i++) {
                    nearbyParticles.push(cell[i]);
                }
            }
        }
        
        return nearbyParticles;
    }
    
    // Update grid cell size (when force radius changes)
    updateCellSize(newCellSize) {
        this.cellSize = newCellSize;
        this.gridWidth = Math.ceil(this.canvasWidth / newCellSize);
        this.gridHeight = Math.ceil(this.canvasHeight / newCellSize);
        
        // Recreate grid with new dimensions
        const newSize = this.gridWidth * this.gridHeight;
        if (this.grid.length !== newSize) {
            this.grid = [];
            for (let i = 0; i < newSize; i++) {
                this.grid[i] = [];
            }
            console.log(`Spatial Grid resized: ${this.gridWidth}x${this.gridHeight} cells`);
        }
    }
}


// ===== PARTICLE SYSTEM =====
// Particle class with motion blur trails
class Particle {
    constructor(species) {
        this.species = species;
        this.x = Math.random() * canvasWidth;
        this.y = Math.random() * canvasHeight;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2;
        this.updateSize();
        this.visualSize = this.size; // Initialize visual size
        
        // Set color based on species
        this.color = [...speciesColors[species]];
        
        // Audio fade state for smooth threshold transitions
        this.audioFadeState = 0.0; // 0.0 = silent, 1.0 = full volume
        this.wasAboveThreshold = false; // Track previous threshold state
        
        // Simple age tracking for particle sorting (temporal priority)
        this.age = 0;
        
        // Previous position tracking removed - trails now spawn every frame
        
        // Collision tracking for audio
        this.collisionEvents = []; // Array of recent collision events
        this.lastCollisionTime = 0;
        this.collisionForce = 0; // Current collision force magnitude
        
        // Cached velocity magnitude for performance optimization
        this.velocityMagnitude = 0;
        this.velocityMagnitudeSquared = 0;
    }

    updateSize() {
        this.size = particleSizes[this.species];
        
        // Calculate visual size (enhanced when size = 10)
        this.visualSize = this.size;
        if (this.size >= 10) {
            this.visualSize = this.size * 1.5; // 50% larger visual representation
        }
    }

    update() {
        // Store old position for movement detection
        const oldX = this.x;
        const oldY = this.y;
        
        // Calculate forces from nearby particles only (using spatial grid)
        let fx = 0;
        let fy = 0;

        // Get nearby particles from spatial grid instead of all particles
        const nearbyParticles = spatialGrid.getNearbyParticles(this.x, this.y);

        for (let i = 0; i < nearbyParticles.length; i++) {
            const other = nearbyParticles[i];
            if (other === this) continue;

            // Calculate distance with toroidal wrapping (if enabled)
            let dx = other.x - this.x;
            let dy = other.y - this.y;
            
            // Handle toroidal space - find shortest distance across wrapping edges
            if (TOROIDAL_SPACE) {
                if (Math.abs(dx) > canvasWidth / 2) {
                    dx = dx > 0 ? dx - canvasWidth : dx + canvasWidth;
                }
                if (Math.abs(dy) > canvasHeight / 2) {
                    dy = dy > 0 ? dy - canvasHeight : dy + canvasHeight;
                }
            }
            
            let distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate collision distance using visual sizes to prevent visual overlap
            let collisionDistance = this.visualSize + other.visualSize;
            
            // Handle collision - push particles apart if they're overlapping
            if (distance < collisionDistance && distance > 0) {
                let overlap = collisionDistance - distance;
                let separationForce = overlap * 1.0; // Increased separation strength
                
                // Normalize direction vector
                let normalizedDx = dx / distance;
                let normalizedDy = dy / distance;
                
                // Apply separation force (push away from each other)
                fx -= separationForce * normalizedDx;
                fy -= separationForce * normalizedDy;
                
                // Calculate collision force magnitude for audio
                const velocityMagnitude = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const otherVelocityMagnitude = Math.sqrt(other.vx * other.vx + other.vy * other.vy);
                const totalVelocity = velocityMagnitude + otherVelocityMagnitude;
                const collisionForce = (separationForce + totalVelocity) * 0.5; // Combined force measure
                
                // Record collision event for audio processing
                const currentTime = performance.now();
                // Calculate collision position (midpoint between particles)
                const collisionX = (this.x + other.x) / 2;
                const collisionY = (this.y + other.y) / 2;
                const collisionEvent = {
                    time: currentTime,
                    force: collisionForce,
                    otherSpecies: other.species,
                    distance: distance,
                    relativeVelocity: totalVelocity,
                    collisionX: collisionX,
                    collisionY: collisionY
                };
                
                // Add collision event to both particles
                this.collisionEvents.push(collisionEvent);
                other.collisionEvents.push({
                    ...collisionEvent,
                    otherSpecies: this.species
                });
                
                // Update current collision force
                this.collisionForce = Math.max(this.collisionForce, collisionForce);
                other.collisionForce = Math.max(other.collisionForce, collisionForce);
                this.lastCollisionTime = currentTime;
                other.lastCollisionTime = currentTime;
                
                // Debug logging (very rarely to avoid spam)
                if (Math.random() < 0.001) {
                    console.log(`💥 Collision detected - Species ${this.species} <-> ${other.species}, Force: ${collisionForce.toFixed(3)}, Position: (${collisionX.toFixed(1)}, ${collisionY.toFixed(1)})`);
                }
                
                // Apply mutual velocity damping on collision (both particles affected)
                this.vx *= 0.7;
                this.vy *= 0.7;
                other.vx *= 0.7;
                other.vy *= 0.7;
                
                // Update cached velocity after collision damping
                // (Main cache update happens at end of update method)
                
                // Add a small repulsion force to ensure separation
                const repulsionForce = 0.2;
                fx -= repulsionForce * normalizedDx;
                fy -= repulsionForce * normalizedDy;
            }

            // Skip normal force calculation if outside force range
            if (distance > MAX_FORCE_DISTANCE || distance < 1) continue;

            // Get force strength from relationship matrix
            let forceStrength = RELATIONSHIP_MATRIX[this.species][other.species];

            // Calculate force falloff (smooth falloff to 0)
            let falloff = 1 - (distance / MAX_FORCE_DISTANCE);
            falloff = falloff * falloff; // Quadratic falloff for smoother effect

            // Calculate force components
            let force = forceStrength * falloff;
            let normalizedDx = dx / distance;
            let normalizedDy = dy / distance;

            fx += force * normalizedDx;
            fy += force * normalizedDy;
        }

        // Apply gravity force if active
        if (gravityPoint.active && GRAVITY_STRENGTH > 0) {
            const gravityDx = gravityPoint.x - this.x;
            const gravityDy = gravityPoint.y - this.y;
            const gravityDistance = Math.sqrt(gravityDx * gravityDx + gravityDy * gravityDy);
            
            if (gravityDistance > 1) { // Avoid division by zero
                // Calculate gravity force (inverse square law with minimum distance)
                const minDistance = 10; // Minimum distance to prevent extreme forces (reduced for better close-range control)
                const effectiveDistance = Math.max(gravityDistance, minDistance);
                const gravityForce = GRAVITY_STRENGTH / (effectiveDistance * effectiveDistance) * 5000; // Increased scale factor for stronger response
                
                // Normalize and apply gravity
                const normalizedGravityDx = gravityDx / gravityDistance;
                const normalizedGravityDy = gravityDy / gravityDistance;
                
                fx += gravityForce * normalizedGravityDx;
                fy += gravityForce * normalizedGravityDy;
            }
        }

        // Apply forces to velocity (scaled by simulation speed)
        this.vx += fx * 0.1 * SIMULATION_SPEED;
        this.vy += fy * 0.1 * SIMULATION_SPEED;

        // Apply friction
        this.vx *= FRICTION;
        this.vy *= FRICTION;

        // Cache velocity magnitude for performance optimization
        this.velocityMagnitudeSquared = this.vx * this.vx + this.vy * this.vy;
        this.velocityMagnitude = Math.sqrt(this.velocityMagnitudeSquared);

        // Limit maximum speed using cached velocity
        if (this.velocityMagnitude > MAX_SPEED) {
            const scale = MAX_SPEED / this.velocityMagnitude;
            this.vx *= scale;
            this.vy *= scale;
            // Update cache after speed limiting
            this.velocityMagnitude = MAX_SPEED;
            this.velocityMagnitudeSquared = MAX_SPEED * MAX_SPEED;
        }

        // Update position (scaled by simulation speed)
        this.x += this.vx * SIMULATION_SPEED;
        this.y += this.vy * SIMULATION_SPEED;

        // Handle boundary conditions based on toroidal space setting
        if (TOROIDAL_SPACE) {
            // Implement toroidal wrapping
            if (this.x < 0) this.x += canvasWidth;
            if (this.x > canvasWidth) this.x -= canvasWidth;
            if (this.y < 0) this.y += canvasHeight;
            if (this.y > canvasHeight) this.y -= canvasHeight;
        } else {
            // Implement bouncing off walls
            if (this.x < this.size) {
                this.x = this.size;
                this.vx = Math.abs(this.vx) * BOUNCE_DAMPING; // Bounce with configurable damping
            }
            if (this.x > canvasWidth - this.size) {
                this.x = canvasWidth - this.size;
                this.vx = -Math.abs(this.vx) * BOUNCE_DAMPING;
            }
            if (this.y < this.size) {
                this.y = this.size;
                this.vy = Math.abs(this.vy) * BOUNCE_DAMPING;
            }
            if (this.y > canvasHeight - this.size) {
                this.y = canvasHeight - this.size;
                this.vy = -Math.abs(this.vy) * BOUNCE_DAMPING;
            }
        }
        
        // Spawn trail particle every frame when trails enabled (velocity independent)
        const speciesTrailLength = speciesTrailLengths[this.species] !== undefined ? speciesTrailLengths[this.species] : 0.75;
        
        if (speciesTrailLength > 0.01) { // Use 0.01 threshold to handle floating point precision
            // Create trail particle at current position
            trailParticles.push(new TrailParticle(
                this.x, 
                this.y, 
                this.species, 
                this.color, 
                this.visualSize
            ));
        }
        
        // Simple age increment for temporal sorting
        this.age++;
        
        // Update collision tracking for audio
        const currentTime = performance.now();
        
        // Remove old collision events (older than 100ms)
        this.collisionEvents = this.collisionEvents.filter(event => 
            currentTime - event.time < 100
        );
        
        // Decay collision force over time
        const timeSinceCollision = currentTime - this.lastCollisionTime;
        if (timeSinceCollision > 50) { // Start decaying after 50ms
            const decayFactor = Math.exp(-(timeSinceCollision - 50) / 100); // Exponential decay
            this.collisionForce *= decayFactor;
            if (this.collisionForce < 0.01) {
                this.collisionForce = 0;
            }
        }
    }
}

// ===== TRAIL PARTICLE SYSTEM =====
// TrailParticle class - lightweight, visual-only particles for trail effects
class TrailParticle {
    constructor(x, y, species, color, size) {
        // Position (fixed - trail particles don't move)
        this.x = x;
        this.y = y;
        
        // Visual properties inherited from parent particle
        this.species = species;
        this.color = [...color]; // Copy color array
        this.size = size;
        
        // Trail-specific properties
        this.creationTime = performance.now();
        this.age = 0;
        this.alpha = 1.0; // Start fully visible
    }
    
    // Update trail particle age and alpha based on species trail settings
    updateTrailParticle() {
        const currentTime = performance.now();
        this.age = currentTime - this.creationTime;
        
        // Get species trail length setting (0.0 to 0.99)
        const speciesTrailLength = speciesTrailLengths[this.species] !== undefined ? speciesTrailLengths[this.species] : 0.75;
        
        // If trail length is 0 or very close to 0, remove immediately (no trails)
        if (speciesTrailLength <= 0.01) {
            this.alpha = 0;
            return true;
        }
        
        // Simple linear fade based on species trail length setting
        const maxFadeTime = 2000; // 2 seconds maximum fade time
        const fadeTime = speciesTrailLength * maxFadeTime; // Direct relationship: 0.5 = 1 second, 1.0 = 2 seconds
        
        // Linear fade from 1.0 to 0.0 over fadeTime
        this.alpha = Math.max(0, 1.0 - (this.age / fadeTime));
        
        // Return true if trail particle should be removed
        return this.alpha <= 0;
    }
}

// Trail particles array - separate from main particles
let trailParticles = [];

// Initialize particles
function initParticles() {
    particles = [];
    
    // Create particles for each active species
    for (let species = 0; species < speciesCount; species++) {
        for (let i = 0; i < particleCounts[species]; i++) {
            particles.push(new Particle(species));
        }
    }
    
    updateParticleCountDisplay();
}

// Initialize spatial grid system
function initSpatialGrid() {
    // Use force radius as cell size for optimal performance
    spatialGrid = new SpatialGrid(canvasWidth, canvasHeight, MAX_FORCE_DISTANCE);
    console.log('🚀 Spatial partitioning enabled! Force calculations optimized from O(N²) to O(N)');
}

// ===== TRAIL PARTICLE TRAIL SYSTEM =====
// Initialize trail particle system
function initTrailSystem() {
    // Set up main 2D canvas context
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Clear main canvas to black
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    
    // Initialize empty trail particles array
    trailParticles = [];
    
    // Remove any existing off-screen canvases
    window.speciesTrailCanvases = null;
    window.speciesTrailContexts = null;
    
    console.log('🎨 Trail particle system initialized with individual species control!');
}



// ===== PARTICLE MANAGEMENT =====
// Adjust particle counts dynamically
function adjustParticleCounts() {
    // Count current particles by species
    let currentCounts = new Array(maxSpecies).fill(0);
    for (let particle of particles) {
        currentCounts[particle.species]++;
    }

    // Adjust each active species
    for (let species = 0; species < speciesCount; species++) {
        let currentCount = currentCounts[species];
        let targetCount = particleCounts[species];

        if (currentCount < targetCount) {
            // Add particles
            for (let i = currentCount; i < targetCount; i++) {
                particles.push(new Particle(species));
            }
        } else if (currentCount > targetCount) {
            // Remove particles
            let toRemove = currentCount - targetCount;
            for (let i = particles.length - 1; i >= 0 && toRemove > 0; i--) {
                if (particles[i].species === species) {
                    particles.splice(i, 1);
                    toRemove--;
                }
            }
        }
    }

    // Remove particles from inactive species
    for (let i = particles.length - 1; i >= 0; i--) {
        if (particles[i].species >= speciesCount) {
            particles.splice(i, 1);
        }
    }

    updateParticleCountDisplay();
}

// Update particle sizes
function updateParticleSizes() {
    for (let particle of particles) {
        particle.updateSize();
    }
}

// Update particle positions with audio integration
function updateParticles() {
    if (isPaused) return;
    
    // Rebuild spatial grid each frame for optimal performance
    spatialGrid.clear();
    
    // Insert all particles into spatial grid
    for (let i = 0; i < particles.length; i++) {
        spatialGrid.insertParticle(particles[i]);
    }
    
    // Update particles using spatial optimization
    for (let particle of particles) {
        particle.update();
    }
    
    // Update trail particles and remove expired ones
    updateTrailParticles();
    
    // Update audio system with new particle positions
    updateAudioSystem();
}

// Update trail particles and remove expired ones
function updateTrailParticles() {
    for (let i = trailParticles.length - 1; i >= 0; i--) {
        const trailParticle = trailParticles[i];
        const shouldRemove = trailParticle.updateTrailParticle();
        
        if (shouldRemove) {
            trailParticles.splice(i, 1);
        }
    }
}

// Remove all trail particles for a specific species (called when trail length set to 0)
function removeTrailParticlesForSpecies(speciesIndex) {
    for (let i = trailParticles.length - 1; i >= 0; i--) {
        if (trailParticles[i].species === speciesIndex) {
            trailParticles.splice(i, 1);
        }
    }
    console.log(`🧹 Cleared all trail particles for Species ${String.fromCharCode(65 + speciesIndex)}`);
}

// ===== RENDERING =====
// Render trail particles and species particles with temporal priority
function render() {
    // Get main canvas context
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Disable anti-aliasing for crisp effect
    ctx.imageSmoothingEnabled = false;
    
    // Step 1: Always clear the canvas completely 
    // Individual trail fading is handled by TrailParticle alpha values
    ctx.fillStyle = 'rgba(0, 0, 0, 1.0)';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    
    // Step 2: Render trail particles first (oldest to newest)
    ctx.globalCompositeOperation = 'source-over';
    
    // Sort trail particles by creation time (oldest first)
    const sortedTrailParticles = [...trailParticles].sort((a, b) => a.creationTime - b.creationTime);
    
    for (let trailParticle of sortedTrailParticles) {
        // Skip invisible trail particles
        if (trailParticle.alpha <= 0) continue;
        
        // Set alpha for this trail particle
        ctx.globalAlpha = trailParticle.alpha;
        
        // Get particle color
        const r = Math.round(trailParticle.color[0] * 255);
        const g = Math.round(trailParticle.color[1] * 255);
        const b = Math.round(trailParticle.color[2] * 255);
        
        // Render trail particle
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.beginPath();
        ctx.arc(trailParticle.x, trailParticle.y, trailParticle.size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Step 3: Render current species particles at full opacity (newest last)
    ctx.globalAlpha = 1.0;
    
    // Sort species particles by age (oldest first, newest last)
    const sortedParticles = [...particles].sort((a, b) => a.age - b.age);
    
    for (let particle of sortedParticles) {
        // Get particle color
        const r = Math.round(particle.color[0] * 255);
        const g = Math.round(particle.color[1] * 255);
        const b = Math.round(particle.color[2] * 255);
        
        // Render species particle at full opacity
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.visualSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Add stroke for definition
        ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.lineWidth = 1;
        ctx.stroke();
    }
    
    // Reset alpha
    ctx.globalAlpha = 1.0;
}


// ===== ANIMATION LOOP =====
// Animation loop with FPS tracking
let lastFrameTime = performance.now();
let frameCount = 0;
let fpsUpdateTime = performance.now();
let frameTimeHistory = [];

function animate() {
    const currentTime = performance.now();
    const frameTime = currentTime - lastFrameTime;
    
    updateParticles();
    render();
    
    // Track frame time for performance metrics
    frameTimeHistory.push(frameTime);
    if (frameTimeHistory.length > 60) {
        frameTimeHistory.shift(); // Keep only last 60 frames
    }
    
    // FPS and performance tracking
    frameCount++;
    if (currentTime - fpsUpdateTime >= 500) { // Update every 500ms
        const fps = Math.round((frameCount * 1000) / (currentTime - fpsUpdateTime));
        const avgFrameTime = frameTimeHistory.reduce((a, b) => a + b, 0) / frameTimeHistory.length;
        
        // Update performance displays
        const fpsElement = document.getElementById('fps-display');
        if (fpsElement) fpsElement.textContent = fps;
        
        const frameTimeElement = document.getElementById('frame-time');
        if (frameTimeElement) frameTimeElement.textContent = `${avgFrameTime.toFixed(1)}ms`;
        
        const canvasSizeElement = document.getElementById('canvas-size');
        if (canvasSizeElement) canvasSizeElement.textContent = `${canvasWidth}×${canvasHeight}`;
        
        const totalParticlesElement = document.getElementById('total-particles');
        if (totalParticlesElement) totalParticlesElement.textContent = particles.length;
        
        const trailParticlesElement = document.getElementById('trail-particles');
        if (trailParticlesElement) trailParticlesElement.textContent = trailParticles.length;
        
        // Update grid info
        if (spatialGrid) {
            const gridInfo = `${spatialGrid.gridWidth}×${spatialGrid.gridHeight}`;
            const gridElement = document.getElementById('grid-info');
            if (gridElement) gridElement.textContent = gridInfo;
        }
        
        // Update audio grain count
        let totalGrains = 0;
        if (typeof speciesAudioSynths !== 'undefined' && speciesAudioSynths.length > 0) {
            for (let synth of speciesAudioSynths) {
                if (synth && synth.grains) {
                    totalGrains += synth.grains.length;
                }
            }
        }
        const totalGrainsElement = document.getElementById('total-grains');
        if (totalGrainsElement) totalGrainsElement.textContent = totalGrains;
        
        // Update audio latency
        const audioLatencyElement = document.getElementById('audio-latency');
        if (audioLatencyElement && typeof audioContext !== 'undefined' && audioContext) {
            const latency = (audioContext.baseLatency * 1000).toFixed(1) + 'ms';
            audioLatencyElement.textContent = latency;
        }
        
        // Update species tab info
        if (typeof updateSpeciesTabInfo === 'function') {
            updateSpeciesTabInfo();
        }
        
        // Update species activity levels for audio visualization
        if (typeof updateSpeciesActivityLevels === 'function') {
            updateSpeciesActivityLevels(particles);
        }
        
        frameCount = 0;
        fpsUpdateTime = currentTime;
    }
    
    lastFrameTime = currentTime;
    requestAnimationFrame(animate);
}

// ===== CONTROL FUNCTIONS =====
// Control functions
function resetSimulation() {
    // Clear main canvas
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    
    // Clear trail particles
    trailParticles = [];
    
    // Reset particles
    initParticles();
    isPaused = false;
}

function togglePause() {
    isPaused = !isPaused;
}

function updateParticleCountDisplay() {
    // This function is no longer needed but kept for compatibility
}

// Setup canvas mouse interaction for gravity
function setupCanvasInteraction() {
    const canvas = document.getElementById('canvas');
    
    canvas.addEventListener('mousedown', (e) => {
        if (GRAVITY_STRENGTH > 0) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            gravityPoint.x = x;
            gravityPoint.y = y;
            gravityPoint.active = true;
            isMouseDown = true;
            
            console.log(`🌍 Gravity point activated at (${Math.round(x)}, ${Math.round(y)})`);
        }
        e.preventDefault();
    });
    
    canvas.addEventListener('mousemove', (e) => {
        if (isMouseDown && GRAVITY_STRENGTH > 0) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            gravityPoint.x = x;
            gravityPoint.y = y;
        }
        e.preventDefault();
    });
    
    canvas.addEventListener('mouseup', (e) => {
        if (isMouseDown) {
            gravityPoint.active = false;
            isMouseDown = false;
            console.log('🌍 Gravity point deactivated');
        }
        e.preventDefault();
    });
    
    canvas.addEventListener('mouseleave', (e) => {
        if (isMouseDown) {
            gravityPoint.active = false;
            isMouseDown = false;
            console.log('🌍 Gravity point deactivated (mouse left canvas)');
        }
    });
    
    // Update cursor based on gravity setting
    function updateCanvasCursor() {
        if (GRAVITY_STRENGTH > 0) {
            canvas.style.cursor = 'crosshair';
        } else {
            canvas.style.cursor = 'default';
        }
    }
    
    // Update cursor initially and when gravity changes
    updateCanvasCursor();
    
    // Update cursor when gravity strength changes
    document.getElementById('gravityStrength').addEventListener('input', updateCanvasCursor);
}
        
        // ===== MAIN APPLICATION =====
        // ===== CANVAS SETUP & RENDERING =====
        // 2D Canvas setup for motion blur particle system
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        if (!ctx) {
            alert('Canvas 2D not supported!');
        }

        // Canvas sizing system - using manual controls only
        let canvasWidth = 1200;
        let canvasHeight = 800;

        // Initialize canvas to default size
        function initCanvas() {
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            console.log(`🖥️ Canvas initialized to ${canvasWidth}×${canvasHeight}`);
        }

        // Particle data
        let particles = [];
        let isPaused = false;
        let spatialGrid; // Spatial partitioning system

        

        // Species management
        let speciesCount = 2;
        let maxSpecies = 8;
        let speciesColors = [
            [1.0, 0.27, 0.27], // Red
            [0.27, 0.27, 1.0], // Blue
            [0.27, 1.0, 0.27], // Green
            [1.0, 1.0, 0.27],  // Yellow
            [1.0, 0.27, 1.0],  // Magenta
            [0.27, 1.0, 1.0],  // Cyan
            [1.0, 0.5, 0.0],   // Orange
            [0.5, 0.0, 1.0]    // Purple
        ];

        // Configurable parameters
        let particleSizes = [4, 4, 4, 4, 4, 4, 4, 4];
        let particleCounts = [50, 50, 50, 50, 50, 50, 50, 50];
        let speciesTrailLengths = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]; // Individual trail fade per species (0.0-0.99 range)
        let FRICTION = 0.95;
        let MAX_FORCE_DISTANCE = 60;
        let SIMULATION_SPEED = 1.0;
        let TOROIDAL_SPACE = true; // Toggle for edge wrapping
        let GRAVITY_STRENGTH = 0.0; // Gravity pull strength
        let BOUNCE_DAMPING = 0.8; // Wall bounce damping factor (0.5-1.5)
        
        // Gravity system
        let gravityPoint = { x: 0, y: 0, active: false };
        let isMouseDown = false;

        // Species constants
        const SPECIES = {
            A: 0, // Red
            B: 1  // Blue
        };

        // Relationship matrix (force strengths) - now dynamic and expandable
        let RELATIONSHIP_MATRIX = [
            [-0.3, 0.8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],   // A relationships
            [-0.5, -0.3, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  // B relationships
            [0.0, 0.0, -0.1, 0.0, 0.0, 0.0, 0.0, 0.0],   // C relationships
            [0.0, 0.0, 0.0, -0.1, 0.0, 0.0, 0.0, 0.0],   // D relationships
            [0.0, 0.0, 0.0, 0.0, -0.1, 0.0, 0.0, 0.0],   // E relationships
            [0.0, 0.0, 0.0, 0.0, 0.0, -0.1, 0.0, 0.0],   // F relationships
            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.1, 0.0],   // G relationships
            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.1]    // H relationships
        ];

        // Force parameters
        const MAX_SPEED = 3;


        // ===== UI GENERATION =====

        // [REMOVED] Duplicate rgbToHex function - already defined above

        // ===== CONTROL SYSTEM & FORCE MATRIX =====
        // Slider event handlers
        function setupSliders() {
            // Species count slider
            document.getElementById('speciesCount').addEventListener('input', (e) => {
                speciesCount = parseInt(e.target.value);
                document.getElementById('speciesCount-value').textContent = speciesCount;
                
                // Regenerate UI and adjust particles
                createForceMatrix();
                setupDraggableNumbers();
                adjustParticleCounts();
                
                // Regenerate species tabs
                createSpeciesTabs();
                
                // Ensure current tab is valid
                if (currentSpeciesTab >= speciesCount) {
                    currentSpeciesTab = 0;
                    selectedSpeciesForAudio = 0;
                }
                
                // Regenerate audio controls if audio is initialized
                if (isAudioEnabled && speciesAudioSynths.length > 0) {
                    // Just regenerate the UI, don't recreate synths
                    createSpeciesAudioControls();
                    // Custom drag handlers already set up in createSpeciesAudioControls
                }
            });

            // Physics sliders
            document.getElementById('friction').addEventListener('input', (e) => {
                FRICTION = parseFloat(e.target.value);
                document.getElementById('friction-value').textContent = FRICTION.toFixed(2);
            });

            document.getElementById('forceRadius').addEventListener('input', (e) => {
                MAX_FORCE_DISTANCE = parseInt(e.target.value);
                document.getElementById('forceRadius-value').textContent = MAX_FORCE_DISTANCE;
                
                // Update spatial grid cell size
                if (spatialGrid) {
                    spatialGrid.updateCellSize(MAX_FORCE_DISTANCE);
                }
            });

            document.getElementById('simSpeed').addEventListener('input', (e) => {
                SIMULATION_SPEED = parseFloat(e.target.value);
                document.getElementById('simSpeed-value').textContent = SIMULATION_SPEED.toFixed(1);
            });

            document.getElementById('gravityStrength').addEventListener('input', (e) => {
                GRAVITY_STRENGTH = parseFloat(e.target.value);
                document.getElementById('gravityStrength-value').textContent = GRAVITY_STRENGTH.toFixed(1);
            });

            document.getElementById('bounceDamping').addEventListener('input', (e) => {
                BOUNCE_DAMPING = parseFloat(e.target.value);
                document.getElementById('bounceDamping-value').textContent = BOUNCE_DAMPING.toFixed(1);
            });

            document.getElementById('toroidalSpace').addEventListener('change', (e) => {
                TOROIDAL_SPACE = e.target.checked;
            });

            // Audio sliders
            document.getElementById('masterVolume').addEventListener('input', (e) => {
                setMasterVolume(parseFloat(e.target.value));
            });

            document.getElementById('freqLow').addEventListener('input', (e) => {
                const low = parseInt(e.target.value);
                const high = frequencyRange.high;
                if (low < high) {
                    setFrequencyRange(low, high);
                }
            });

            document.getElementById('freqHigh').addEventListener('input', (e) => {
                const high = parseInt(e.target.value);
                const low = frequencyRange.low;
                if (high > low) {
                    setFrequencyRange(low, high);
                }
            });

            document.getElementById('velocityGainCurve').addEventListener('input', (e) => {
                setGlobalVelocityGainCurve(parseFloat(e.target.value));
            });

            document.getElementById('velocityThreshold').addEventListener('input', (e) => {
                setGlobalVelocityThreshold(parseFloat(e.target.value));
            });

            document.getElementById('masterMute').addEventListener('click', toggleMasterMute);
            
            document.getElementById('audioInit').addEventListener('click', () => {
                initAudioSystem();
            });
            
            // Randomize matrix button
            document.getElementById('randomizeMatrix').addEventListener('click', randomizeForceMatrix);
        }

        function setupDraggableNumbers() {
            const draggableNumbers = document.querySelectorAll('.draggable-number:not(.audio-dial)');
            
            draggableNumbers.forEach(element => {
                let isDragging = false;
                let startY = 0;
                let startValue = 0;
                
                element.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startY = e.clientY;
                    startValue = parseFloat(element.textContent);
                    element.classList.add('dragging');
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaY = startY - e.clientY; // Inverted for natural feel
                    let sensitivity = 1;
                    let newValue = startValue;
                    
                    // Determine parameter type and apply appropriate sensitivity
                    if (element.id.includes('count')) {
                        sensitivity = 0.5;
                        newValue = Math.max(1, Math.min(1000, Math.round(startValue + deltaY * sensitivity)));
                        
                        // Update particle count
                        const speciesIndex = parseInt(element.id.split('-')[1]);
                        particleCounts[speciesIndex] = newValue;
                        adjustParticleCounts();
                        
                    } else if (element.id.includes('size')) {
                        sensitivity = 0.1;
                        newValue = Math.max(2, Math.min(20, Math.round((startValue + deltaY * sensitivity) * 10) / 10));
                        
                        // Update particle size
                        const speciesIndex = parseInt(element.id.split('-')[1]);
                        particleSizes[speciesIndex] = newValue;
                        updateParticleSizes();
                        
                    } else if (element.id.includes('trail')) {
                        sensitivity = 0.01;
                        newValue = Math.max(0.0, Math.min(0.99, Math.round((startValue + deltaY * sensitivity) * 100) / 100));
                        
                        // Update trail length
                        const speciesIndex = parseInt(element.id.split('-')[1]);
                        speciesTrailLengths[speciesIndex] = newValue;
                        
                        // If trail length is set to 0 or very close to 0, immediately remove all trail particles for this species
                        if (newValue <= 0.01) {
                            removeTrailParticlesForSpecies(speciesIndex);
                        }
                        
                    } else if (element.id.includes('correlation')) {
                        sensitivity = 0.05;
                        newValue = Math.max(0.1, Math.min(5.0, Math.round((startValue + deltaY * sensitivity) * 10) / 10));
                        
                        // Update size correlation factor
                        const speciesIndex = parseInt(element.id.split('-')[1]);
                        if (speciesAudioSynths[speciesIndex]) {
                            speciesAudioSynths[speciesIndex].setSizeCorrelationFactor(newValue);
                        }
                        
                    } else if (element.id.includes('velocity')) {
                        sensitivity = 0.1;
                        newValue = Math.max(0.1, Math.min(10.0, Math.round((startValue + deltaY * sensitivity) * 10) / 10));
                        
                        // Update velocity scale factor
                        const speciesIndex = parseInt(element.id.split('-')[1]);
                        if (speciesAudioSynths[speciesIndex]) {
                            speciesAudioSynths[speciesIndex].setVelocityScale(newValue);
                        }
                        
                    } else if (element.id.includes('threshold')) {
                        sensitivity = 0.01;
                        newValue = Math.max(0.0, Math.min(0.5, Math.round((startValue + deltaY * sensitivity) * 100) / 100));
                        
                        // Update volume threshold
                        const speciesIndex = parseInt(element.id.split('-')[1]);
                        if (speciesAudioSynths[speciesIndex]) {
                            speciesAudioSynths[speciesIndex].setVolumeThreshold(newValue);
                        }
                        
                    } else if (element.id === 'canvas-width') {
                        sensitivity = 5;
                        newValue = Math.max(400, Math.min(1600, Math.round(startValue + deltaY * sensitivity)));
                        
                        // Update canvas width
                        updateCanvasSize(newValue, canvasHeight);
                        
                    } else if (element.id === 'canvas-height') {
                        sensitivity = 3;
                        newValue = Math.max(300, Math.min(1200, Math.round(startValue + deltaY * sensitivity)));
                        
                        // Update canvas height
                        updateCanvasSize(canvasWidth, newValue);
                    }
                    
                    if (element.id.includes('trail')) {
                        element.textContent = newValue.toFixed(2);
                    } else if (element.id.includes('correlation')) {
                        element.textContent = newValue.toFixed(1) + 'x';
                    } else if (element.id.includes('velocity')) {
                        element.textContent = newValue.toFixed(1) + 'x';
                    } else if (element.id.includes('threshold')) {
                        element.textContent = newValue.toFixed(2);
                    } else {
                        element.textContent = newValue;
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        element.classList.remove('dragging');
                    }
                });
            });
        }

        function createForceMatrix() {
            const matrixGrid = document.getElementById('forceMatrix');
            matrixGrid.innerHTML = '';
            
            // Set grid layout
            matrixGrid.style.gridTemplateColumns = `repeat(${speciesCount + 1}, 1fr)`;
            
            // Add corner cell (empty)
            const cornerCell = document.createElement('div');
            cornerCell.className = 'matrix-header';
            matrixGrid.appendChild(cornerCell);
            
            // Add column headers
            for (let i = 0; i < speciesCount; i++) {
                const header = document.createElement('div');
                header.className = 'matrix-header';
                header.style.color = rgbToHex(speciesColors[i]);
                header.innerHTML = `<span>${String.fromCharCode(65 + i)}</span>`;
                matrixGrid.appendChild(header);
            }
            
            // Add row headers and matrix cells
            for (let fromSpecies = 0; fromSpecies < speciesCount; fromSpecies++) {
                // Row header
                const rowHeader = document.createElement('div');
                rowHeader.className = 'matrix-header';
                rowHeader.style.color = rgbToHex(speciesColors[fromSpecies]);
                rowHeader.textContent = String.fromCharCode(65 + fromSpecies);
                matrixGrid.appendChild(rowHeader);
                
                // Matrix cells for this row
                for (let toSpecies = 0; toSpecies < speciesCount; toSpecies++) {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    cell.dataset.from = fromSpecies;
                    cell.dataset.to = toSpecies;
                    
                    const value = RELATIONSHIP_MATRIX[fromSpecies][toSpecies];
                    cell.textContent = value.toFixed(1);
                    
                    // Color coding based on force value
                    if (value > 0.1) {
                        // Green for attraction (positive values)
                        const intensity = Math.abs(value);
                        cell.style.backgroundColor = `rgb(${Math.round(50 * (1 - intensity))}, ${Math.round(150 + intensity * 105)}, ${Math.round(50 * (1 - intensity))})`;
                    } else if (value < -0.1) {
                        // Red for repulsion (negative values)
                        const intensity = Math.abs(value);
                        cell.style.backgroundColor = `rgb(${Math.round(150 + intensity * 105)}, ${Math.round(50 * (1 - intensity))}, ${Math.round(50 * (1 - intensity))})`;
                    } else {
                        cell.style.backgroundColor = '#666';
                    }
                    
                    // Add drag interaction for force values
                    (function(cellElement, from, to) {
                        let isDragging = false;
                        let startY = 0;
                        let startValue = 0;
                        
                        cellElement.addEventListener('mousedown', (e) => {
                            isDragging = true;
                            startY = e.clientY;
                            startValue = RELATIONSHIP_MATRIX[from][to];
                            cellElement.classList.add('dragging');
                            e.preventDefault();
                        });
                        
                        const handleMouseMove = (e) => {
                            if (!isDragging) return;
                            
                            const deltaY = startY - e.clientY;
                            const sensitivity = 0.01;
                            const newValue = Math.max(-1, Math.min(1, startValue + deltaY * sensitivity));
                            const clampedValue = Math.round(newValue * 10) / 10;
                            
                            cellElement.textContent = clampedValue.toFixed(1);
                            
                            // Update color
                            if (clampedValue > 0.1) {
                                // Green for attraction (positive values)
                                const intensity = Math.abs(clampedValue);
                                cellElement.style.backgroundColor = `rgb(${Math.round(50 * (1 - intensity))}, ${Math.round(150 + intensity * 105)}, ${Math.round(50 * (1 - intensity))})`;
                            } else if (clampedValue < -0.1) {
                                // Red for repulsion (negative values)
                                const intensity = Math.abs(clampedValue);
                                cellElement.style.backgroundColor = `rgb(${Math.round(150 + intensity * 105)}, ${Math.round(50 * (1 - intensity))}, ${Math.round(50 * (1 - intensity))})`;
                            } else {
                                cellElement.style.backgroundColor = '#666';
                            }
                            
                            // Update the relationship matrix
                            RELATIONSHIP_MATRIX[from][to] = clampedValue;
                        };
                        
                        const handleMouseUp = () => {
                            if (isDragging) {
                                isDragging = false;
                                cellElement.classList.remove('dragging');
                            }
                        };
                        
                        document.addEventListener('mousemove', handleMouseMove);
                        document.addEventListener('mouseup', handleMouseUp);
                    })(cell, fromSpecies, toSpecies);
                    
                    matrixGrid.appendChild(cell);
                }
            }
        }

        // Ensure matrix size matches species count
        function ensureMatrixSize() {
            while (RELATIONSHIP_MATRIX.length < maxSpecies) {
                RELATIONSHIP_MATRIX.push(new Array(maxSpecies).fill(-0.1));
            }
            for (let i = 0; i < RELATIONSHIP_MATRIX.length; i++) {
                while (RELATIONSHIP_MATRIX[i].length < maxSpecies) {
                    RELATIONSHIP_MATRIX[i].push(-0.1);
                }
            }
        }

        function randomizeForceMatrix() {
            // Randomize the relationship matrix values
            for (let i = 0; i < speciesCount; i++) {
                for (let j = 0; j < speciesCount; j++) {
                    // Generate random value between -1 and 1, rounded to 1 decimal place
                    RELATIONSHIP_MATRIX[i][j] = Math.round((Math.random() * 2 - 1) * 10) / 10;
                }
            }
            
            // Recreate the matrix UI to reflect new values
            createForceMatrix();
            
            console.log('🎲 Force matrix randomized');
        }

        function updateCanvasSize(newWidth, newHeight) {
            // Store old dimensions for proportional scaling
            const oldWidth = canvasWidth;
            const oldHeight = canvasHeight;
            
            // Update canvas dimensions
            canvasWidth = newWidth;
            canvasHeight = newHeight;
            
            // Update canvas size
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // No species trail canvases to update in single canvas system
            
            // Update WebGL viewport (if WebGL context exists)
            if (typeof gl !== 'undefined' && gl) {
                gl.viewport(0, 0, canvasWidth, canvasHeight);
            }
            
            // Scale particle positions proportionally (preserves audio mappings)
            if (particles.length > 0 && oldWidth > 0 && oldHeight > 0) {
                const scaleX = canvasWidth / oldWidth;
                const scaleY = canvasHeight / oldHeight;
                
                for (let particle of particles) {
                    particle.x *= scaleX;
                    particle.y *= scaleY;
                    
                }
            }
            
            // Update spatial grid for new dimensions
            if (spatialGrid) {
                spatialGrid.canvasWidth = canvasWidth;
                spatialGrid.canvasHeight = canvasHeight;
                spatialGrid.gridWidth = Math.ceil(canvasWidth / spatialGrid.cellSize);
                spatialGrid.gridHeight = Math.ceil(canvasHeight / spatialGrid.cellSize);
                
                // Recreate grid with new dimensions
                const newSize = spatialGrid.gridWidth * spatialGrid.gridHeight;
                spatialGrid.grid = [];
                for (let i = 0; i < newSize; i++) {
                    spatialGrid.grid[i] = [];
                }
            }
            
            // Update gravity point if active (scale it proportionally)
            if (gravityPoint.active && oldWidth > 0 && oldHeight > 0) {
                gravityPoint.x *= (canvasWidth / oldWidth);
                gravityPoint.y *= (canvasHeight / oldHeight);
            }
            
            // Update the canvas size display
            document.getElementById('canvas-size').textContent = `${canvasWidth}×${canvasHeight}`;
            
            // Update the draggable controls
            document.getElementById('canvas-width').textContent = canvasWidth;
            document.getElementById('canvas-height').textContent = canvasHeight;
        }

        // ===== TAB SYSTEM =====
        // Tab switching functionality
        function initTabSystem() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabPanels = document.querySelectorAll('.tab-panel');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetTab = button.getAttribute('data-tab');
                    
                    // Remove active class from all buttons and panels
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabPanels.forEach(panel => panel.classList.remove('active'));
                    
                    // Add active class to clicked button
                    button.classList.add('active');
                    
                    // Show corresponding panel
                    const targetPanel = document.getElementById(`${targetTab}-panel`);
                    if (targetPanel) {
                        targetPanel.classList.add('active');
                    }
                });
            });
            
            console.log('🎯 Tab system initialized');
        }
        
        // ===== COLLAPSIBLE SECTIONS =====
        function toggleCollapsible(sectionId) {
            const section = document.getElementById(sectionId);
            const content = section.querySelector('.collapsible-content');
            const toggle = section.querySelector('.collapsible-toggle');
            
            section.classList.toggle('collapsed');
            content.classList.toggle('collapsed');
            
            // Save state to localStorage
            const isCollapsed = section.classList.contains('collapsed');
            localStorage.setItem(`collapsible-${sectionId}`, isCollapsed.toString());
        }
        
        // Initialize collapsible sections from saved state
        function initCollapsibleSections() {
            const sections = document.querySelectorAll('.collapsible-section');
            sections.forEach(section => {
                const sectionId = section.id;
                const saved = localStorage.getItem(`collapsible-${sectionId}`);
                if (saved === 'true') {
                    section.classList.add('collapsed');
                    const content = section.querySelector('.collapsible-content');
                    content.classList.add('collapsed');
                }
            });
        }
        
        // ===== SPECIES TAB SYSTEM =====
        let currentSpeciesTab = 0;
        
        function createSpeciesTabs() {
            const tabContainer = document.getElementById('speciesTabs');
            if (!tabContainer) return;
            
            tabContainer.innerHTML = '';
            
            for (let i = 0; i < speciesCount; i++) {
                const tab = document.createElement('div');
                tab.className = 'species-tab';
                if (i === currentSpeciesTab) tab.classList.add('active');
                tab.style.color = rgbToHex(speciesColors[i]);
                tab.addEventListener('click', () => selectSpeciesTab(i));
                
                const label = document.createElement('div');
                label.className = 'species-tab-label';
                label.textContent = `Species ${String.fromCharCode(65 + i)}`;
                
                const info = document.createElement('div');
                info.className = 'species-tab-info';
                
                const particleCount = document.createElement('span');
                particleCount.textContent = particleCounts[i] || 0;
                particleCount.id = `species-count-${i}`;
                
                const audioStatus = document.createElement('div');
                audioStatus.className = 'species-audio-status';
                audioStatus.id = `species-audio-status-${i}`;
                audioStatus.title = 'Click to mute/unmute';
                audioStatus.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent tab selection when clicking the status
                    toggleSpeciesMute(i);
                });
                
                info.appendChild(particleCount);
                info.appendChild(audioStatus);
                
                tab.appendChild(label);
                tab.appendChild(info);
                tabContainer.appendChild(tab);
            }
            
            console.log(`🎯 Created ${speciesCount} species tabs`);
        }
        
        function selectSpeciesTab(speciesIndex) {
            if (speciesIndex === currentSpeciesTab) return;
            
            currentSpeciesTab = speciesIndex;
            selectedSpeciesForAudio = speciesIndex;
            
            // Update tab appearance
            const tabs = document.querySelectorAll('.species-tab');
            tabs.forEach((tab, index) => {
                tab.classList.toggle('active', index === speciesIndex);
            });
            
            // Regenerate audio controls for selected species
            createSpeciesAudioControls();
            
            // Setup draggable numbers
            if (typeof setupDraggableNumbers === 'function') {
                setTimeout(() => setupDraggableNumbers(), 0);
            }
            
            console.log(`🎯 Selected species ${String.fromCharCode(65 + speciesIndex)}`);
        }
        
        // Update species tab info (particle counts, audio status)
        function updateSpeciesTabInfo() {
            for (let i = 0; i < speciesCount; i++) {
                const countElement = document.getElementById(`species-count-${i}`);
                if (countElement) {
                    countElement.textContent = particleCounts[i] || 0;
                }
                
                const statusElement = document.getElementById(`species-audio-status-${i}`);
                if (statusElement && speciesAudioSynths[i]) {
                    const hasAudio = speciesAudioSynths[i].audioBuffer && isAudioEnabled;
                    const isMuted = speciesAudioSynths[i].isMuted;
                    const isActive = hasAudio && !isMuted;
                    
                    // Reset classes
                    statusElement.classList.remove('active', 'muted');
                    
                    if (hasAudio) {
                        if (isMuted) {
                            statusElement.classList.add('muted');
                        } else {
                            statusElement.classList.add('active');
                        }
                    }
                }
            }
        }
        
        // ===== KEYBOARD SHORTCUTS =====
        let keyboardEnabled = true;
        
        function initKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Skip if user is typing in an input field
                if (['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) {
                    return;
                }
                
                if (!keyboardEnabled) return;
                
                switch(e.code) {
                    case 'Space':
                        e.preventDefault();
                        togglePause();
                        showToast('Simulation ' + (isPaused ? 'Paused' : 'Resumed'));
                        break;
                        
                    case 'KeyR':
                        if (e.ctrlKey || e.metaKey) return; // Don't interfere with refresh
                        e.preventDefault();
                        resetSimulation();
                        showToast('Simulation Reset');
                        break;
                        
                    case 'KeyM':
                        e.preventDefault();
                        toggleMasterMute();
                        showToast('Master ' + (isMasterMuted ? 'Muted' : 'Unmuted'));
                        break;
                        
                    case 'KeyS':
                        if (e.ctrlKey || e.metaKey) return; // Don't interfere with save
                        e.preventDefault();
                        soloCurrentSpecies();
                        break;
                        
                    case 'Equal': // Plus key
                        if (!e.shiftKey) break; // Only on Shift+= (+)
                        e.preventDefault();
                        adjustMasterVolume(0.05);
                        break;
                        
                    case 'Minus':
                        e.preventDefault();
                        adjustMasterVolume(-0.05);
                        break;
                        
                    case 'Digit1':
                    case 'Digit2':
                    case 'Digit3':
                    case 'Digit4':
                    case 'Digit5':
                    case 'Digit6':
                    case 'Digit7':
                    case 'Digit8':
                        e.preventDefault();
                        const speciesIndex = parseInt(e.code.slice(-1)) - 1;
                        if (speciesIndex < speciesCount) {
                            selectSpeciesTab(speciesIndex);
                            showToast(`Species ${String.fromCharCode(65 + speciesIndex)} Selected`);
                        }
                        break;
                        
                    case 'ArrowUp':
                    case 'ArrowDown':
                    case 'ArrowLeft':
                    case 'ArrowRight':
                        // Fine-tune selected parameter (could be expanded)
                        e.preventDefault();
                        break;
                        
                    case 'KeyH':
                        e.preventDefault();
                        toggleKeyboardShortcuts();
                        break;
                }
            });
            
            console.log('⌨️ Keyboard shortcuts initialized');
        }
        
        function adjustMasterVolume(delta) {
            const newVolume = Math.max(0, Math.min(1, masterVolume + delta));
            setMasterVolume(newVolume);
            document.getElementById('masterVolume').value = newVolume;
            showToast(`Master Volume: ${Math.round(newVolume * 100)}%`);
        }
        
        function soloCurrentSpecies() {
            const currentSynth = speciesAudioSynths[currentSpeciesTab];
            if (!currentSynth) return;
            
            // Toggle solo: if current is unmuted and others are muted, unmute all
            // Otherwise, mute all except current
            let othersMuted = true;
            for (let i = 0; i < speciesCount; i++) {
                if (i !== currentSpeciesTab && speciesAudioSynths[i] && !speciesAudioSynths[i].isMuted) {
                    othersMuted = false;
                    break;
                }
            }
            
            if (!currentSynth.isMuted && othersMuted) {
                // Unsolo - unmute all
                for (let i = 0; i < speciesCount; i++) {
                    if (speciesAudioSynths[i]) {
                        speciesAudioSynths[i].setMute(false);
                    }
                }
                updateSpeciesTabInfo();
                showToast('All Species Unmuted');
            } else {
                // Solo current species
                for (let i = 0; i < speciesCount; i++) {
                    const shouldMute = i !== currentSpeciesTab;
                    if (speciesAudioSynths[i]) {
                        speciesAudioSynths[i].setMute(shouldMute);
                    }
                }
                updateSpeciesTabInfo();
                showToast(`Species ${String.fromCharCode(65 + currentSpeciesTab)} Soloed`);
            }
        }
        
        function toggleKeyboardShortcuts() {
            const shortcuts = document.getElementById('keyboardShortcuts');
            const isHidden = shortcuts.classList.contains('hidden');
            
            if (isHidden) {
                shortcuts.classList.remove('hidden');
                showToast('Shortcuts shown');
            } else {
                shortcuts.classList.add('hidden');
                showToast('Shortcuts hidden');
            }
            
            // Save state to localStorage
            localStorage.setItem('keyboardShortcuts-hidden', (!isHidden).toString());
        }
        
        function initKeyboardShortcutsDisplay() {
            const shortcuts = document.getElementById('keyboardShortcuts');
            const isHidden = localStorage.getItem('keyboardShortcuts-hidden') === 'true';
            
            if (isHidden) {
                shortcuts.classList.add('hidden');
            }
            
            console.log('⌨️ Keyboard shortcuts display initialized');
        }
        
        // ===== TOAST NOTIFICATIONS =====
        function showToast(message, duration = 2000) {
            // Remove existing toast
            const existingToast = document.getElementById('toast');
            if (existingToast) {
                existingToast.remove();
            }
            
            // Create new toast
            const toast = document.createElement('div');
            toast.id = 'toast';
            toast.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: #333;
                color: #fff;
                padding: 10px 20px;
                border-radius: 6px;
                border: 1px solid #555;
                font-size: 14px;
                font-weight: bold;
                z-index: 10000;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
                font-family: Arial, sans-serif;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                max-width: 300px;
            `;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            // Animate in
            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateX(0)';
            }, 10);
            
            // Animate out and remove
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.remove();
                    }
                }, 300);
            }, duration);
        }
        
        // ===== PRESET SYSTEM =====
        function getCurrentState() {
            const state = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                
                // Canvas settings
                canvasWidth: canvasWidth,
                canvasHeight: canvasHeight,
                
                // Species settings
                speciesCount: speciesCount,
                particleCounts: [...particleCounts],
                particleSizes: [...particleSizes],
                speciesTrailLengths: [...speciesTrailLengths],
                speciesColors: speciesColors.map(color => [...color]),
                
                // Physics settings
                friction: FRICTION,
                maxForceDistance: MAX_FORCE_DISTANCE,
                simulationSpeed: SIMULATION_SPEED,
                toroidalSpace: TOROIDAL_SPACE,
                gravityStrength: GRAVITY_STRENGTH,
                bounceDamping: BOUNCE_DAMPING,
                relationshipMatrix: RELATIONSHIP_MATRIX.map(row => [...row]),
                
                // Audio settings
                masterVolume: masterVolume,
                frequencyRange: {...frequencyRange},
                globalVelocityGainCurve: globalVelocityGainCurve,
                globalVelocityThreshold: globalVelocityThreshold,
                
                // Species audio settings (excluding audio buffers)
                speciesAudioSettings: speciesAudioSynths.map(synth => ({
                    volume: synth ? synth.volume : 0.7,
                    isMuted: synth ? synth.isMuted : false,
                    loopMode: synth ? synth.loopMode : 'forward',
                    pitch: synth ? synth.pitch : 0,
                    detune: synth ? synth.detune : 0,
                    fadeLength: synth ? synth.fadeLength : 0.002,
                    sampleStart: synth ? synth.sampleStart : 0.0,
                    sampleEnd: synth ? synth.sampleEnd : 1.0
                }))
            };
            
            return state;
        }
        
        function applyState(state) {
            try {
                // Validate version compatibility
                if (!state.version || state.version !== '1.0') {
                    throw new Error('Incompatible preset version');
                }
                
                // Apply canvas settings
                updateCanvasSize(state.canvasWidth || 1200, state.canvasHeight || 800);
                
                // Apply species settings
                speciesCount = state.speciesCount || 2;
                document.getElementById('speciesCount').value = speciesCount;
                document.getElementById('speciesCount-value').textContent = speciesCount;
                
                if (state.particleCounts) particleCounts.splice(0, particleCounts.length, ...state.particleCounts);
                if (state.particleSizes) particleSizes.splice(0, particleSizes.length, ...state.particleSizes);
                if (state.speciesTrailLengths) speciesTrailLengths.splice(0, speciesTrailLengths.length, ...state.speciesTrailLengths);
                if (state.speciesColors) {
                    speciesColors.splice(0, speciesColors.length, ...state.speciesColors.map(color => [...color]));
                }
                
                // Apply physics settings
                FRICTION = state.friction || 0.95;
                MAX_FORCE_DISTANCE = state.maxForceDistance || 60;
                SIMULATION_SPEED = state.simulationSpeed || 1.0;
                TOROIDAL_SPACE = state.toroidalSpace !== undefined ? state.toroidalSpace : true;
                GRAVITY_STRENGTH = state.gravityStrength || 0.0;
                BOUNCE_DAMPING = state.bounceDamping || 0.8;
                
                if (state.relationshipMatrix) {
                    RELATIONSHIP_MATRIX.splice(0, RELATIONSHIP_MATRIX.length, ...state.relationshipMatrix.map(row => [...row]));
                }
                
                // Update physics UI
                document.getElementById('friction').value = FRICTION;
                document.getElementById('friction-value').textContent = FRICTION.toFixed(2);
                document.getElementById('forceRadius').value = MAX_FORCE_DISTANCE;
                document.getElementById('forceRadius-value').textContent = MAX_FORCE_DISTANCE;
                document.getElementById('simSpeed').value = SIMULATION_SPEED;
                document.getElementById('simSpeed-value').textContent = SIMULATION_SPEED.toFixed(1);
                document.getElementById('gravityStrength').value = GRAVITY_STRENGTH;
                document.getElementById('gravityStrength-value').textContent = GRAVITY_STRENGTH.toFixed(1);
                document.getElementById('bounceDamping').value = BOUNCE_DAMPING;
                document.getElementById('bounceDamping-value').textContent = BOUNCE_DAMPING.toFixed(1);
                document.getElementById('toroidalSpace').checked = TOROIDAL_SPACE;
                
                // Apply audio settings
                masterVolume = state.masterVolume || 0.3;
                document.getElementById('masterVolume').value = masterVolume;
                setMasterVolume(masterVolume);
                
                if (state.frequencyRange) {
                    setFrequencyRange(state.frequencyRange.low || 80, state.frequencyRange.high || 8000);
                    document.getElementById('freqLow').value = frequencyRange.low;
                    document.getElementById('freqHigh').value = frequencyRange.high;
                }
                
                setGlobalVelocityGainCurve(state.globalVelocityGainCurve || 1.0);
                document.getElementById('velocityGainCurve').value = globalVelocityGainCurve;
                
                setGlobalVelocityThreshold(state.globalVelocityThreshold || 0.0);
                document.getElementById('velocityThreshold').value = globalVelocityThreshold;
                
                // Apply species audio settings (preserve existing audio buffers)
                if (state.speciesAudioSettings) {
                    state.speciesAudioSettings.forEach((settings, i) => {
                        if (speciesAudioSynths[i] && settings) {
                            speciesAudioSynths[i].volume = settings.volume || 0.7;
                            speciesAudioSynths[i].isMuted = settings.isMuted || false;
                            speciesAudioSynths[i].loopMode = settings.loopMode || 'forward';
                            speciesAudioSynths[i].pitch = settings.pitch || 0;
                            speciesAudioSynths[i].detune = settings.detune || 0;
                            speciesAudioSynths[i].fadeLength = settings.fadeLength || 0.002;
                            speciesAudioSynths[i].sampleStart = settings.sampleStart || 0.0;
                            speciesAudioSynths[i].sampleEnd = settings.sampleEnd || 1.0;
                        }
                    });
                }
                
                // Regenerate UI
                ensureMatrixSize();
                createForceMatrix();
                createSpeciesTabs();
                adjustParticleCounts();
                
                // Update spatial grid if needed
                if (spatialGrid) {
                    spatialGrid.updateCellSize(MAX_FORCE_DISTANCE);
                }
                
                // Regenerate audio controls
                if (isAudioEnabled) {
                    createSpeciesAudioControls();
                    // Custom drag handlers already set up in createSpeciesAudioControls
                }
                
                console.log('⚙️ Preset applied successfully');
                return true;
                
            } catch (error) {
                console.error('Failed to apply preset:', error);
                showToast('Failed to load preset: ' + error.message, 3000);
                return false;
            }
        }
        
        function savePreset() {
            const name = prompt('Enter preset name:');
            if (!name || !name.trim()) return;
            
            const state = getCurrentState();
            state.name = name.trim();
            
            // Save to localStorage
            const presets = getStoredPresets();
            presets[name] = state;
            localStorage.setItem('granular-presets', JSON.stringify(presets));
            
            updatePresetSelect();
            showToast(`Preset "${name}" saved`);
            
            console.log(`💾 Preset saved: ${name}`);
        }
        
        function loadPreset() {
            const select = document.getElementById('presetSelect');
            const presetName = select.value;
            
            if (!presetName) {
                showToast('Please select a preset to load');
                return;
            }
            
            const presets = getStoredPresets();
            const preset = presets[presetName];
            
            if (!preset) {
                showToast('Preset not found');
                return;
            }
            
            if (applyState(preset)) {
                showToast(`Preset "${presetName}" loaded`);
                console.log(`📁 Preset loaded: ${presetName}`);
            }
        }
        
        function deletePreset() {
            const select = document.getElementById('presetSelect');
            const presetName = select.value;
            
            if (!presetName) {
                showToast('Please select a preset to delete');
                return;
            }
            
            if (!confirm(`Delete preset "${presetName}"?`)) {
                return;
            }
            
            const presets = getStoredPresets();
            delete presets[presetName];
            localStorage.setItem('granular-presets', JSON.stringify(presets));
            
            updatePresetSelect();
            showToast(`Preset "${presetName}" deleted`);
            
            console.log(`🗑️ Preset deleted: ${presetName}`);
        }
        
        function exportPreset() {
            const select = document.getElementById('presetSelect');
            const presetName = select.value;
            
            let preset, filename;
            
            if (presetName) {
                const presets = getStoredPresets();
                preset = presets[presetName];
                filename = `granular-preset-${presetName.replace(/[^a-zA-Z0-9]/g, '-')}.json`;
            } else {
                preset = getCurrentState();
                preset.name = 'Current State';
                filename = `granular-preset-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
            }
            
            if (!preset) {
                showToast('No preset to export');
                return;
            }
            
            // Create download link
            const dataStr = JSON.stringify(preset, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportLink = document.createElement('a');
            exportLink.setAttribute('href', dataUri);
            exportLink.setAttribute('download', filename);
            exportLink.click();
            
            showToast(`Preset exported as ${filename}`);
            
            console.log(`📤 Preset exported: ${filename}`);
        }
        
        function importPreset() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const preset = JSON.parse(e.target.result);
                        
                        if (applyState(preset)) {
                            // Also save to localStorage if it has a name
                            if (preset.name) {
                                const presets = getStoredPresets();
                                presets[preset.name] = preset;
                                localStorage.setItem('granular-presets', JSON.stringify(presets));
                                updatePresetSelect();
                                showToast(`Preset "${preset.name}" imported and saved`);
                            } else {
                                showToast('Preset imported (not saved)');
                            }
                        }
                    } catch (error) {
                        console.error('Import error:', error);
                        showToast('Invalid preset file');
                    }
                };
                reader.readAsText(file);
            });
            input.click();
        }
        
        function getStoredPresets() {
            try {
                return JSON.parse(localStorage.getItem('granular-presets') || '{}');
            } catch (error) {
                console.error('Failed to load presets:', error);
                return {};
            }
        }
        
        function updatePresetSelect() {
            const select = document.getElementById('presetSelect');
            const presets = getStoredPresets();
            
            select.innerHTML = '<option value="">Select Preset...</option>';
            
            Object.keys(presets).sort().forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
        }
        
        function initPresetSystem() {
            updatePresetSelect();
            
            // Add import functionality to the load button's context menu
            const loadButton = document.querySelector('button[onclick="loadPreset()"]');
            if (loadButton) {
                loadButton.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    importPreset();
                });
                loadButton.title = 'Left-click: Load selected preset\nRight-click: Import preset file';
            }
            
            console.log('🎯 Preset system initialized');
        }

        // ===== INITIALIZATION =====
        // Initialize and start
        initCanvas(); // Initialize canvas to default size
        ensureMatrixSize();
        createForceMatrix();
        setupSliders();
        setupDraggableNumbers();
        setupCanvasInteraction(); // Setup gravity interaction
        initSpatialGrid(); // Initialize spatial partitioning system
        initTrailSystem(); // Initialize colorful trail system
        initParticles();
        
        // Initialize audio UI (controls visible immediately)
        initAudioUI();
        updateAudioStatus('Click to Start');
        
        // Initialize interface systems
        initTabSystem();
        initCollapsibleSections();
        createSpeciesTabs();
        initKeyboardShortcuts();
        initKeyboardShortcutsDisplay();
        initPresetSystem();
        
        animate(); // Use original animation loop from physics-core.js
    </script>
</body>
</html>